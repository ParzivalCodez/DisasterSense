{
  "version": 3,
  "sources": ["../src/configure/index.ts", "../src/messaging/Messaging.ts", "../src/BaseNamespace.ts", "../src/utils/internals.ts", "../src/Session.ts", "../src/ListenSubscriber.ts", "../src/messaging/workers/messagingWorker.ts", "../src/messaging/Message.ts", "../src/chat/Chat.ts", "../src/chat/BaseChat.ts", "../src/chat/workers/chatWorker.ts", "../src/pubSub/PubSub.ts", "../src/pubSub/workers/pubSubWorker.ts", "../src/task/Task.ts", "../src/task/workers/taskWorker.ts", "../src/voice/Voice.ts", "../src/voice/workers/voiceCallReceiveWorker.ts", "../src/voice/Call.ts", "../src/voice/utils.ts", "../src/voice/Playlist.ts", "../src/voice/CallPlayback/CallPlayback.ts", "../src/decoratePromise.ts", "../src/voice/CallPlayback/decoratePlaybackPromise.ts", "../src/voice/CallRecording/CallRecording.ts", "../src/voice/CallRecording/decorateRecordingPromise.ts", "../src/voice/CallPrompt/CallPrompt.ts", "../src/voice/CallPrompt/decoratePromptPromise.ts", "../src/voice/CallCollect/CallCollect.ts", "../src/voice/CallCollect/decorateCollectPromise.ts", "../src/voice/CallTap/CallTap.ts", "../src/voice/CallTap/decorateTapPromise.ts", "../src/voice/DeviceBuilder.ts", "../src/voice/CallDetect/CallDetect.ts", "../src/voice/CallDetect/decorateDetectPromise.ts", "../src/voice/workers/handlers/callStateEventsHandler.ts", "../src/voice/workers/handlers/callConnectEventsHandler.ts", "../src/voice/workers/handlers/callDialEventsHandler.ts", "../src/voice/workers/voiceCallPlayWorker.ts", "../src/voice/workers/voiceCallRecordWorker.ts", "../src/voice/workers/voiceCallCollectWorker.ts", "../src/voice/workers/voiceCallTapWorker.ts", "../src/voice/workers/voiceCallConnectWorker.ts", "../src/voice/workers/voiceCallDialWorker.ts", "../src/voice/workers/VoiceCallSendDigitWorker.ts", "../src/voice/workers/voiceCallDetectWorker.ts", "../src/video/Video.ts", "../src/video/RoomSession.ts", "../src/video/RoomSessionMember/RoomSessionMember.ts", "../src/video/methods/methods.ts", "../src/video/RoomSessionPlayback/RoomSessionPlayback.ts", "../src/video/RoomSessionPlayback/decoratePlaybackPromise.ts", "../src/video/RoomSessionRecording/RoomSessionRecording.ts", "../src/video/RoomSessionRecording/decorateRecordingPromise.ts", "../src/video/RoomSessionStream/RoomSessionStream.ts", "../src/video/RoomSessionStream/decorateStreamPromise.ts", "../src/video/BaseVideo.ts", "../src/video/workers/videoCallingWorker.ts", "../src/video/workers/videoRoomWorker.ts", "../src/video/workers/videoMemberWorker.ts", "../src/video/workers/videoLayoutWorker.ts", "../src/video/workers/videoRoomAudienceWorker.ts", "../src/video/workers/videoRecordingWorker.ts", "../src/video/workers/videoPlaybackWorker.ts", "../src/video/workers/videoStreamWorker.ts", "../src/client/createClient.ts", "../src/client/Client.ts", "../src/client/clientConnect.ts", "../src/SWClient.ts", "../src/SignalWire.ts"],
  "sourcesContent": ["export interface GlobalConfig {\n  token?: string\n  project?: string\n}\n\nlet GLOBAL_CONFIG: GlobalConfig = {}\n\nexport const getConfig = (): GlobalConfig => {\n  return GLOBAL_CONFIG\n}\n\n/** @ignore */\nexport interface ConfigOptions extends GlobalConfig {\n  /** @internal */\n  cache?: GlobalConfig\n}\n\n/** @internal */\nexport const config = ({\n  cache = GLOBAL_CONFIG,\n  ...options\n}: ConfigOptions) => {\n  if (cache) {\n    GLOBAL_CONFIG = cache\n  }\n\n  Object.entries(options).forEach(([key, value]) => {\n    // TODO: filter out properties\n    // @ts-expect-error\n    GLOBAL_CONFIG[key] = value\n  })\n}\n", "import { MessagingEventNames, toExternalJSON } from '@signalwire/core'\nimport { BaseNamespace } from '../BaseNamespace'\nimport { SWClient } from '../SWClient'\nimport { Message } from './Message'\nimport { messagingWorker } from './workers'\n\ninterface MessageListenOptions {\n  topics: string[]\n  onMessageReceived?: (message: Message) => unknown\n  onMessageUpdated?: (message: Message) => unknown\n}\n\ntype MessageListenerKeys = keyof Omit<MessageListenOptions, 'topics'>\n\ntype MessageEvents = Record<MessagingEventNames, (message: Message) => void>\n\ninterface MessageSendMethodParams {\n  context?: string\n  from: string\n  to: string\n  body?: string\n  tags?: string[]\n  region?: string\n  media?: string[]\n}\n\ninterface MessagingSendResult {\n  message: string\n  code: string\n  messageId: string\n}\n\ninterface MessagingSendError {\n  message: string\n  code: string\n  errors: Record<any, any>\n}\n\nexport class Messaging extends BaseNamespace<\n  MessageListenOptions,\n  MessageEvents\n> {\n  protected _eventMap: Record<MessageListenerKeys, MessagingEventNames> = {\n    onMessageReceived: 'message.received',\n    onMessageUpdated: 'message.updated',\n  }\n\n  constructor(options: SWClient) {\n    super(options)\n\n    this._client.runWorker('messagingWorker', {\n      worker: messagingWorker,\n      initialState: {\n        messaging: this,\n      },\n    })\n  }\n\n  async send(params: MessageSendMethodParams): Promise<any> {\n    const { from = '', to = '', ...rest } = params\n    const sendParams = {\n      ...rest,\n      from_number: from,\n      to_number: to,\n    }\n\n    try {\n      const response = await this._client.execute<unknown, MessagingSendResult>(\n        {\n          method: 'messaging.send',\n          params: sendParams,\n        }\n      )\n\n      return toExternalJSON(response)\n    } catch (error) {\n      this._client.logger.error('Error sending message', error)\n      throw error as MessagingSendError\n    }\n  }\n}\n\nexport * from './Message'\nexport type { MessagingMessageState } from '@signalwire/core'\n", "import { EventEmitter, ExecuteParams, uuid } from '@signalwire/core'\nimport { prefixEvent } from './utils/internals'\nimport { ListenSubscriber } from './ListenSubscriber'\nimport { SWClient } from './SWClient'\n\nexport interface ListenOptions {\n  topics?: string[]\n  channels?: string[]\n}\n\nexport type Listeners<T> = Omit<T, 'topics' | 'channels'>\n\nexport type ListenersKeys<T> = keyof T\n\nexport class BaseNamespace<\n  T extends ListenOptions,\n  EventTypes extends EventEmitter.ValidEventTypes\n> extends ListenSubscriber<Listeners<T>, EventTypes> {\n  constructor(options: SWClient) {\n    super({ swClient: options })\n  }\n\n  protected addTopics(topics: string[]) {\n    const executeParams: ExecuteParams = {\n      method: 'signalwire.receive',\n      params: {\n        contexts: topics,\n      },\n    }\n    return this._client.execute<unknown, void>(executeParams)\n  }\n\n  protected removeTopics(topics: string[]) {\n    const executeParams: ExecuteParams = {\n      method: 'signalwire.unreceive',\n      params: {\n        contexts: topics,\n      },\n    }\n    return this._client.execute<unknown, void>(executeParams)\n  }\n\n  public listen(listenOptions: T) {\n    return new Promise<() => Promise<void>>(async (resolve, reject) => {\n      try {\n        const { topics } = listenOptions\n        if (!Array.isArray(topics) || topics?.length < 1) {\n          throw new Error(\n            'Invalid options: topics should be an array with at least one topic!'\n          )\n        }\n        const unsub = await this.subscribe(listenOptions)\n        resolve(unsub)\n      } catch (error) {\n        reject(error)\n      }\n    })\n  }\n\n  protected async subscribe(listenOptions: T) {\n    const { topics, ...listeners } = listenOptions\n    const _uuid = uuid()\n\n    // Attach listeners\n    this._attachListenersWithTopics(topics!, listeners as Listeners<T>)\n    await this.addTopics(topics!)\n\n    const unsub = () => {\n      return new Promise<void>(async (resolve, reject) => {\n        try {\n          // Detach listeners\n          this._detachListenersWithTopics(topics!, listeners as Listeners<T>)\n\n          // Remove topics from the listener map\n          this.removeFromListenerMap(_uuid)\n\n          // Remove the topics\n          const topicsToRemove = topics!.filter(\n            (topic) => !this.hasOtherListeners(_uuid, topic)\n          )\n          if (topicsToRemove.length > 0) {\n            await this.removeTopics(topicsToRemove)\n          }\n\n          resolve()\n        } catch (error) {\n          reject(error)\n        }\n      })\n    }\n\n    // Add topics to the listener map\n    this.addToListenerMap(_uuid, {\n      topics: new Set([...topics!]),\n      listeners: listeners as Listeners<T>,\n      unsub,\n    })\n\n    return unsub\n  }\n\n  protected _attachListenersWithTopics(\n    topics: string[],\n    listeners: Listeners<T>\n  ) {\n    const listenerKeys = Object.keys(listeners)\n    topics.forEach((topic) => {\n      listenerKeys.forEach((key) => {\n        const _key = key as keyof Listeners<T>\n        if (typeof listeners[_key] === 'function' && this._eventMap[_key]) {\n          const event = prefixEvent(topic, this._eventMap[_key] as string)\n          // @ts-expect-error\n          this.on(event, listeners[_key])\n        }\n      })\n    })\n  }\n\n  protected _detachListenersWithTopics(\n    topics: string[],\n    listeners: Listeners<T>\n  ) {\n    const listenerKeys = Object.keys(listeners)\n    topics.forEach((topic) => {\n      listenerKeys.forEach((key) => {\n        const _key = key as keyof Listeners<T>\n        if (typeof listeners[_key] === 'function' && this._eventMap[_key]) {\n          const event = prefixEvent(topic, this._eventMap[_key] as string)\n          // @ts-expect-error\n          this.off(event, listeners[_key])\n        }\n      })\n    })\n  }\n\n  protected hasOtherListeners(uuid: string, topic: string) {\n    for (const [key, listener] of this._listenerMap) {\n      if (key !== uuid && listener.topics?.has(topic)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  protected async unsubscribeAll() {\n    await Promise.all(\n      [...this._listenerMap.values()].map(({ unsub }) => unsub())\n    )\n    this._listenerMap.clear()\n  }\n}\n", "import { configureStore, getEventEmitter, UserOptions } from '@signalwire/core'\nimport { getConfig } from '../configure'\nimport { Session } from '../Session'\n\nexport const setupInternals = (userOptions: {\n  project: string\n  token: string\n  logLevel?: UserOptions['logLevel']\n}) => {\n  /**\n   * The emitter will be used across the entire stack so no\n   * need to type it here. Typings will be provided by each\n   * constructor.\n   */\n  const emitter = getEventEmitter<any>()\n\n  const baseOptions = {\n    ...userOptions,\n    emitter,\n  }\n\n  const store = configureStore({\n    userOptions: baseOptions,\n    SessionConstructor: Session,\n  })\n\n  return { store, emitter }\n}\n\nconst getToken = (userToken?: string) => {\n  const globalConfig = getConfig()\n  const token = userToken || globalConfig.token || process.env.SW_TOKEN\n\n  if (!token) {\n    // TODO: Add error message\n    throw new Error('Missing `token`')\n  }\n\n  return token\n}\n\nconst getProject = (userProject?: string) => {\n  const globalConfig = getConfig()\n  const project = userProject || globalConfig.project || process.env.SW_PROJECT\n\n  if (!project) {\n    // TODO: Add error message\n    throw new Error('Missing `project`')\n  }\n\n  return project\n}\n\ninterface GetCredentialsOptions {\n  token?: string\n  project?: string\n}\n\nexport const getCredentials = (options?: GetCredentialsOptions) => {\n  const project = getProject(options?.project)\n  const token = getToken(options?.token)\n\n  return { project, token }\n}\n\nexport const prefixEvent = (prefix: string, event: string) => {\n  if (typeof prefix !== 'string' || typeof event !== 'string') return event\n  return `${prefix}.${event}`\n}\n", "import { BaseSession, SWCloseEvent } from '@signalwire/core'\nimport WebSocket from 'ws'\n\nexport class Session extends BaseSession {\n  public WebSocketConstructor = WebSocket\n  public CloseEventConstructor = SWCloseEvent\n  public agent = process.env.SDK_PKG_AGENT!\n}\n", "import { EventEmitter, getLogger, uuid } from '@signalwire/core'\nimport type { Client } from './client/Client'\nimport { SWClient } from './SWClient'\n\nexport type ListenersKeys<T> = keyof T\n\nexport type ListenerMapValue<T> = {\n  topics?: Set<string>\n  listeners: T\n  unsub: () => Promise<void>\n}\n\nexport type ListenerMap<T> = Map<string, ListenerMapValue<T>>\n\nexport class ListenSubscriber<\n  T extends {},\n  EventTypes extends EventEmitter.ValidEventTypes\n> {\n  /** @internal */\n  _sw: SWClient\n\n  protected _client: Client\n  protected _listenerMap: ListenerMap<T> = new Map()\n  protected _eventMap: Record<keyof T, keyof EventTypes>\n  private _emitter = new EventEmitter<EventTypes>()\n\n  constructor(options: { swClient: SWClient }) {\n    this._sw = options.swClient\n    this._client = options.swClient.client\n  }\n\n  protected get emitter() {\n    return this._emitter\n  }\n\n  protected eventNames() {\n    return this.emitter.eventNames()\n  }\n\n  /** @internal */\n  emit<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T,\n    ...args: EventEmitter.EventArgs<EventTypes, T>\n  ) {\n    return this.emitter.emit(event, ...args)\n  }\n\n  protected on<E extends EventEmitter.EventNames<EventTypes>>(\n    event: E,\n    fn: EventEmitter.EventListener<EventTypes, E>\n  ) {\n    return this.emitter.on(event, fn)\n  }\n\n  protected once<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T,\n    fn: EventEmitter.EventListener<EventTypes, T>\n  ) {\n    return this.emitter.once(event, fn)\n  }\n\n  protected off<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T,\n    fn?: EventEmitter.EventListener<EventTypes, T>\n  ) {\n    return this.emitter.off(event, fn)\n  }\n\n  public listen(listeners: T) {\n    return new Promise<() => Promise<void>>(async (resolve, reject) => {\n      try {\n        if (\n          !listeners ||\n          listeners?.constructor !== Object ||\n          Object.keys(listeners).length < 1\n        ) {\n          throw new Error('Invalid params!')\n        }\n\n        const unsub = await this.subscribe(listeners)\n        resolve(unsub)\n      } catch (error) {\n        reject(error)\n      }\n    })\n  }\n\n  protected async subscribe(listeners: T) {\n    const _uuid = uuid()\n\n    // Attach listeners\n    this._attachListeners(listeners)\n\n    const unsub = () => {\n      return new Promise<void>(async (resolve, reject) => {\n        try {\n          // Detach listeners\n          this._detachListeners(listeners)\n\n          // Remove listeners from the listener map\n          this.removeFromListenerMap(_uuid)\n\n          resolve()\n        } catch (error) {\n          reject(error)\n        }\n      })\n    }\n\n    // Add listeners to the listener map\n    this.addToListenerMap(_uuid, {\n      listeners,\n      unsub,\n    })\n\n    return unsub\n  }\n\n  protected _attachListeners(listeners: T) {\n    const listenerKeys = Object.keys(listeners) as Array<ListenersKeys<T>>\n    listenerKeys.forEach((key) => {\n      if (typeof listeners[key] === 'function' && this._eventMap[key]) {\n        // @ts-expect-error\n        this.on(this._eventMap[key], listeners[key])\n      } else {\n        getLogger().warn(`Unsupported listener: ${listeners[key]}`)\n      }\n    })\n  }\n\n  protected _detachListeners(listeners: T) {\n    const listenerKeys = Object.keys(listeners) as Array<ListenersKeys<T>>\n    listenerKeys.forEach((key) => {\n      if (typeof listeners[key] === 'function' && this._eventMap[key]) {\n        // @ts-expect-error\n        this.off(this._eventMap[key], listeners[key])\n      }\n    })\n  }\n\n  protected addToListenerMap(id: string, value: ListenerMapValue<T>) {\n    return this._listenerMap.set(id, value)\n  }\n\n  protected removeFromListenerMap(id: string) {\n    return this._listenerMap.delete(id)\n  }\n}\n", "import {\n  MessagingAction,\n  SDKActions,\n  SDKWorker,\n  SagaIterator,\n  getLogger,\n  sagaEffects,\n} from '@signalwire/core'\nimport type { Client } from '../../client/Client'\nimport { prefixEvent } from '../../utils/internals'\nimport { Message } from '../Messaging'\nimport { Messaging } from '../Messaging'\n\ninterface MessagingWorkerInitialState {\n  messaging: Messaging\n}\n\nexport const messagingWorker: SDKWorker<Client> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('messagingWorker started')\n  const {\n    channels: { swEventChannel },\n    initialState,\n  } = options\n\n  const { messaging } = initialState as MessagingWorkerInitialState\n\n  function* worker(action: MessagingAction) {\n    const { payload, type } = action\n\n    // @ts-expect-error\n    const message = new Message(payload)\n\n    switch (type) {\n      case 'messaging.receive':\n        messaging.emit(\n          // @ts-expect-error\n          prefixEvent(payload.context, 'message.received'),\n          message\n        )\n        break\n      case 'messaging.state':\n        // @ts-expect-error\n        messaging.emit(prefixEvent(payload.context, 'message.updated'), message)\n        break\n      default:\n        getLogger().warn(`Unknown message event: \"${action.type}\"`)\n        break\n    }\n  }\n\n  const isMessagingEvent = (action: SDKActions) =>\n    action.type.startsWith('messaging.')\n\n  while (true) {\n    const action: MessagingAction = yield sagaEffects.take(\n      swEventChannel,\n      isMessagingEvent\n    )\n\n    yield sagaEffects.fork(worker, action)\n  }\n\n  getLogger().trace('messagingWorker ended')\n}\n", "import { MessagingMessageState } from '@signalwire/core'\n\n/**\n * An object representing an SMS or MMS message.\n */\nexport interface MessageContract {\n  /** The unique identifier of the message. */\n  id: string\n  /** The current state of the message. */\n  state: MessagingMessageState\n  /** The context of the message. */\n  context: string\n  /** The phone number the message comes from. */\n  from: string\n  /** The destination number of the message. */\n  to: string\n  /** The direction of the message: `inbound` or `outbound`. */\n  direction: string\n  /** Array of strings with message tags. */\n  tags: string[]\n  /** Body of the message */\n  body: string\n  /** Array of URLs media. */\n  media: string[]\n  /** Number of segments of the message. */\n  segments: number\n  /** Reason why the message was not sent. This is present only in case of failure. */\n  reason?: string\n}\n\ninterface MessageOptions {\n  message_id: string\n  message_state: MessagingMessageState\n  context: string\n  from_number: string\n  to_number: string\n  direction: 'inbound' | 'outbound'\n  tags: string[]\n  body: string\n  media: string[]\n  segments: number\n  reason?: string\n}\n\n/** @internal */\nexport class Message implements MessageContract {\n  public id: string\n  public state: MessagingMessageState\n  public context: string\n  public from: string\n  public to: string\n  public body: string\n  public direction: 'inbound' | 'outbound'\n  public media: string[]\n  public segments: number\n  public tags: string[]\n  public reason?: string\n\n  constructor(options: MessageOptions) {\n    this.id = options.message_id\n    this.state = options.message_state\n    this.context = options.context\n    this.from = options.from_number\n    this.to = options.to_number\n    this.body = options.body\n    this.direction = options.direction\n    this.media = options.media || []\n    this.segments = options.segments\n    this.tags = options.tags || []\n    this.reason = options.reason\n  }\n}\n", "import {\n  ChatMember,\n  ChatMessage,\n  ChatEvents,\n  Chat as ChatCore,\n} from '@signalwire/core'\nimport { BaseChat } from './BaseChat'\nimport { chatWorker } from './workers'\nimport { SWClient } from '../SWClient'\nimport { RealTimeChatEvents } from '../types/chat'\n\ninterface ChatListenOptions {\n  channels: string[]\n  onMessageReceived?: (message: ChatMessage) => unknown\n  onMemberJoined?: (member: ChatMember) => unknown\n  onMemberUpdated?: (member: ChatMember) => unknown\n  onMemberLeft?: (member: ChatMember) => unknown\n}\n\ntype ChatListenersKeys = keyof Omit<ChatListenOptions, 'channels' | 'topics'>\n\nexport class Chat extends ChatCore.applyCommonMethods(\n  BaseChat<ChatListenOptions, RealTimeChatEvents>\n) {\n  protected _eventMap: Record<ChatListenersKeys, ChatEvents> = {\n    onMessageReceived: 'chat.message',\n    onMemberJoined: 'chat.member.joined',\n    onMemberUpdated: 'chat.member.updated',\n    onMemberLeft: 'chat.member.left',\n  }\n\n  constructor(options: SWClient) {\n    super(options)\n\n    this._client.runWorker('chatWorker', {\n      worker: chatWorker,\n      initialState: {\n        chat: this,\n      },\n    })\n  }\n}\n\nexport { ChatMember, ChatMessage } from '@signalwire/core'\nexport type {\n  ChatAction,\n  ChatChannel,\n  ChatChannelMessageEvent,\n  ChatChannelMessageEventParams,\n  ChatChannelState,\n  ChatEvent,\n  ChatGetMembersParams,\n  ChatGetMemberStateParams,\n  ChatGetMessagesParams,\n  ChatMemberContract,\n  ChatMemberEntity,\n  ChatMemberJoinedEvent,\n  ChatMemberJoinedEventParams,\n  ChatMemberLeftEvent,\n  ChatMemberLeftEventParams,\n  ChatMemberUpdatedEvent,\n  ChatMemberUpdatedEventParams,\n  ChatMessageContract,\n  ChatMessageEntity,\n  ChatSetMemberStateParams,\n  InternalChatMemberEntity,\n  InternalChatMessageEntity,\n  InternalPubSubMessageEntity,\n  MapToPubSubShape,\n  MessagingAction,\n  PaginationCursor,\n  PubSubAction,\n  PubSubChannel,\n  PubSubChannelMessageEvent,\n  PubSubChannelMessageEventParams,\n  PubSubEvent,\n  PubSubEventAction,\n  PubSubPublishParams,\n} from '@signalwire/core'\n", "import {\n  EventEmitter,\n  ExecuteParams,\n  PubSubPublishParams,\n  uuid,\n} from '@signalwire/core'\nimport { BaseNamespace, Listeners } from '../BaseNamespace'\n\nexport interface BaseChatListenOptions {\n  channels: string[]\n}\n\nexport class BaseChat<\n  T extends BaseChatListenOptions,\n  EventTypes extends EventEmitter.ValidEventTypes\n> extends BaseNamespace<T, EventTypes> {\n  public listen(listenOptions: T) {\n    return new Promise<() => Promise<void>>(async (resolve, reject) => {\n      try {\n        const { channels } = listenOptions\n        if (!Array.isArray(channels) || channels?.length < 1) {\n          throw new Error(\n            'Invalid options: channels should be an array with at least one channel!'\n          )\n        }\n        const unsub = await this.subscribe(listenOptions)\n        resolve(unsub)\n      } catch (error) {\n        reject(error)\n      }\n    })\n  }\n\n  protected async subscribe(listenOptions: T) {\n    const { channels, ...listeners } = listenOptions\n\n    const _uuid = uuid()\n\n    // Attach listeners\n    this._attachListenersWithTopics(channels, listeners as Listeners<T>)\n\n    const listenerKeys = Object.keys(listeners)\n    const events: string[] = []\n    listenerKeys.forEach((key) => {\n      const _key = key as keyof Listeners<T>\n      if (this._eventMap[_key]) events.push(this._eventMap[_key] as string)\n    })\n    await this.addChannels(channels, events)\n\n    const unsub = () => {\n      return new Promise<void>(async (resolve, reject) => {\n        try {\n          // Remove the channels\n          const channelsToRemove = channels.filter(\n            (channel) => !this.hasOtherListeners(_uuid, channel)\n          )\n          if (channelsToRemove.length > 0) {\n            await this.removeChannels(channelsToRemove)\n          }\n\n          // Detach listeners\n          this._detachListenersWithTopics(channels, listeners as Listeners<T>)\n\n          // Remove channels from the listener map\n          this.removeFromListenerMap(_uuid)\n\n          resolve()\n        } catch (error) {\n          reject(error)\n        }\n      })\n    }\n\n    // Add channels to the listener map\n    this.addToListenerMap(_uuid, {\n      topics: new Set([...channels]),\n      listeners: listeners as Listeners<T>,\n      unsub,\n    })\n\n    return unsub\n  }\n\n  private addChannels(channels: string[], events: string[]) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const execParams: ExecuteParams = {\n          method: 'chat.subscribe',\n          params: {\n            channels: channels.map((channel) => ({\n              name: channel,\n            })),\n            events,\n          },\n        }\n\n        // @TODO: Do not subscribe if the user params are the same\n\n        await this._client.execute(execParams)\n        resolve(undefined)\n      } catch (error) {\n        reject(error)\n      }\n    })\n  }\n\n  private removeChannels(channels: string[]) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const execParams: ExecuteParams = {\n          method: 'chat.unsubscribe',\n          params: {\n            channels: channels.map((channel) => ({\n              name: channel,\n            })),\n          },\n        }\n\n        await this._client.execute(execParams)\n        resolve(undefined)\n      } catch (error) {\n        reject(error)\n      }\n    })\n  }\n\n  public publish(params: PubSubPublishParams) {\n    return new Promise((resolve, reject) => {\n      try {\n        const publish = this._client.execute({\n          method: 'chat.publish',\n          params,\n        })\n        resolve(publish)\n      } catch (error) {\n        reject(error)\n      }\n    })\n  }\n}\n", "import { SagaIterator } from '@redux-saga/core'\nimport {\n  sagaEffects,\n  SDKWorker,\n  getLogger,\n  ChatAction,\n  toExternalJSON,\n  ChatMessage,\n  ChatMember,\n  SDKActions,\n} from '@signalwire/core'\nimport { prefixEvent } from '../../utils/internals'\nimport type { Client } from '../../client/Client'\nimport { Chat } from '../Chat'\n\ninterface ChatWorkerInitialState {\n  chat: Chat\n}\n\nexport const chatWorker: SDKWorker<Client> = function* (options): SagaIterator {\n  getLogger().trace('chatWorker started')\n  const {\n    channels: { swEventChannel },\n    initialState,\n  } = options\n\n  const { chat } = initialState as ChatWorkerInitialState\n\n  function* worker(action: ChatAction) {\n    const { type, payload } = action\n\n    switch (type) {\n      case 'chat.channel.message': {\n        const { channel, message } = payload\n        const externalJSON = toExternalJSON({\n          ...message,\n          channel,\n        })\n        const chatMessage = new ChatMessage(externalJSON)\n\n        // @ts-expect-error\n        chat.emit(prefixEvent(channel, 'chat.message'), chatMessage)\n        break\n      }\n      case 'chat.member.joined':\n      case 'chat.member.updated':\n      case 'chat.member.left': {\n        const { member, channel } = payload\n        const externalJSON = toExternalJSON(member)\n        const chatMember = new ChatMember(externalJSON)\n\n        // @ts-expect-error\n        chat.emit(prefixEvent(channel, type), chatMember)\n        break\n      }\n      default:\n        getLogger().warn(`Unknown chat event: \"${type}\"`, payload)\n        break\n    }\n  }\n\n  const isChatEvent = (action: SDKActions) => action.type.startsWith('chat.')\n\n  while (true) {\n    const action: ChatAction = yield sagaEffects.take(\n      swEventChannel,\n      isChatEvent\n    )\n\n    yield sagaEffects.fork(worker, action)\n  }\n\n  getLogger().trace('chatWorker ended')\n}\n", "import {\n  PubSubMessageEventName,\n  PubSubNamespace,\n  PubSubMessage,\n} from '@signalwire/core'\nimport { SWClient } from '../SWClient'\nimport { pubSubWorker } from './workers'\nimport { BaseChat } from '../chat/BaseChat'\nimport { RealTimePubSubEvents } from '../types/pubSub'\n\ninterface PubSubListenOptions {\n  channels: string[]\n  onMessageReceived?: (message: PubSubMessage) => unknown\n}\n\ntype PubSubListenersKeys = keyof Omit<\n  PubSubListenOptions,\n  'channels' | 'topics'\n>\n\nexport class PubSub extends BaseChat<\n  PubSubListenOptions,\n  RealTimePubSubEvents\n> {\n  protected _eventMap: Record<\n    PubSubListenersKeys,\n    `${PubSubNamespace}.${PubSubMessageEventName}`\n  > = {\n    onMessageReceived: 'chat.message',\n  }\n\n  constructor(options: SWClient) {\n    super(options)\n\n    this._client.runWorker('pubSubWorker', {\n      worker: pubSubWorker,\n      initialState: {\n        pubSub: this,\n      },\n    })\n  }\n}\n\nexport type { PubSubMessageContract } from '@signalwire/core'\n", "import { SagaIterator } from '@redux-saga/core'\nimport {\n  sagaEffects,\n  PubSubEventAction,\n  SDKWorker,\n  getLogger,\n  PubSubMessage,\n  toExternalJSON,\n} from '@signalwire/core'\nimport { prefixEvent } from '../../utils/internals'\nimport type { Client } from '../../client/Client'\nimport { PubSub } from '../PubSub'\n\ninterface PubSubWorkerInitialState {\n  pubSub: PubSub\n}\n\nexport const pubSubWorker: SDKWorker<Client> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('pubSubWorker started')\n  const {\n    channels: { swEventChannel },\n    initialState,\n  } = options\n\n  const { pubSub } = initialState as PubSubWorkerInitialState\n\n  function* worker(action: PubSubEventAction) {\n    const { type, payload } = action\n\n    switch (type) {\n      case 'chat.channel.message': {\n        const {\n          channel,\n          /**\n           * Since we're using the same event as `Chat`\n           * the payload comes with a `member` prop. To\n           * avoid confusion (since `PubSub` doesn't\n           * have members) we'll remove it from the\n           * payload sent to the end user.\n           */\n          // @ts-expect-error\n          message: { member, ...restMessage },\n        } = payload\n        const externalJSON = toExternalJSON({\n          ...restMessage,\n          channel,\n        })\n        const pubSubMessage = new PubSubMessage(externalJSON)\n\n        // @ts-expect-error\n        pubSub.emit(prefixEvent(channel, 'chat.message'), pubSubMessage)\n        break\n      }\n      default:\n        getLogger().warn(`Unknown pubsub event: \"${type}\"`, payload)\n        break\n    }\n  }\n\n  const isPubSubEvent = (action: any) => action.type.startsWith('chat.')\n\n  while (true) {\n    const action: PubSubEventAction = yield sagaEffects.take(\n      swEventChannel,\n      isPubSubEvent\n    )\n\n    yield sagaEffects.fork(worker, action)\n  }\n\n  getLogger().trace('pubSubWorker ended')\n}\n", "import { request } from 'node:https'\nimport {\n  TaskInboundEvent,\n  TaskReceivedEventName,\n  getLogger,\n} from '@signalwire/core'\nimport { SWClient } from '../SWClient'\nimport { taskWorker } from './workers'\nimport { BaseNamespace } from '../BaseNamespace'\n\nexport const PATH = '/api/relay/rest/tasks'\nconst HOST = 'relay.signalwire.com'\n\ninterface TaskListenOptions {\n  topics: string[]\n  onTaskReceived?: (payload: TaskInboundEvent['message']) => unknown\n}\n\ntype TaskListenersKeys = keyof Omit<TaskListenOptions, 'topics'>\n\ntype TaskEvents = Record<\n  TaskReceivedEventName,\n  (task: TaskInboundEvent['message']) => void\n>\n\nexport class Task extends BaseNamespace<TaskListenOptions, TaskEvents> {\n  protected _eventMap: Record<TaskListenersKeys, TaskReceivedEventName> = {\n    onTaskReceived: 'task.received',\n  }\n\n  constructor(options: SWClient) {\n    super(options)\n\n    this._client.runWorker('taskWorker', {\n      worker: taskWorker,\n      initialState: {\n        task: this,\n      },\n    })\n  }\n\n  send({\n    topic,\n    message,\n  }: {\n    topic: string\n    message: Record<string, unknown>\n  }) {\n    const { userOptions } = this._sw\n    if (!userOptions.project || !userOptions.token) {\n      throw new Error('Invalid options: project and token are required!')\n    }\n    return new Promise<void>((resolve, reject) => {\n      try {\n        const Authorization = `Basic ${Buffer.from(\n          `${userOptions.project}:${userOptions.token}`\n        ).toString('base64')}`\n\n        const data = JSON.stringify({ context: topic, message })\n        const options = {\n          host: userOptions.host ?? HOST,\n          port: 443,\n          method: 'POST',\n          path: PATH,\n          headers: {\n            Authorization,\n            'Content-Type': 'application/json',\n            'Content-Length': data.length,\n          },\n        }\n\n        getLogger().debug('Task send -', data)\n        const req = request(options, ({ statusCode }) => {\n          statusCode === 204 ? resolve() : reject()\n        })\n\n        req.on('error', reject)\n\n        req.write(data)\n        req.end()\n      } catch (error) {\n        reject(error)\n      }\n    })\n  }\n}\n\nexport type { TaskReceivedEventName } from '@signalwire/core'\nexport type {\n  TaskClientApiEvents,\n  RealTimeTaskApiEventsHandlerMapping,\n} from '../types'\n", "import {\n  getLogger,\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  SDKActions,\n  TaskAction,\n} from '@signalwire/core'\nimport { prefixEvent } from '../../utils/internals'\nimport type { Client } from '../../client/Client'\nimport { Task } from '../Task'\n\ninterface TaskWorkerInitialState {\n  task: Task\n}\n\nexport const taskWorker: SDKWorker<Client> = function* (options): SagaIterator {\n  getLogger().trace('taskWorker started')\n  const {\n    channels: { swEventChannel },\n    initialState,\n  } = options\n\n  const { task } = initialState as TaskWorkerInitialState\n\n  function* worker(action: TaskAction) {\n    const { context } = action.payload\n\n    // @ts-expect-error\n    task.emit(prefixEvent(context, 'task.received'), action.payload.message)\n  }\n\n  const isTaskEvent = (action: SDKActions) =>\n    action.type === 'queuing.relay.tasks'\n\n  while (true) {\n    const action = yield sagaEffects.take(swEventChannel, isTaskEvent)\n\n    yield sagaEffects.fork(worker, action)\n  }\n\n  getLogger().trace('taskWorker ended')\n}\n", "import { toExternalJSON, uuid } from '@signalwire/core'\nimport type {\n  ToExternalJSONResult,\n  CallingCallDialFailedEventParams,\n} from '@signalwire/core'\nimport { Call } from './Call'\nimport { voiceCallReceiveWorker, voiceCallDialWorker } from './workers'\nimport { DeviceBuilder } from './DeviceBuilder'\nimport type {\n  VoiceDialMethodParams,\n  VoiceDialPhonelMethodParams,\n  VoiceDialSipMethodParams,\n  VoiceEvents,\n  VoiceListeners,\n  VoiceListenersEventsMapping,\n} from '../types'\nimport { toInternalDevices } from './utils'\nimport { BaseNamespace } from '../BaseNamespace'\nimport { SWClient } from '../SWClient'\n\ninterface VoiceListenOptions extends VoiceListeners {\n  topics: string[]\n}\n\nexport class Voice extends BaseNamespace<VoiceListenOptions, VoiceEvents> {\n  protected _eventMap: VoiceListenersEventsMapping = {\n    onCallReceived: 'call.received',\n  }\n\n  constructor(options: SWClient) {\n    super(options)\n\n    this._client.runWorker('voiceCallReceiveWorker', {\n      worker: voiceCallReceiveWorker,\n      initialState: {\n        voice: this,\n      },\n    })\n  }\n\n  dial(params: VoiceDialMethodParams) {\n    return new Promise<Call>((resolve, reject) => {\n      const _tag = uuid()\n\n      this._client.runWorker('voiceCallDialWorker', {\n        worker: voiceCallDialWorker,\n        initialState: {\n          voice: this,\n          tag: _tag,\n          listeners: params.listen,\n        },\n      })\n\n      const resolveHandler = (call: Call) => {\n        // @ts-expect-error\n        this.off('dial.failed', rejectHandler)\n        resolve(call)\n      }\n\n      const rejectHandler = (\n        error: ToExternalJSONResult<CallingCallDialFailedEventParams>\n      ) => {\n        // @ts-expect-error\n        this.off('dial.answered', resolveHandler)\n        reject(toExternalJSON(error))\n      }\n\n      // @ts-expect-error\n      this.once('dial.answered', resolveHandler)\n      // @ts-expect-error\n      this.once('dial.failed', rejectHandler)\n\n      let executeParams: Record<string, any>\n      if (params instanceof DeviceBuilder) {\n        const { devices } = params\n        executeParams = {\n          tag: _tag,\n          devices: toInternalDevices(devices),\n        }\n      } else if ('region' in params) {\n        const { region, nodeId, devices: deviceBuilder } = params\n        executeParams = {\n          tag: _tag,\n          region,\n          node_id: nodeId,\n          devices: toInternalDevices(deviceBuilder.devices),\n        }\n      } else {\n        throw new Error('[dial] Invalid input')\n      }\n\n      this._client\n        .execute({\n          method: 'calling.dial',\n          params: executeParams,\n        })\n        .catch((e) => {\n          reject(e)\n        })\n    })\n  }\n\n  dialPhone({\n    region,\n    maxPricePerMinute,\n    nodeId,\n    listen,\n    ...params\n  }: VoiceDialPhonelMethodParams) {\n    const devices = new DeviceBuilder().add(DeviceBuilder.Phone(params))\n    return this.dial({\n      maxPricePerMinute,\n      region,\n      nodeId,\n      devices,\n      listen,\n    })\n  }\n\n  dialSip({\n    region,\n    maxPricePerMinute,\n    nodeId,\n    listen,\n    ...params\n  }: VoiceDialSipMethodParams) {\n    const devices = new DeviceBuilder().add(DeviceBuilder.Sip(params))\n    return this.dial({\n      maxPricePerMinute,\n      region,\n      nodeId,\n      devices,\n      listen,\n    })\n  }\n}\n\nexport { Call } from './Call'\nexport { DeviceBuilder }\nexport { Playlist } from './Playlist'\nexport type { CallPlayback } from './CallPlayback'\nexport type { CallPrompt } from './CallPrompt'\nexport type { CallRecording } from './CallRecording'\nexport type { CallTap } from './CallTap'\nexport type {\n  CallingCallDirection,\n  CallingCallState,\n  CallingCallWaitForState,\n  ClientEvents,\n  CollectDigitsConfig,\n  CollectSpeechConfig,\n  CreateVoicePlaylistParams,\n  NestedArray,\n  RingtoneName,\n  SipCodec,\n  SipHeader,\n  SpeechOrDigits,\n  TapDevice,\n  TapDeviceRTP,\n  TapDeviceWS,\n  TapDirection,\n  VoiceCallConnectMethodParams,\n  VoiceCallConnectPhoneMethodParams,\n  VoiceCallConnectSipMethodParams,\n  VoiceCallContract,\n  VoiceCallDetectContract,\n  VoiceCallDetectDigitParams,\n  VoiceCallDetectFaxParams,\n  VoiceCallDetectMachineParams,\n  VoiceCallDetectMethodParams,\n  VoiceCallCollectContract,\n  VoiceCallCollectMethodParams,\n  VoiceCallDeviceParams,\n  VoiceCallDialPhoneMethodParams,\n  VoiceCallDialRegionParams,\n  VoiceCallDialSipMethodParams,\n  VoiceCallDisconnectReason,\n  VoiceCallPhoneParams,\n  VoiceCallPlayAudioMethodParams,\n  VoiceCallPlayAudioParams,\n  VoiceCallPlaybackContract,\n  VoiceCallPlayParams,\n  VoiceCallPlayRingtoneMethodParams,\n  VoiceCallPlayRingtoneParams,\n  VoiceCallPlaySilenceMethodParams,\n  VoiceCallPlaySilenceParams,\n  VoiceCallPlayTTSMethodParams,\n  VoiceCallPlayTTSParams,\n  VoiceCallPromptAudioMethodParams,\n  VoiceCallPromptContract,\n  VoiceCallPromptMethodParams,\n  VoiceCallPromptRingtoneMethodParams,\n  VoiceCallPromptTTSMethodParams,\n  VoiceCallRecordingContract,\n  VoiceCallRecordMethodParams,\n  VoiceCallSipParams,\n  VoiceCallTapAudioMethodParams,\n  VoiceCallTapContract,\n  VoiceCallTapMethodParams,\n  VoiceDeviceBuilder,\n  VoiceDialerParams,\n  VoicePlaylist,\n} from '@signalwire/core'\nexport type {\n  CallPlayMethodParams,\n  CallPlayAudioMethodarams,\n  CallPlaySilenceMethodParams,\n  CallPlayRingtoneMethodParams,\n  CallPlayTTSMethodParams,\n  CallRecordMethodParams,\n  CallRecordAudioMethodParams,\n  CallPromptMethodParams,\n  CallPromptAudioMethodParams,\n  CallPromptRingtoneMethodParams,\n  CallPromptTTSMethodParams,\n  CallCollectMethodParams,\n  CallTapMethodParams,\n  CallTapAudioMethodParams,\n  CallDetectMethodParams,\n  CallDetectMachineParams,\n  CallDetectFaxParams,\n  CallDetectDigitParams,\n} from '../types/voice'\n", "import {\n  getLogger,\n  sagaEffects,\n  SagaIterator,\n  SDKActions,\n  SDKWorker,\n  VoiceCallReceiveAction,\n  VoiceCallStateAction,\n} from '@signalwire/core'\nimport { prefixEvent } from '../../utils/internals'\nimport type { Client } from '../../client/index'\nimport { Call } from '../Call'\nimport { Voice } from '../Voice'\nimport { handleCallStateEvents } from './handlers'\n\ninterface VoiceCallReceiveWorkerInitialState {\n  voice: Voice\n}\n\nexport const voiceCallReceiveWorker: SDKWorker<Client> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('voiceCallReceiveWorker started')\n  const {\n    channels: { swEventChannel },\n    instanceMap,\n    initialState,\n  } = options\n\n  const { voice } = initialState as VoiceCallReceiveWorkerInitialState\n\n  function* callReceiveWorker(action: VoiceCallReceiveAction) {\n    const { get, set } = instanceMap\n    const { payload } = action\n\n    // Contexts is required\n    if (!payload.context || !payload.context.length) {\n      throw new Error('Invalid context to receive inbound call')\n    }\n\n    let callInstance = get<Call>(payload.call_id)\n    if (!callInstance) {\n      callInstance = new Call({\n        voice,\n        payload,\n      })\n    } else {\n      callInstance.setPayload(payload)\n    }\n\n    set<Call>(payload.call_id, callInstance)\n\n    // @ts-expect-error\n    voice.emit(prefixEvent(payload.context, 'call.received'), callInstance)\n  }\n\n  function* worker(action: VoiceCallReceiveAction | VoiceCallStateAction) {\n    if (action.type === 'calling.call.receive') {\n      yield sagaEffects.fork(callReceiveWorker, action)\n    } else {\n      handleCallStateEvents({\n        payload: action.payload,\n        voice,\n        instanceMap,\n      })\n    }\n  }\n\n  while (true) {\n    const action = yield sagaEffects.take(\n      swEventChannel,\n      (action: SDKActions) => {\n        return (\n          action.type === 'calling.call.receive' ||\n          (action.type === 'calling.call.state' &&\n            action.payload.direction === 'inbound')\n        )\n      }\n    )\n\n    yield sagaEffects.fork(worker, action)\n  }\n\n  getLogger().trace('voiceCallReceiveWorker ended')\n}\n", "import {\n  CallingCallConnectEventParams,\n  CallingCall,\n  uuid,\n  VoiceCallDisconnectReason,\n  toSnakeCaseKeys,\n  CallingCallWaitForState,\n  CallingCallState,\n  VoiceCallConnectMethodParams,\n  toExternalJSON,\n  VoiceCallConnectPhoneMethodParams,\n  VoiceCallConnectSipMethodParams,\n  CallingCallConnectFailedEventParams,\n} from '@signalwire/core'\nimport { ListenSubscriber } from '../ListenSubscriber'\nimport {\n  CallCollectMethodParams,\n  CallDetectDigitParams,\n  CallDetectFaxParams,\n  CallDetectMachineParams,\n  CallDetectMethodParams,\n  CallPlayAudioMethodarams,\n  CallPlayMethodParams,\n  CallPlayRingtoneMethodParams,\n  CallPlaySilenceMethodParams,\n  CallPlayTTSMethodParams,\n  CallPromptAudioMethodParams,\n  CallPromptMethodParams,\n  CallPromptRingtoneMethodParams,\n  CallPromptTTSMethodParams,\n  CallRecordAudioMethodParams,\n  CallRecordMethodParams,\n  CallTapAudioMethodParams,\n  CallTapMethodParams,\n  RealTimeCallEvents,\n  RealTimeCallListeners,\n  RealtimeCallListenersEventsMapping,\n} from '../types'\nimport { toInternalDevices, toInternalPlayParams } from './utils'\nimport {\n  voiceCallCollectWorker,\n  voiceCallConnectWorker,\n  voiceCallDetectWorker,\n  voiceCallPlayWorker,\n  voiceCallRecordWorker,\n  voiceCallSendDigitsWorker,\n  voiceCallTapWorker,\n} from './workers'\nimport { Playlist } from './Playlist'\nimport { Voice } from './Voice'\nimport { CallPlayback, decoratePlaybackPromise } from './CallPlayback'\nimport { CallRecording, decorateRecordingPromise } from './CallRecording'\nimport { CallPrompt, decoratePromptPromise } from './CallPrompt'\nimport { CallCollect, decorateCollectPromise } from './CallCollect'\nimport { CallTap, decorateTapPromise } from './CallTap'\nimport { DeviceBuilder } from './DeviceBuilder'\nimport { CallDetect, decorateDetectPromise } from './CallDetect'\n\ninterface CallOptions {\n  voice: Voice\n  payload?: CallingCall\n  connectPayload?: CallingCallConnectEventParams\n  listeners?: RealTimeCallListeners\n}\n\nexport class Call extends ListenSubscriber<\n  RealTimeCallListeners,\n  RealTimeCallEvents\n> {\n  private _voice: Voice\n  private _context: string | undefined\n  private _peer: Call | undefined\n  private _payload: CallingCall | undefined\n  private _connectPayload: CallingCallConnectEventParams | undefined\n  protected _eventMap: RealtimeCallListenersEventsMapping = {\n    onStateChanged: 'call.state',\n    onPlaybackStarted: 'playback.started',\n    onPlaybackUpdated: 'playback.updated',\n    onPlaybackFailed: 'playback.failed',\n    onPlaybackEnded: 'playback.ended',\n    onRecordingStarted: 'recording.started',\n    onRecordingUpdated: 'recording.updated',\n    onRecordingFailed: 'recording.failed',\n    onRecordingEnded: 'recording.ended',\n    onPromptStarted: 'prompt.started',\n    onPromptUpdated: 'prompt.updated',\n    onPromptFailed: 'prompt.failed',\n    onPromptEnded: 'prompt.ended',\n    onCollectStarted: 'collect.started',\n    onCollectInputStarted: 'collect.startOfInput',\n    onCollectUpdated: 'collect.updated',\n    onCollectFailed: 'collect.failed',\n    onCollectEnded: 'collect.ended',\n    onTapStarted: 'tap.started',\n    onTapEnded: 'tap.ended',\n    onDetectStarted: 'detect.started',\n    onDetectUpdated: 'detect.updated',\n    onDetectEnded: 'detect.ended',\n  }\n\n  constructor(options: CallOptions) {\n    super({ swClient: options.voice._sw })\n\n    this._voice = options.voice\n    this._payload = options.payload\n    this._context = options.payload?.context\n    this._connectPayload = options.connectPayload\n\n    if (options.listeners) {\n      this.listen(options.listeners)\n    }\n  }\n\n  /** Unique id for this voice call */\n  get id() {\n    return this._payload?.call_id\n  }\n\n  get callId() {\n    return this._payload?.call_id\n  }\n\n  get state() {\n    return this._payload?.call_state\n  }\n\n  get callState() {\n    return this._payload?.call_state\n  }\n\n  get tag() {\n    return this._payload?.tag\n  }\n\n  get nodeId() {\n    return this._payload?.node_id\n  }\n\n  get device() {\n    return this._payload?.device\n  }\n\n  /** The type of call. Only phone and sip are currently supported. */\n  get type() {\n    return this.device?.type ?? ''\n  }\n\n  /** The phone number that the call is coming from. */\n  get from() {\n    if (this.type === 'phone') {\n      return (\n        // @ts-expect-error\n        (this.device?.params?.from_number || this.device?.params?.fromNumber) ??\n        ''\n      )\n    }\n    return (\n      // @ts-expect-error\n      this.device?.params?.from ?? ''\n    )\n  }\n\n  /** The phone number you are attempting to call. */\n  get to() {\n    if (this.type === 'phone') {\n      return (\n        // @ts-expect-error\n        (this.device?.params?.to_number || this.device?.params?.toNumber) ?? ''\n      )\n    }\n    // @ts-expect-error\n    return this.device?.params?.to ?? ''\n  }\n\n  get headers() {\n    // @ts-expect-error\n    return this.device?.params?.headers ?? []\n  }\n\n  get active() {\n    return this.state === 'answered'\n  }\n\n  get connected() {\n    return this.connectState === 'connected'\n  }\n\n  get direction() {\n    return this._payload?.direction\n  }\n\n  get context() {\n    return this._context\n  }\n\n  get connectState() {\n    return this._connectPayload?.connect_state\n  }\n\n  get peer() {\n    return this._peer\n  }\n\n  /** @internal */\n  set peer(callInstance: Call | undefined) {\n    this._peer = callInstance\n  }\n\n  /** @internal */\n  setPayload(payload: CallingCall) {\n    this._payload = payload\n  }\n\n  /** @internal */\n  setConnectPayload(payload: CallingCallConnectEventParams) {\n    this._connectPayload = payload\n  }\n\n  /**\n   * Hangs up the call.\n   * @param reason Optional reason for hanging up\n   *\n   * @example\n   *\n   * ```js\n   * call.hangup();\n   * ```\n   */\n  hangup(reason: VoiceCallDisconnectReason = 'hangup') {\n    return new Promise<void>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(\n          new Error(\n            `Can't call hangup() on a call that hasn't been established.`\n          )\n        )\n      }\n\n      this.on('call.state', (params) => {\n        if (params.callState === 'ended') {\n          resolve()\n        }\n      })\n\n      this._client\n        .execute({\n          method: 'calling.end',\n          params: {\n            node_id: this.nodeId,\n            call_id: this.callId,\n            reason: reason,\n          },\n        })\n        .catch((e) => {\n          reject(e)\n        })\n    })\n  }\n\n  /**\n   * Pass the incoming call to another consumer.\n   *\n   * @example\n   *\n   * ```js\n   * call.pass();\n   * ```\n   */\n  pass() {\n    return new Promise<void>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call pass() on a call without callId.`))\n      }\n\n      this._client\n        .execute({\n          method: 'calling.pass',\n          params: {\n            node_id: this.nodeId,\n            call_id: this.callId,\n          },\n        })\n        .then(() => {\n          resolve()\n        })\n        .catch((e) => {\n          reject(e)\n        })\n    })\n  }\n\n  /**\n   * Answers the incoming call.\n   *\n   * @example\n   *\n   * ```js\n   * voice.client.listen({\n   *  topics: ['home'],\n   *  onCallReceived: async (call) => {\n   *    try {\n   *      await call.answer()\n   *      console.log('Inbound call answered')\n   *    } catch (error) {\n   *      console.error('Error answering inbound call', error)\n   *    }\n   *  }\n   * })\n   * ```\n   */\n  answer() {\n    return new Promise<this>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call answer() on a call without callId.`))\n      }\n\n      this.on('call.state', (params) => {\n        if (params.state === 'answered') {\n          resolve(this)\n        } else if (params.state === 'ended') {\n          reject(new Error('Failed to answer the call.'))\n        }\n      })\n\n      this._client\n        .execute({\n          method: 'calling.answer',\n          params: {\n            node_id: this.nodeId,\n            call_id: this.callId,\n          },\n        })\n        .catch((e) => {\n          reject(e)\n        })\n    })\n  }\n\n  /**\n   * Play one or multiple media in a Call and waits until the playing has ended.\n   *\n   * The play method is a generic method for all types of media, see\n   * {@link playAudio}, {@link playSilence}, {@link playTTS} or\n   * {@link playRingtone} for more specific usages.\n   *\n   * @param params a media playlist. See {@link Voice.Playlist}.\n   *\n   * @example\n   *\n   * ```js\n   * await call.play(new Voice.Playlist({ volume: 1.0 }).add(\n   *   Voice.Playlist.TTS({\n   *     text: 'Welcome to SignalWire! Please enter your 4 digits PIN',\n   *   })\n   * ))\n   * ```\n   */\n  play(params: CallPlayMethodParams) {\n    const promise = new Promise<CallPlayback>((resolve, reject) => {\n      const { playlist, listen } = params\n\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call play() on a call not established yet.`))\n      }\n\n      const resolveHandler = (callPlayback: CallPlayback) => {\n        this.off('playback.failed', rejectHandler)\n        resolve(callPlayback)\n      }\n\n      const rejectHandler = (callPlayback: CallPlayback) => {\n        this.off('playback.started', resolveHandler)\n        reject(callPlayback)\n      }\n\n      this.once('playback.started', resolveHandler)\n      this.once('playback.failed', rejectHandler)\n\n      const controlId = uuid()\n\n      this._client.runWorker('voiceCallPlayWorker', {\n        worker: voiceCallPlayWorker,\n        initialState: {\n          controlId,\n          listeners: listen,\n        },\n      })\n\n      this._client\n        .execute({\n          method: 'calling.play',\n          params: {\n            node_id: this.nodeId,\n            call_id: this.callId,\n            control_id: controlId,\n            volume: playlist.volume,\n            play: toInternalPlayParams(playlist.media),\n          },\n        })\n        .then(() => {\n          // TODO: handle then?\n        })\n        .catch((e) => {\n          this.off('playback.started', resolveHandler)\n          this.off('playback.failed', rejectHandler)\n          reject(e)\n        })\n    })\n\n    return decoratePlaybackPromise.call(this, promise)\n  }\n\n  /**\n   * Plays an audio file.\n   *\n   * @example\n   *\n   * ```js\n   * const playback = await call.playAudio({ url: 'https://cdn.signalwire.com/default-music/welcome.mp3' });\n   * ```\n   */\n  playAudio(params: CallPlayAudioMethodarams) {\n    const { volume, listen, ...rest } = params\n    const playlist = new Playlist({ volume }).add(Playlist.Audio(rest))\n    return this.play({ playlist, listen })\n  }\n\n  /**\n   * Plays some silence.\n   *\n   * @example\n   *\n   * ```js\n   * const playback = await call.playSilence({ duration: 3 });\n   * ```\n   */\n  playSilence(params: CallPlaySilenceMethodParams) {\n    const { listen, ...rest } = params\n    const playlist = new Playlist().add(Playlist.Silence(rest))\n    return this.play({ playlist, listen })\n  }\n\n  /**\n   * Plays a ringtone.\n   *\n   * @example\n   *\n   * ```js\n   * const playback = await call.playRingtone({ name: 'it' });\n   * ```\n   */\n  playRingtone(params: CallPlayRingtoneMethodParams) {\n    const { volume, listen, ...rest } = params\n    const playlist = new Playlist({ volume }).add(Playlist.Ringtone(rest))\n    return this.play({ playlist, listen })\n  }\n\n  /**\n   * Plays text-to-speech.\n   *\n   * @example\n   *\n   * ```js\n   * const playback = await call.playTTS({ text: 'Welcome to SignalWire!' });\n   * ```\n   */\n  playTTS(params: CallPlayTTSMethodParams) {\n    const { volume, listen, ...rest } = params\n    const playlist = new Playlist({ volume }).add(Playlist.TTS(rest))\n    return this.play({ playlist, listen })\n  }\n\n  /**\n   * Generic method to record a call. Please see {@link recordAudio}.\n   */\n  record(params: CallRecordMethodParams) {\n    const promise = new Promise<CallRecording>((resolve, reject) => {\n      const { audio, listen } = params\n\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call record() on a call not established yet.`))\n      }\n\n      const resolveHandler = (callRecording: CallRecording) => {\n        resolve(callRecording)\n      }\n\n      const rejectHandler = (callRecording: CallRecording) => {\n        this.off('recording.started', resolveHandler)\n        reject(callRecording)\n      }\n\n      this.once('recording.started', resolveHandler)\n      this.once('recording.failed', rejectHandler)\n\n      const controlId = uuid()\n      const record = toSnakeCaseKeys({ audio })\n\n      this._client.runWorker('voiceCallRecordWorker', {\n        worker: voiceCallRecordWorker,\n        initialState: {\n          controlId,\n          listeners: listen,\n        },\n      })\n\n      this._client\n        .execute({\n          method: 'calling.record',\n          params: {\n            node_id: this.nodeId,\n            call_id: this.callId,\n            control_id: controlId,\n            record,\n          },\n        })\n        .then(() => {\n          // TODO: handle then?\n        })\n        .catch((e) => {\n          this.off('recording.started', resolveHandler)\n          this.off('recording.failed', rejectHandler)\n          reject(e)\n        })\n    })\n\n    return decorateRecordingPromise.call(this, promise)\n  }\n\n  /**\n   * Records the audio from the call.\n   *\n   * @example\n   *\n   * ```js\n   * const recording = await call.recordAudio({ direction: 'both' })\n   * ```\n   */\n  recordAudio(params: CallRecordAudioMethodParams = {}) {\n    const { listen, ...rest } = params\n    return this.record({\n      audio: rest,\n      listen,\n    })\n  }\n\n  /**\n   * Generic method to prompt the user for input. Please see {@link promptAudio}, {@link promptRingtone}, {@link promptTTS}.\n   */\n  prompt(params: CallPromptMethodParams) {\n    const promise = new Promise<CallPrompt>((resolve, reject) => {\n      const { listen, ...rest } = params\n\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call record() on a call not established yet.`))\n      }\n      if (!params.playlist) {\n        reject(new Error(`Missing 'playlist' params.`))\n      }\n\n      const controlId = `${uuid()}.prompt`\n\n      const { volume, media } = params.playlist\n      // TODO: move this to a method to build `collect`\n      const { initial_timeout, digits, speech } = toSnakeCaseKeys(rest)\n      const collect = {\n        initial_timeout,\n        digits,\n        speech,\n      }\n\n      this._client.runWorker('voiceCallPlayWorker', {\n        worker: voiceCallPlayWorker,\n        initialState: {\n          controlId,\n        },\n      })\n\n      this._client.runWorker('voiceCallCollectWorker', {\n        worker: voiceCallCollectWorker,\n        initialState: {\n          controlId,\n        },\n      })\n\n      this._client\n        .execute({\n          method: 'calling.play_and_collect',\n          params: {\n            node_id: this.nodeId,\n            call_id: this.callId,\n            control_id: controlId,\n            volume,\n            play: toInternalPlayParams(media),\n            collect,\n          },\n        })\n        .then(() => {\n          const promptInstance = new CallPrompt({\n            call: this,\n            listeners: listen,\n            // @ts-expect-error\n            payload: {\n              control_id: controlId,\n              call_id: this.id!,\n              node_id: this.nodeId!,\n            },\n          })\n          this._client.instanceMap.set<CallPrompt>(controlId, promptInstance)\n          this.emit('prompt.started', promptInstance)\n          promptInstance.emit('prompt.started', promptInstance)\n          resolve(promptInstance)\n        })\n        .catch((e) => {\n          this.emit('prompt.failed', e)\n          reject(e)\n        })\n    })\n\n    return decoratePromptPromise.call(this, promise)\n  }\n\n  /**\n   * Play an audio while collecting user input from the call, such as `digits` or `speech`.\n   *\n   * @example\n   *\n   * Prompting for digits and waiting for a result:\n   *\n   * ```js\n   * const prompt = await call.promptAudio({\n   *   url: 'https://cdn.signalwire.com/default-music/welcome.mp3',\n   *   digits: {\n   *     max: 5,\n   *     digitTimeout: 2,\n   *     terminators: '#*'\n   *   }\n   * })\n   * const { type, digits, terminator } = await prompt.ended()\n   * ```\n   */\n  promptAudio(params: CallPromptAudioMethodParams) {\n    const { url, volume, ...rest } = params\n    const playlist = new Playlist({ volume }).add(Playlist.Audio({ url }))\n\n    return this.prompt({\n      playlist,\n      ...rest,\n    })\n  }\n\n  /**\n   * Play a ringtone while collecting user input from the call, such as `digits` or `speech`.\n   *\n   * @example\n   *\n   * Prompting for digits and waiting for a result:\n   *\n   * ```js\n   * const prompt = await call.promptRingtone({\n   *   name: 'it',\n   *   duration: 10,\n   *   digits: {\n   *     max: 5,\n   *     digitTimeout: 2,\n   *     terminators: '#*'\n   *   }\n   * })\n   * const { type, digits, terminator } = await prompt.ended()\n   * ```\n   */\n  promptRingtone(params: CallPromptRingtoneMethodParams) {\n    const { name, duration, volume, ...rest } = params\n    const playlist = new Playlist({ volume }).add(\n      Playlist.Ringtone({ name, duration })\n    )\n\n    return this.prompt({\n      playlist,\n      ...rest,\n    })\n  }\n\n  /**\n   * Say some text while collecting user input from the call, such as `digits` or `speech`.\n   *\n   * @example\n   *\n   * Prompting for digits and waiting for a result:\n   *\n   * ```js\n   * const prompt = await call.promptTTS({\n   *   text: 'Please enter your PIN',\n   *   digits: {\n   *     max: 5,\n   *     digitTimeout: 2,\n   *     terminators: '#*'\n   *   }\n   * })\n   * const { type, digits, terminator } = await prompt.ended()\n   * ```\n   */\n  promptTTS(params: CallPromptTTSMethodParams) {\n    const { text, language, gender, volume, ...rest } = params\n    const playlist = new Playlist({ volume }).add(\n      Playlist.TTS({ text, language, gender })\n    )\n\n    return this.prompt({\n      playlist,\n      ...rest,\n    })\n  }\n\n  /**\n   * Play DTMF digits to the other party on the call.\n   *\n   * @example\n   *\n   * ```js\n   * await call.sendDigits('123')\n   * ```\n   */\n  sendDigits(digits: string) {\n    return new Promise<Call>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(\n          new Error(`Can't call sendDigits() on a call not established yet.`)\n        )\n      }\n\n      const callStateHandler = (params: any) => {\n        if (params.callState === 'ended' || params.callState === 'ending') {\n          reject(\n            new Error(\n              \"Call is ended or about to end, couldn't send digits in time.\"\n            )\n          )\n        }\n      }\n\n      this.once('call.state', callStateHandler)\n\n      const cleanup = () => {\n        this.off('call.state', callStateHandler)\n      }\n\n      const resolveHandler = (call: Call) => {\n        cleanup()\n        // @ts-expect-error\n        this.off('send_digits.failed', rejectHandler)\n        resolve(call)\n      }\n\n      const rejectHandler = (error: Error) => {\n        cleanup()\n        // @ts-expect-error\n        this.off('send_digits.finished', resolveHandler)\n        reject(error)\n      }\n\n      // @ts-expect-error\n      this.once('send_digits.finished', resolveHandler)\n      // @ts-expect-error\n      this.once('send_digits.failed', rejectHandler)\n\n      const controlId = uuid()\n\n      this._client.runWorker('voiceCallSendDigitsWorker', {\n        worker: voiceCallSendDigitsWorker,\n        initialState: {\n          controlId,\n        },\n      })\n\n      this._client\n        .execute({\n          method: 'calling.send_digits',\n          params: {\n            node_id: this.nodeId,\n            call_id: this.callId,\n            control_id: controlId,\n            digits,\n          },\n        })\n        .catch((e) => {\n          reject(e)\n        })\n    })\n  }\n\n  /**\n   * Intercept call media and stream it to the specified WebSocket endpoint.\n   * Prefer using {@link tapAudio} if you only need to tap audio.\n   *\n   * @example\n   *\n   * ```js\n   * const tap = await call.tapAudio({\n   *   audio: {\n   *     direction: 'both',\n   *   },\n   *   device: {\n   *     type: 'ws',\n   *     uri: 'wss://example.domain.com/endpoint',\n   *   },\n   * })\n   * ```\n   */\n  tap(params: CallTapMethodParams) {\n    const promise = new Promise<CallTap>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call tap() on a call not established yet.`))\n      }\n\n      const resolveHandler = (callTap: CallTap) => {\n        this.off('tap.ended', rejectHandler)\n        resolve(callTap)\n      }\n\n      const rejectHandler = (callTap: CallTap) => {\n        this.off('tap.started', resolveHandler)\n        reject(callTap)\n      }\n\n      this.once('tap.started', resolveHandler)\n      this.once('tap.ended', rejectHandler)\n\n      const controlId = uuid()\n\n      // TODO: Move to a method to build the objects and transform camelCase to snake_case\n      const {\n        audio = {},\n        device: { type, ...rest },\n        listen,\n      } = params\n\n      this._client.runWorker('voiceCallTapWorker', {\n        worker: voiceCallTapWorker,\n        initialState: {\n          controlId,\n          listeners: listen,\n        },\n      })\n\n      this._client\n        .execute({\n          method: 'calling.tap',\n          params: {\n            node_id: this.nodeId,\n            call_id: this.callId,\n            control_id: controlId,\n            tap: {\n              type: 'audio',\n              params: audio,\n            },\n            device: {\n              type,\n              params: rest,\n            },\n          },\n        })\n        .then(() => {\n          // TODO: handle then?\n        })\n        .catch((e) => {\n          this.off('tap.started', resolveHandler)\n          this.off('tap.ended', rejectHandler)\n          reject(e)\n        })\n    })\n\n    return decorateTapPromise.call(this, promise)\n  }\n\n  /**\n   * Intercept call audio and stream it to the specified WebSocket endpoint.\n   *\n   * @example\n   *\n   * ```js\n   * const tap = await call.tapAudio({\n   *   direction: 'both',\n   *   device: {\n   *     type: 'ws',\n   *     uri: 'wss://example.domain.com/endpoint',\n   *   },\n   * })\n   *\n   * await tap.stop()\n   * ```\n   */\n  tapAudio(params: CallTapAudioMethodParams) {\n    const { direction, ...rest } = params\n    return this.tap({ audio: { direction }, ...rest })\n  }\n\n  /**\n   * Attempt to connect an existing call to a new outbound call. You can wait\n   * until the call is disconnected by calling {@link waitForDisconnected}.\n   *\n   * This is a generic method that allows you to connect to multiple devices in\n   * series, parallel, or combinations of both with the use of a\n   * {@link Voice.DeviceBuilder}. For simpler use cases, prefer using\n   * {@link connectPhone} or {@link connectSip}.\n   *\n   * @example\n   *\n   * Connecting to a new SIP call.\n   *\n   * ```js\n   * const plan = new Voice.DeviceBuilder().add(\n   *   Voice.DeviceBuilder.Sip({\n   *     from: 'sip:user1@domain.com',\n   *     to: 'sip:user2@domain.com',\n   *     timeout: 30,\n   *   })\n   * )\n   *\n   * const peer = await call.connect(plan)\n   * ```\n   */\n  connect(params: VoiceCallConnectMethodParams) {\n    return new Promise<any>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call connect() on a call not established yet.`))\n      }\n\n      const _tag = uuid()\n\n      // We can ignore the \"ringback\" error since we just want to cleanup \"...rest\"\n      // @ts-expect-error\n      const { devices, ringback, ...rest } = params\n      const executeParams: Record<string, any> = {\n        tag: _tag,\n        ...toSnakeCaseKeys(rest),\n      }\n      if ('ringback' in params) {\n        executeParams.ringback = toInternalPlayParams(\n          params.ringback?.media ?? []\n        )\n      }\n\n      if (params instanceof DeviceBuilder) {\n        executeParams.devices = toInternalDevices(params.devices)\n      } else if (devices instanceof DeviceBuilder) {\n        executeParams.devices = toInternalDevices(devices.devices)\n      } else {\n        throw new Error('[connect] Invalid \"devices\" parameter.')\n      }\n\n      const resolveHandler = (payload: Call) => {\n        // @ts-expect-error\n        this.off('connect.failed', rejectHandler)\n        resolve(payload)\n      }\n\n      const rejectHandler = (payload: CallingCallConnectFailedEventParams) => {\n        // @ts-expect-error\n        this.off('connect.connected', resolveHandler)\n        reject(toExternalJSON(payload))\n      }\n\n      // @ts-expect-error\n      this.once('connect.connected', resolveHandler)\n      // @ts-expect-error\n      this.once('connect.failed', rejectHandler)\n\n      this._client.runWorker('voiceCallConnectWorker', {\n        worker: voiceCallConnectWorker,\n        initialState: {\n          voice: this._voice,\n          tag: _tag,\n        },\n      })\n\n      this._client\n        .execute({\n          method: 'calling.connect',\n          params: {\n            node_id: this.nodeId,\n            call_id: this.callId,\n            tag: _tag,\n            ...executeParams,\n          },\n        })\n        .catch((e) => {\n          // @ts-expect-error\n          this.off('connect.connected', resolveHandler)\n          // @ts-expect-error\n          this.off('connect.failed', rejectHandler)\n\n          reject(e)\n        })\n    })\n  }\n\n  /**\n   * Attempt to connect an existing call to a new outbound phone call. You can\n   * wait until the call is disconnected by calling {@link waitForDisconnected}.\n   *\n   * @example\n   *\n   * ```js\n   * const peer = await call.connectPhone({\n   *   from: '+xxxxxx',\n   *   to: '+yyyyyy',\n   *   timeout: 30\n   * })\n   * ```\n   */\n  connectPhone({\n    ringback,\n    maxPricePerMinute,\n    ...params\n  }: VoiceCallConnectPhoneMethodParams) {\n    const devices = new DeviceBuilder().add(DeviceBuilder.Phone(params))\n    return this.connect({ devices, maxPricePerMinute, ringback })\n  }\n\n  /**\n   * Attempt to connect an existing call to a new outbound SIP call. You can\n   * wait until the call is disconnected by calling {@link waitForDisconnected}.\n   *\n   * @example\n   *\n   * ```js\n   * const peer = await call.connectPhone({\n   *   from: 'sip:user1@domain.com',\n   *   to: 'sip:user2@domain.com',\n   *   timeout: 30\n   * })\n   * ```\n   */\n  connectSip({\n    ringback,\n    maxPricePerMinute,\n    ...params\n  }: VoiceCallConnectSipMethodParams) {\n    const devices = new DeviceBuilder().add(DeviceBuilder.Sip(params))\n    return this.connect({ devices, maxPricePerMinute, ringback })\n  }\n\n  disconnect() {\n    return new Promise<void>((resolve, reject) => {\n      if (!this.callId || !this.nodeId || !this.peer) {\n        reject(\n          new Error(`Can't call disconnect() on a call not connected yet.`)\n        )\n      }\n\n      const resolveHandler = () => {\n        resolve()\n      }\n      // @ts-expect-error\n      this.once('connect.disconnected', resolveHandler)\n\n      this._client\n        .execute({\n          method: 'calling.disconnect',\n          params: {\n            node_id: this.nodeId,\n            call_id: this.callId,\n          },\n        })\n        .catch((e) => {\n          // @ts-expect-error\n          this.off('connect.disconnected', resolveHandler)\n\n          reject(e)\n        })\n    })\n  }\n\n  /**\n   * @deprecated use {@link disconnected} instead.\n   */\n  waitForDisconnected() {\n    return this.disconnect\n  }\n\n  disconnected() {\n    return new Promise<this>((resolve) => {\n      const resolveHandler = () => {\n        resolve(this)\n      }\n      // @ts-expect-error\n      this.once('connect.disconnected', resolveHandler)\n      // @ts-expect-error\n      this.once('connect.failed', resolveHandler)\n\n      if (this.state === 'ended' || this.state === 'ending') {\n        return resolveHandler()\n      }\n    })\n  }\n\n  /**\n   * Generic method. Please see {@link amd}, {@link detectFax}, {@link detectDigit}.\n   */\n  detect(params: CallDetectMethodParams) {\n    const promise = new Promise<CallDetect>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call detect() on a call not established yet.`))\n      }\n\n      const controlId = uuid()\n\n      // TODO: build params in a method\n      const { listen, timeout, type, waitForBeep = false, ...rest } = params\n\n      this._client.runWorker('voiceCallDetectWorker', {\n        worker: voiceCallDetectWorker,\n        initialState: {\n          controlId,\n          listeners: listen,\n        },\n      })\n\n      this._client\n        .execute({\n          method: 'calling.detect',\n          params: {\n            node_id: this.nodeId,\n            call_id: this.callId,\n            control_id: controlId,\n            timeout,\n            detect: {\n              type,\n              params: toSnakeCaseKeys(rest),\n            },\n          },\n        })\n        .then(() => {\n          const detectInstance = new CallDetect({\n            call: this,\n            payload: {\n              control_id: controlId,\n              call_id: this.id!,\n              node_id: this.nodeId!,\n              waitForBeep: params.waitForBeep ?? false,\n            },\n            listeners: listen,\n          })\n          this._client.instanceMap.set<CallDetect>(controlId, detectInstance)\n          this.emit('detect.started', detectInstance)\n          detectInstance.emit('detect.started', detectInstance)\n          resolve(detectInstance)\n        })\n        .catch((e) => {\n          this.emit('detect.ended', e)\n          reject(e)\n        })\n    })\n\n    return decorateDetectPromise.call(this, promise)\n  }\n\n  /**\n   * Detects the presence of an answering machine.\n   *\n   * @example\n   *\n   * ```js\n   * const detect = await call.amd()\n   * const result = await detect.ended()\n   *\n   * console.log('Detect result:', result.type)\n   * ```\n   */\n  amd(params: CallDetectMachineParams = {}) {\n    return this.detect({\n      ...params,\n      type: 'machine',\n    })\n  }\n\n  /**\n   * Alias for amd()\n   */\n  detectAnsweringMachine = this.amd\n\n  /**\n   * Detects the presence of a fax machine.\n   *\n   * @example\n   *\n   * ```js\n   * const detect = await call.detectFax()\n   * const result = await detect.ended()\n   *\n   * console.log('Detect result:', result.type)\n   * ```\n   */\n  detectFax(params: CallDetectFaxParams = {}) {\n    return this.detect({\n      ...params,\n      type: 'fax',\n    })\n  }\n\n  /**\n   * Detects digits in the audio stream.\n   *\n   * @example\n   *\n   * ```js\n   * const detect = await call.detectDigit()\n   * const result = await detect.ended()\n   *\n   * console.log('Detect result:', result.type)\n   * ```\n   */\n  detectDigit(params: CallDetectDigitParams = {}) {\n    return this.detect({\n      ...params,\n      type: 'digit',\n    })\n  }\n\n  /**\n   * Collect user input from the call, such as `digits` or `speech`.\n   *\n   * @example\n   *\n   * Collect digits and waiting for a result:\n   *\n   * ```js\n   * const collectObj = await call.collect({\n   *   digits: {\n   *     max: 5,\n   *     digitTimeout: 2,\n   *     terminators: '#*'\n   *   }\n   * })\n   * const { digits, terminator } = await collectObj.ended()\n   * ```\n   */\n  collect(params: CallCollectMethodParams) {\n    const promise = new Promise<CallCollect>((resolve, reject) => {\n      const { listen, ...rest } = params\n\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call collect() on a call not established yet.`))\n      }\n\n      const controlId = uuid()\n\n      // TODO: move this to a method to build the params\n      const {\n        initial_timeout,\n        partial_results,\n        digits,\n        speech,\n        continuous,\n        send_start_of_input,\n        start_input_timers,\n      } = toSnakeCaseKeys(rest)\n\n      this._client.runWorker('voiceCallCollectWorker', {\n        worker: voiceCallCollectWorker,\n        initialState: {\n          controlId,\n        },\n      })\n\n      this._client\n        .execute({\n          method: 'calling.collect',\n          params: {\n            node_id: this.nodeId,\n            call_id: this.callId,\n            control_id: controlId,\n            initial_timeout,\n            digits,\n            speech,\n            partial_results,\n            continuous,\n            send_start_of_input,\n            start_input_timers,\n          },\n        })\n        .then(() => {\n          const collectInstance = new CallCollect({\n            call: this,\n            listeners: listen,\n            // @ts-expect-error\n            payload: {\n              control_id: controlId,\n              call_id: this.id!,\n              node_id: this.nodeId!,\n            },\n          })\n          this._client.instanceMap.set<CallCollect>(controlId, collectInstance)\n          this.emit('collect.started', collectInstance)\n          collectInstance.emit('collect.started', collectInstance)\n          resolve(collectInstance)\n        })\n        .catch((e) => {\n          this.emit('collect.failed', e)\n          reject(e)\n        })\n    })\n\n    return decorateCollectPromise.call(this, promise)\n  }\n\n  /**\n   * Returns a promise that is resolved only after the current call is in one of\n   * the specified states.\n   *\n   * @returns true if the requested states have been reached, false if they\n   * won't be reached because the call ended.\n   *\n   * @example\n   *\n   * ```js\n   * await call.waitFor('ended')\n   * ```\n   */\n  waitFor(params: CallingCallWaitForState | CallingCallWaitForState[]) {\n    return new Promise((resolve) => {\n      if (!params) {\n        resolve(true)\n      }\n\n      const events = Array.isArray(params) ? params : [params]\n      const emittedCallStates = new Set<CallingCallState>()\n      const shouldResolve = () => emittedCallStates.size === events.length\n      const shouldWaitForEnded = events.includes('ended')\n      // If the user is not awaiting for the `ended` state\n      // and we've got that from the server then we won't\n      // get the event/s the user was awaiting for\n      const shouldResolveUnsuccessful = (state: CallingCallState) => {\n        return !shouldWaitForEnded && state === 'ended'\n      }\n\n      this.on('call.state', (params) => {\n        if (events.includes(params.state as CallingCallWaitForState)) {\n          emittedCallStates.add(params.state!)\n        } else if (shouldResolveUnsuccessful(params.state!)) {\n          return resolve(false)\n        }\n\n        if (shouldResolve()) {\n          resolve(true)\n        }\n      })\n    })\n  }\n}\n", "import type {\n  VoiceCallDeviceParams,\n  VoiceCallDialMethodParams,\n  VoiceCallPlayParams,\n  VoiceCallPlayMethodParams,\n} from '@signalwire/core'\nimport { toSnakeCaseKeys } from '@signalwire/core'\n\nconst toInternalDevice = (device: VoiceCallDeviceParams) => {\n  switch (device.type) {\n    case 'sip': {\n      const { type, ...params } = device\n      return {\n        type,\n        params: toSnakeCaseKeys(params),\n      }\n    }\n    case 'phone': {\n      const { to, from, type, ...rest } = device\n      return {\n        type,\n        params: toSnakeCaseKeys({\n          ...rest,\n          to_number: to,\n          from_number: from,\n        }),\n      }\n    }\n\n    // TODO: handle other devices\n  }\n\n  return device\n}\n\n// TODO: add proper to internal mapping\ntype ToInternalDialParams<T> = T extends any ? any : any\n\nexport const toInternalDevices = (\n  params: VoiceCallDialMethodParams['devices'],\n  internalDevices: ToInternalDialParams<\n    VoiceCallDialMethodParams['devices']\n  > = []\n) => {\n  params.forEach((dev, index) => {\n    if (Array.isArray(dev)) {\n      internalDevices[index] = toInternalDevices(dev)\n    } else {\n      internalDevices[index] = toInternalDevice(dev)\n    }\n  })\n  return internalDevices\n}\n\nconst toInternalPlay = (media: VoiceCallPlayParams) => {\n  const { type, ...params } = media\n  return { type, params }\n}\n\n// TODO: add proper to internal mapping\ntype ToInternalPlayParams<T> = T extends any ? any : any\n\nexport const toInternalPlayParams = (\n  params: VoiceCallPlayMethodParams['media'],\n  result: ToInternalPlayParams<VoiceCallPlayMethodParams['media']> = []\n) => {\n  params.forEach((media, index) => {\n    if (Array.isArray(media)) {\n      result[index] = toInternalPlayParams(media)\n    } else {\n      result[index] = toInternalPlay(media)\n    }\n  })\n  return result\n}\n", "import type {\n  CreateVoicePlaylistParams,\n  VoicePlaylist,\n  VoiceCallPlayParams,\n  VoiceCallPlayAudioParams,\n  VoiceCallPlayTTSParams,\n  VoiceCallPlaySilenceParams,\n  VoiceCallPlayRingtoneParams,\n  VoicePlaylistAudioParams,\n  VoicePlaylistTTSParams,\n  VoicePlaylistSilenceParams,\n  VoicePlaylistRingtoneParams,\n} from '@signalwire/core'\n\n/**\n * A Playlist object allows you to specify a series of media which should be\n * played in sequence. You can then pass the playlist to the methods that\n * support it, for example {@link Call.play}.\n *\n * @example\n *\n * Creates a playlist for playing, in sequence, a TTS message, 1 second of\n * silence, and an mp3 file.\n *\n * ```js\n * const playlist = new Voice.Playlist({ volume: 1.0 })\n *   .add(Voice.Playlist.TTS({\n *     text: 'Welcome to SignalWire!',\n *   }))\n *   .add(Voice.Playlist.Silence({ duration: 1 }))\n *   .add(Voice.Playlist.Audio({\n *     url: 'https://cdn.signalwire.com/default-music/welcome.mp3'\n *   }))\n * ```\n */\nexport class Playlist implements VoicePlaylist {\n  private _media: VoicePlaylist['media'] = []\n\n  constructor(private params: CreateVoicePlaylistParams = {}) {}\n\n  /** Default volume for the audio in the playlist. */\n  get volume() {\n    return this.params?.volume\n  }\n\n  /** The media in this playlist. */\n  get media() {\n    return this._media\n  }\n\n  /** Adds a new media to the playlist*/\n  add(params: VoiceCallPlayParams) {\n    this._media.push(params)\n    return this\n  }\n\n  /**\n   * An audio media.\n   * @params params - {@link VoicePlaylistAudioParams}\n   * @returns - {@link VoiceCallPlayAudioParams}\n   **/\n  static Audio(params: VoicePlaylistAudioParams): VoiceCallPlayAudioParams {\n    return { type: 'audio', ...params }\n  }\n\n  /**\n   * A TTS media.\n   * @params params - {@link VoicePlaylistTTSParams}\n   * @returns - {@link VoiceCallPlayTTSParams}\n   **/\n  static TTS(params: VoicePlaylistTTSParams): VoiceCallPlayTTSParams {\n    return { type: 'tts', ...params }\n  }\n\n  /**\n   * A silence interval.\n   * @params params - {@link VoicePlaylistSilenceParams}\n   * @returns - {@link VoiceCallPlaySilenceParams}\n   **/\n  static Silence(\n    params: VoicePlaylistSilenceParams\n  ): VoiceCallPlaySilenceParams {\n    return { type: 'silence', ...params }\n  }\n\n  /**\n   * A ringtone media.\n   * @params param - {@link VoicePlaylistRingtoneParams}\n   * @returns - {@link VoiceCallPlayRingtoneParams}\n   **/\n  static Ringtone(\n    params: VoicePlaylistRingtoneParams\n  ): VoiceCallPlayRingtoneParams {\n    return { type: 'ringtone', ...params }\n  }\n}\n", "import {\n  CallingCallPlayEndState,\n  CallingCallPlayEventParams,\n  VoiceCallPlaybackContract,\n} from '@signalwire/core'\nimport { ListenSubscriber } from '../../ListenSubscriber'\nimport {\n  CallPlaybackEvents,\n  CallPlaybackListeners,\n  CallPlaybackListenersEventsMapping,\n} from '../../types'\nimport { Call } from '../Call'\n\nexport interface CallPlaybackOptions {\n  call: Call\n  payload: CallingCallPlayEventParams\n  listeners?: CallPlaybackListeners\n}\n\nconst ENDED_STATES: CallingCallPlayEndState[] = ['finished', 'error']\n\nexport class CallPlayback\n  extends ListenSubscriber<CallPlaybackListeners, CallPlaybackEvents>\n  implements VoiceCallPlaybackContract\n{\n  public _paused: boolean\n  private _volume: number\n  private _payload: CallingCallPlayEventParams\n  protected _eventMap: CallPlaybackListenersEventsMapping = {\n    onStarted: 'playback.started',\n    onUpdated: 'playback.updated',\n    onFailed: 'playback.failed',\n    onEnded: 'playback.ended',\n  }\n\n  constructor(options: CallPlaybackOptions) {\n    super({ swClient: options.call._sw })\n\n    this._payload = options.payload\n    this._paused = false\n\n    if (options.listeners) {\n      this.listen(options.listeners)\n    }\n  }\n\n  get id() {\n    return this._payload?.control_id.split('.')[0]\n  }\n\n  get volume() {\n    return this._volume\n  }\n\n  get callId() {\n    return this._payload?.call_id\n  }\n\n  get nodeId() {\n    return this._payload?.node_id\n  }\n\n  get controlId() {\n    return this._payload?.control_id\n  }\n\n  get state() {\n    return this._payload?.state\n  }\n\n  get hasEnded() {\n    if (ENDED_STATES.includes(this.state as CallingCallPlayEndState)) {\n      return true\n    }\n    return false\n  }\n\n  /** @internal */\n  setPayload(payload: CallingCallPlayEventParams) {\n    this._payload = payload\n  }\n\n  async pause() {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'calling.play.pause',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    return this\n  }\n\n  async resume() {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'calling.play.resume',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    return this\n  }\n\n  async stop() {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'calling.play.stop',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    return this\n  }\n\n  async setVolume(volume: number) {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    this._volume = volume\n\n    await this._client.execute({\n      method: 'calling.play.volume',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n        volume,\n      },\n    })\n\n    return this\n  }\n\n  /** @deprecated */\n  waitForEnded() {\n    return this.ended()\n  }\n\n  ended() {\n    return new Promise<this>((resolve) => {\n      const handler = () => {\n        this.off('playback.ended', handler)\n        this.off('playback.failed', handler)\n        // It's important to notice that we're returning\n        // `this` instead of creating a brand new instance\n        // using the payload. `this` is the instance created by the\n        // `voiceCallPlayWorker` (singleton per\n        // `call.play()`) that gets auto updated (using\n        // the latest payload per event) by the\n        // `voiceCallPlayWorker`\n        resolve(this)\n      }\n      this.once('playback.ended', handler)\n      this.once('playback.failed', handler)\n\n      // Resolve the promise if the play has already ended\n      if (this.hasEnded) {\n        handler()\n      }\n    })\n  }\n}\n", "import { Call } from './voice/Call'\nimport { RoomSession } from './video/RoomSession'\n\nexport interface DecoratePromiseOptions<T> {\n  promise: Promise<T>\n  namespace:\n    | 'playback'\n    | 'recording'\n    | 'prompt'\n    | 'tap'\n    | 'detect'\n    | 'collect'\n    | 'stream'\n  methods: string[]\n  getters: string[]\n}\n\nexport function decoratePromise<T, U>(\n  this: Call | RoomSession,\n  options: DecoratePromiseOptions<T>\n): Promise<U> {\n  const { promise: innerPromise, namespace, methods, getters } = options\n\n  const promise = new Promise<U>((resolve, reject) => {\n    const endedHandler = (instance: U) => {\n      // @ts-expect-error\n      this.off(`${namespace}.ended`, endedHandler)\n      resolve(instance)\n    }\n\n    // @ts-expect-error\n    this.once(`${namespace}.ended`, endedHandler)\n\n    innerPromise.catch((error) => {\n      // @ts-expect-error\n      this.off(`${namespace}.ended`, endedHandler)\n      reject(error)\n    })\n  })\n\n  Object.defineProperties(promise, {\n    onStarted: {\n      value: function () {\n        /**\n         * Since onStarted is a property of the outer promise.\n         * In case the inner promise rejects, the outer promise goes unhandled.\n         * Due to this, we need to catch both of the promises.\n         */\n        return new Promise((resolve, reject) => {\n          promise.catch(reject)\n          innerPromise.then(resolve).catch(reject)\n        })\n      },\n      enumerable: true,\n    },\n    onEnded: {\n      value: async function () {\n        const instance = await this.onStarted()\n        if (instance.hasEnded) {\n          return this\n        }\n        return await promise\n      },\n      enumerable: true,\n    },\n    listen: {\n      value: async function (...args: any) {\n        const instance = await this.onStarted()\n        return instance.listen(...args)\n      },\n      enumerable: true,\n    },\n    ...methods.reduce((acc: Record<string, any>, method) => {\n      acc[method] = {\n        value: async function (...args: any) {\n          const instance = await this.onStarted()\n          return instance[method](...args)\n        },\n        enumerable: true,\n      }\n      return acc\n    }, {}),\n    ...getters.reduce((acc: Record<string, any>, gettter) => {\n      acc[gettter] = {\n        get: async function () {\n          const instance = await this.onStarted()\n          return instance[gettter]\n        },\n        enumerable: true,\n      }\n      return acc\n    }, {}),\n  })\n\n  return promise\n}\n", "import {\n  CallingCallPlayEndState,\n  CallingCallPlayState,\n  Promisify,\n} from '@signalwire/core'\nimport { Call } from '../Call'\nimport { CallPlayback } from './CallPlayback'\nimport { decoratePromise } from '../../decoratePromise'\nimport { CallPlaybackListeners } from '../../types'\n\nexport interface CallPlaybackEnded {\n  id: string\n  volume: number\n  callId: string\n  nodeId: string\n  controlId: string\n  state: CallingCallPlayEndState\n}\n\nexport interface CallPlaybackPromise\n  extends Promise<CallPlaybackEnded>,\n    Omit<Promisify<CallPlaybackEnded>, 'state'> {\n  onStarted: () => Promise<CallPlayback>\n  onEnded: () => Promise<CallPlaybackEnded>\n  listen: (listeners: CallPlaybackListeners) => Promise<() => Promise<void>>\n  pause: () => Promise<CallPlayback>\n  resume: () => Promise<CallPlayback>\n  stop: () => Promise<CallPlayback>\n  setVolume: () => Promise<CallPlayback>\n  ended: () => Promise<CallPlayback>\n  state: Promise<CallingCallPlayState>\n}\n\nexport const getters = [\n  'id',\n  'volume',\n  'callId',\n  'nodeId',\n  'controlId',\n  'state',\n]\n\nexport const methods = ['pause', 'resume', 'stop', 'setVolume', 'ended']\n\nexport function decoratePlaybackPromise(\n  this: Call,\n  innerPromise: Promise<CallPlayback>\n) {\n  // prettier-ignore\n  return (decoratePromise<CallPlayback, CallPlaybackEnded>).call(this, { \n    promise: innerPromise,\n    namespace: 'playback',\n    methods,\n    getters,\n  }) as CallPlaybackPromise\n}\n", "import {\n  VoiceCallRecordingContract,\n  CallingCallRecordEndState,\n  CallingCallRecordEventParams,\n  CallingCallRecordPauseMethodParams,\n} from '@signalwire/core'\nimport { ListenSubscriber } from '../../ListenSubscriber'\nimport {\n  CallRecordingEvents,\n  CallRecordingListeners,\n  CallRecordingListenersEventsMapping,\n} from '../../types'\nimport { Call } from '../Call'\n\nexport interface CallRecordingOptions {\n  call: Call\n  payload: CallingCallRecordEventParams\n  listeners?: CallRecordingListeners\n}\n\nconst ENDED_STATES: CallingCallRecordEndState[] = ['finished', 'no_input']\n\nexport class CallRecording\n  extends ListenSubscriber<CallRecordingListeners, CallRecordingEvents>\n  implements VoiceCallRecordingContract\n{\n  public _paused: boolean\n  private _payload: CallingCallRecordEventParams\n  protected _eventMap: CallRecordingListenersEventsMapping = {\n    onStarted: 'recording.started',\n    onUpdated: 'recording.updated',\n    onFailed: 'recording.failed',\n    onEnded: 'recording.ended',\n  }\n\n  constructor(options: CallRecordingOptions) {\n    super({ swClient: options.call._sw })\n\n    this._payload = options.payload\n    this._paused = false\n\n    if (options.listeners) {\n      this.listen(options.listeners)\n    }\n  }\n\n  get id() {\n    return this._payload.control_id\n  }\n\n  get callId() {\n    return this._payload.call_id\n  }\n\n  get nodeId() {\n    return this._payload.node_id\n  }\n\n  get controlId() {\n    return this._payload.control_id\n  }\n\n  get state() {\n    return this._payload.state\n  }\n\n  get url() {\n    return this._payload.url\n  }\n\n  get size() {\n    return this._payload.size\n  }\n\n  get duration() {\n    return this._payload.duration\n  }\n\n  get record() {\n    return this._payload.record\n  }\n\n  get hasEnded() {\n    if (ENDED_STATES.includes(this.state as CallingCallRecordEndState)) {\n      return true\n    }\n    return false\n  }\n\n  /** @internal */\n  setPayload(payload: CallingCallRecordEventParams) {\n    this._payload = payload\n  }\n\n  async pause(params?: CallingCallRecordPauseMethodParams) {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    const { behavior = 'silence' } = params || {}\n\n    await this._client.execute({\n      method: 'calling.record.pause',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n        behavior,\n      },\n    })\n\n    return this\n  }\n\n  async resume() {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'calling.record.resume',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    return this\n  }\n\n  async stop() {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'calling.record.stop',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    return this\n  }\n\n  ended() {\n    return new Promise<this>((resolve) => {\n      const handler = () => {\n        this.off('recording.ended', handler)\n        this.off('recording.failed', handler)\n        // It's important to notice that we're returning\n        // `this` instead of creating a brand new instance\n        // using the payload. `this` is the instance created by the\n        // `voiceCallRecordWorker` (singleton per\n        // `call.play()`) that gets auto updated (using\n        // the latest payload per event) by the\n        // `voiceCallRecordWorker`\n        resolve(this)\n      }\n      this.once('recording.ended', handler)\n      this.once('recording.failed', handler)\n\n      // Resolve the promise if the recording has already ended\n      if (this.hasEnded) {\n        handler()\n      }\n    })\n  }\n}\n", "import {\n  CallingCallRecordEndState,\n  CallingCallRecordState,\n  Promisify,\n} from '@signalwire/core'\nimport { Call } from '../Call'\nimport { CallRecording } from './CallRecording'\nimport { decoratePromise } from '../../decoratePromise'\nimport { CallRecordingListeners } from '../../types'\n\nexport interface CallRecordingEnded {\n  id: string\n  callId: string\n  nodeId: string\n  controlId: string\n  state: CallingCallRecordEndState\n  url: string | undefined\n  duration: number | undefined\n  record: any\n}\n\nexport interface CallRecordingPromise\n  extends Promise<CallRecordingEnded>,\n    Omit<Promisify<CallRecordingEnded>, 'state'> {\n  onStarted: () => Promise<CallRecording>\n  onEnded: () => Promise<CallRecordingEnded>\n  listen: (listeners: CallRecordingListeners) => Promise<() => Promise<void>>\n  pause: () => Promise<CallRecording>\n  resume: () => Promise<CallRecording>\n  stop: () => Promise<CallRecording>\n  setVolume: () => Promise<CallRecording>\n  ended: () => Promise<CallRecording>\n  state: Promise<CallingCallRecordState>\n}\n\nexport const getters = [\n  'id',\n  'callId',\n  'nodeId',\n  'controlId',\n  'state',\n  'url',\n  'size',\n  'duration',\n  'record',\n]\n\nexport const methods = ['pause', 'resume', 'stop', 'ended']\n\nexport function decorateRecordingPromise(\n  this: Call,\n  innerPromise: Promise<CallRecording>\n) {\n  // prettier-ignore\n  return (decoratePromise<CallRecording, CallRecordingEnded>).call(this, { \n    promise: innerPromise,\n    namespace: 'recording',\n    methods,\n    getters,\n  }) as CallRecordingPromise\n}\n", "import {\n  VoiceCallPromptContract,\n  CallingCallCollectEndState,\n  CallingCallCollectEventParams,\n} from '@signalwire/core'\nimport { Call } from '../Call'\nimport {\n  CallPromptEvents,\n  CallPromptListeners,\n  CallPromptListenersEventsMapping,\n} from '../../types'\nimport { ListenSubscriber } from '../../ListenSubscriber'\n\nexport interface CallPromptOptions {\n  call: Call\n  payload: CallingCallCollectEventParams\n  listeners?: CallPromptListeners\n}\n\nconst ENDED_STATES: CallingCallCollectEndState[] = [\n  'no_input',\n  'error',\n  'no_match',\n  'digit',\n  'speech',\n]\n\nexport class CallPrompt\n  extends ListenSubscriber<CallPromptListeners, CallPromptEvents>\n  implements VoiceCallPromptContract\n{\n  private _payload: CallingCallCollectEventParams\n  protected _eventMap: CallPromptListenersEventsMapping = {\n    onStarted: 'prompt.started',\n    onUpdated: 'prompt.updated',\n    onFailed: 'prompt.failed',\n    onEnded: 'prompt.ended',\n  }\n\n  constructor(options: CallPromptOptions) {\n    super({ swClient: options.call._sw })\n\n    this._payload = options.payload\n\n    if (options.listeners) {\n      this.listen(options.listeners)\n    }\n  }\n\n  get id() {\n    return this._payload?.control_id.split('.')[0]\n  }\n\n  get controlId() {\n    return this._payload.control_id\n  }\n\n  get callId() {\n    return this._payload.call_id\n  }\n\n  get nodeId() {\n    return this._payload.node_id\n  }\n\n  get result() {\n    return this._payload.result\n  }\n\n  get type() {\n    return this.result?.type\n  }\n\n  /**\n   * User-friendly alias to understand the reason in case of errors\n   * no_match | no_input | error\n   */\n  get reason() {\n    return this.type\n  }\n\n  get digits() {\n    if (this.result?.type === 'digit') {\n      return this.result.params.digits\n    }\n    return undefined\n  }\n\n  get speech() {\n    if (this.result?.type === 'speech') {\n      return this.result.params.text\n    }\n    return undefined\n  }\n\n  get terminator() {\n    if (this.result?.type === 'digit') {\n      return this.result.params.terminator\n    }\n    return undefined\n  }\n\n  get text() {\n    if (this.result?.type === 'speech') {\n      return this.result.params.text\n    }\n    return undefined\n  }\n\n  get confidence() {\n    if (this.result?.type === 'speech') {\n      return this.result.params.confidence\n    }\n    return undefined\n  }\n\n  get hasEnded() {\n    if (\n      ENDED_STATES.includes(this.result?.type as CallingCallCollectEndState)\n    ) {\n      return true\n    }\n    return false\n  }\n\n  /** @internal */\n  setPayload(payload: CallingCallCollectEventParams) {\n    this._payload = payload\n  }\n\n  async stop() {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'calling.play_and_collect.stop',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    return this\n  }\n\n  async setVolume(volume: number): Promise<this> {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'calling.play_and_collect.volume',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n        volume,\n      },\n    })\n\n    return this\n  }\n\n  /** @deprecated */\n  waitForResult() {\n    return this.ended()\n  }\n\n  ended() {\n    return new Promise<this>((resolve) => {\n      const handler = () => {\n        this.off('prompt.ended', handler)\n        this.off('prompt.failed', handler)\n        // It's important to notice that we're returning\n        // `this` instead of creating a brand new instance\n        // using the payload. `this` is the instance created by the\n        // `voiceCallPlayWorker` (singleton per\n        // `call.play()`) that gets auto updated (using\n        // the latest payload per event) by the\n        // `voiceCallPlayWorker`\n        resolve(this)\n      }\n      this.once('prompt.ended', handler)\n      this.once('prompt.failed', handler)\n\n      // Resolve the promise if the prompt has already ended\n      if (this.hasEnded) {\n        handler()\n      }\n    })\n  }\n}\n", "import { CallingCallCollectResult, Promisify } from '@signalwire/core'\nimport { Call } from '../Call'\nimport { CallPrompt } from './CallPrompt'\nimport { decoratePromise } from '../../decoratePromise'\nimport { CallPromptListeners } from '../../types'\n\nexport interface CallPromptEnded {\n  id: string\n  controlId: string\n  callId: string\n  nodeId: string\n  result: CallingCallCollectResult\n  type: CallingCallCollectResult['type']\n  reason: CallingCallCollectResult['type']\n  digits?: string\n  speech?: string\n  terminator?: string\n  text?: string\n  confidence?: number\n}\n\nexport interface CallPromptPromise\n  extends Promise<CallPromptEnded>,\n    Promisify<CallPromptEnded> {\n  onStarted: () => Promise<CallPrompt>\n  onEnded: () => Promise<CallPromptEnded>\n  listen: (listeners: CallPromptListeners) => Promise<() => Promise<void>>\n  stop: () => Promise<CallPrompt>\n  setVolume: () => Promise<CallPrompt>\n  ended: () => Promise<CallPrompt>\n}\n\nexport const getters = [\n  'id',\n  'controlId',\n  'callId',\n  'nodeId',\n  'result',\n  'type',\n  'reason',\n  'digits',\n  'speech',\n  'terminator',\n  'text',\n  'confidence',\n]\n\nexport const methods = ['stop', 'setVolume', 'ended']\n\nexport function decoratePromptPromise(\n  this: Call,\n  innerPromise: Promise<CallPrompt>\n) {\n  // prettier-ignore\n  return (decoratePromise<CallPrompt, CallPromptEnded>).call(this, { \n    promise: innerPromise,\n    namespace: 'prompt',\n    methods,\n    getters,\n  }) as CallPromptPromise\n}\n", "import {\n  VoiceCallCollectContract,\n  CallingCallCollectEndState,\n  CallingCallCollectEventParams,\n} from '@signalwire/core'\nimport { ListenSubscriber } from '../../ListenSubscriber'\nimport {\n  CallCollectEvents,\n  CallCollectListeners,\n  CallCollectListenersEventsMapping,\n} from '../../types'\nimport { Call } from '../Call'\n\nexport interface CallCollectOptions {\n  call: Call\n  payload: CallingCallCollectEventParams\n  listeners?: CallCollectListeners\n}\n\nconst ENDED_STATES: CallingCallCollectEndState[] = [\n  'error',\n  'no_input',\n  'no_match',\n  'digit',\n  'speech',\n]\n\nexport class CallCollect\n  extends ListenSubscriber<CallCollectListeners, CallCollectEvents>\n  implements VoiceCallCollectContract\n{\n  private _payload: CallingCallCollectEventParams\n  protected _eventMap: CallCollectListenersEventsMapping = {\n    onStarted: 'collect.started',\n    onInputStarted: 'collect.startOfInput',\n    onUpdated: 'collect.updated',\n    onFailed: 'collect.failed',\n    onEnded: 'collect.ended',\n  }\n\n  constructor(options: CallCollectOptions) {\n    super({ swClient: options.call._sw })\n\n    this._payload = options.payload\n\n    if (options.listeners) {\n      this.listen(options.listeners)\n    }\n  }\n\n  get id() {\n    return this._payload?.control_id.split('.')[0]\n  }\n\n  get controlId() {\n    return this._payload.control_id\n  }\n\n  get callId() {\n    return this._payload.call_id\n  }\n\n  get nodeId() {\n    return this._payload.node_id\n  }\n\n  get result() {\n    return this._payload.result\n  }\n\n  get type() {\n    return this.result?.type\n  }\n\n  /**\n   * User-friendly alias to understand the reason in case of errors\n   * no_match | no_input | error\n   */\n  get reason() {\n    return this.type\n  }\n\n  get digits() {\n    if (this.result?.type === 'digit') {\n      return this.result.params.digits\n    }\n    return undefined\n  }\n\n  get speech() {\n    if (this.result?.type === 'speech') {\n      return this.result.params.text\n    }\n    return undefined\n  }\n\n  get terminator() {\n    if (this.result?.type === 'digit') {\n      return this.result.params.terminator\n    }\n    return undefined\n  }\n\n  get text() {\n    if (this.result?.type === 'speech') {\n      return this.result.params.text\n    }\n    return undefined\n  }\n\n  get confidence() {\n    if (this.result?.type === 'speech') {\n      return this.result.params.confidence\n    }\n    return undefined\n  }\n\n  get state() {\n    return this._payload.state\n  }\n\n  get final() {\n    return this._payload.final\n  }\n\n  get hasEnded() {\n    if (\n      this.state !== 'collecting' &&\n      this.final !== false &&\n      ENDED_STATES.includes(this.result?.type as CallingCallCollectEndState)\n    ) {\n      return true\n    }\n    return false\n  }\n\n  /** @internal */\n  setPayload(payload: CallingCallCollectEventParams) {\n    this._payload = payload\n  }\n\n  async stop() {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'calling.collect.stop',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    return this\n  }\n\n  async startInputTimers() {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'calling.collect.start_input_timers',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    return this\n  }\n\n  ended() {\n    return new Promise<this>((resolve) => {\n      const handler = () => {\n        this.off('collect.ended', handler)\n        this.off('collect.failed', handler)\n        // It's important to notice that we're returning\n        // `this` instead of creating a brand new instance\n        // using the payload. `this` is the instance created by the\n        // `voiceCallCollectWorker` (singleton per\n        // `call.play()`) that gets auto updated (using\n        // the latest payload per event) by the\n        // `voiceCallCollectWorker`\n        resolve(this)\n      }\n      this.once('collect.ended', handler)\n      this.once('collect.failed', handler)\n\n      // Resolve the promise if the collect has already ended\n      if (this.hasEnded) {\n        handler()\n      }\n    })\n  }\n}\n", "import { CallingCallCollectResult, Promisify } from '@signalwire/core'\nimport { Call } from '../Call'\nimport { CallCollect } from './CallCollect'\nimport { decoratePromise } from '../../decoratePromise'\nimport { CallCollectListeners } from '../../types'\n\nexport interface CallCollectEnded {\n  id: string\n  callId: string\n  nodeId: string\n  controlId: string\n  result?: CallingCallCollectResult\n  type?: CallingCallCollectResult['type']\n  reason?: CallingCallCollectResult['type']\n  digits?: string\n  speech?: string\n  terminator?: string\n  text?: string\n  confidence?: number\n}\nexport interface CallCollectPromise\n  extends Promise<CallCollectEnded>,\n    Promisify<CallCollectEnded> {\n  onStarted: () => Promise<CallCollect>\n  onEnded: () => Promise<CallCollectEnded>\n  listen: (listeners: CallCollectListeners) => Promise<() => Promise<void>>\n  stop: () => Promise<CallCollect>\n  startInputTimers: () => Promise<CallCollect>\n  ended: () => Promise<CallCollect>\n}\n\nexport const getters = [\n  'id',\n  'callId',\n  'nodeId',\n  'controlId',\n  'result',\n  'type',\n  'reason',\n  'digits',\n  'speech',\n  'terminator',\n  'text',\n  'confidence',\n]\n\nexport const methods = ['stop', 'startInputTimers', 'ended']\n\nexport function decorateCollectPromise(\n  this: Call,\n  innerPromise: Promise<CallCollect>\n) {\n  // prettier-ignore\n  return (decoratePromise<CallCollect, CallCollectEnded>).call(this, { \n    promise: innerPromise,\n    namespace: 'collect',\n    methods,\n    getters,\n  }) as CallCollectPromise\n}\n", "import {\n  VoiceCallTapContract,\n  CallingCallTapEndState,\n  CallingCallTapEventParams,\n} from '@signalwire/core'\nimport { ListenSubscriber } from '../../ListenSubscriber'\nimport {\n  CallTapEvents,\n  CallTapListeners,\n  CallTapListenersEventsMapping,\n} from '../../types'\nimport { Call } from '../Call'\n\nexport interface CallTapOptions {\n  call: Call\n  payload: CallingCallTapEventParams\n  listeners?: CallTapListeners\n}\n\nconst ENDED_STATES: CallingCallTapEndState[] = ['finished']\n\nexport class CallTap\n  extends ListenSubscriber<CallTapListeners, CallTapEvents>\n  implements VoiceCallTapContract\n{\n  private _payload: CallingCallTapEventParams\n  protected _eventMap: CallTapListenersEventsMapping = {\n    onStarted: 'tap.started',\n    onEnded: 'tap.ended',\n  }\n\n  constructor(options: CallTapOptions) {\n    super({ swClient: options.call._sw })\n\n    this._payload = options.payload\n\n    if (options.listeners) {\n      this.listen(options.listeners)\n    }\n  }\n\n  get id() {\n    return this._payload.control_id\n  }\n\n  get controlId() {\n    return this._payload.control_id\n  }\n\n  get nodeId() {\n    return this._payload.node_id\n  }\n\n  get callId() {\n    return this._payload.call_id\n  }\n\n  get state() {\n    return this._payload.state\n  }\n\n  get hasEnded() {\n    if (ENDED_STATES.includes(this.state as CallingCallTapEndState)) {\n      return true\n    }\n    return false\n  }\n\n  /** @internal */\n  setPayload(payload: CallingCallTapEventParams) {\n    this._payload = payload\n  }\n\n  async stop() {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'calling.tap.stop',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    return this\n  }\n\n  ended() {\n    return new Promise<this>((resolve) => {\n      const handler = () => {\n        this.off('tap.ended', handler)\n        // It's important to notice that we're returning\n        // `this` instead of creating a brand new instance\n        // using the payload. `this` is the instance created by the\n        // `voiceCallTapWorker` (singleton per\n        // `call.play()`) that gets auto updated (using\n        // the latest payload per event) by the\n        // `voiceCallTapWorker`\n        resolve(this)\n      }\n      this.once('tap.ended', handler)\n\n      // Resolve the promise if the tap has already ended\n      if (this.hasEnded) {\n        handler()\n      }\n    })\n  }\n}\n", "import {\n  CallingCallTapEndState,\n  CallingCallTapState,\n  Promisify,\n} from '@signalwire/core'\nimport { Call } from '../Call'\nimport { CallTap } from './CallTap'\nimport { decoratePromise } from '../../decoratePromise'\nimport { CallTapListeners } from '../../types'\n\nexport interface CallTapEnded {\n  id: string\n  callId: string\n  nodeId: string\n  controlId: string\n  state: CallingCallTapEndState\n}\n\nexport interface CallTapPromise\n  extends Promise<CallTapEnded>,\n    Omit<Promisify<CallTapEnded>, 'state'> {\n  onStarted: () => Promise<CallTap>\n  onEnded: () => Promise<CallTapEnded>\n  listen: (listeners: CallTapListeners) => Promise<() => Promise<void>>\n  stop: () => Promise<CallTap>\n  ended: () => Promise<CallTap>\n  state: Promise<CallingCallTapState>\n}\n\nexport const getters = ['id', 'callId', 'nodeId', 'controlId', 'state']\n\nexport const methods = ['stop', 'ended']\n\nexport function decorateTapPromise(this: Call, innerPromise: Promise<CallTap>) {\n  // prettier-ignore\n  return (decoratePromise<CallTap, CallTapEnded>).call(this, { \n    promise: innerPromise,\n    namespace: 'tap',\n    methods,\n    getters,\n  }) as CallTapPromise\n}\n", "import type {\n  VoiceDeviceBuilder,\n  VoiceCallDeviceParams,\n  VoiceCallPhoneParams,\n  VoiceCallDialPhoneMethodParams,\n  VoiceCallSipParams,\n  VoiceCallDialSipMethodParams,\n} from '@signalwire/core'\n\n/**\n * A DeviceBuilder object allows you to specify a set of devices which should be\n * dialed in sequence or parallel. You can then pass the device plan to the\n * methods that support it, for example {@link Call.connect}.\n *\n * @example\n *\n * Creates a plan which specifies to dial a SIP endpoint. If there is no answer\n * within 30 seconds, calls two phone numbers in parallel (as indicated by the\n * array syntax). As soon as one of the two answers, the operation is\n * considered successful.\n *\n * ```js\n * const plan = new Voice.DeviceBuilder()\n *   .add(Voice.DeviceBuilder.Sip({\n *     from: 'sip:user1@domain.com',\n *     to: 'sip:user2@domain.com',\n *     timeout: 30,\n *   }))\n *   .add([\n *     Voice.DeviceBuilder.Phone({ to: '+yyyyyy', timeout: 30 }),\n *     Voice.DeviceBuilder.Phone({ to: '+zzzzzz', timeout: 30 })\n *   ])\n * ```\n */\nexport class DeviceBuilder implements VoiceDeviceBuilder {\n  private _devices: VoiceDeviceBuilder['devices'] = []\n\n  get devices() {\n    return this._devices\n  }\n\n  add(params: VoiceCallDeviceParams | VoiceCallDeviceParams[]) {\n    if (Array.isArray(params)) {\n      this._devices.push(params)\n    } else {\n      this._devices.push([params])\n    }\n\n    return this\n  }\n\n  static Phone(params: VoiceCallDialPhoneMethodParams): VoiceCallPhoneParams {\n    return { type: 'phone', ...params }\n  }\n\n  static Sip(params: VoiceCallDialSipMethodParams): VoiceCallSipParams {\n    return { type: 'sip', ...params }\n  }\n}\n", "import {\n  VoiceCallDetectContract,\n  CallingCallDetectEventParams,\n  type DetectorResult,\n} from '@signalwire/core'\nimport { ListenSubscriber } from '../../ListenSubscriber'\nimport {\n  CallDetectEvents,\n  CallDetectListeners,\n  CallDetectListenersEventsMapping,\n} from '../../types'\nimport { Call } from '../Call'\n\nexport interface CallDetectOptions {\n  call: Call\n  payload: CallingCallDetectEventParams\n  listeners?: CallDetectListeners\n}\n\nconst ENDED_STATES: DetectorResult[] = ['finished', 'error']\n\nexport class CallDetect\n  extends ListenSubscriber<CallDetectListeners, CallDetectEvents>\n  implements VoiceCallDetectContract\n{\n  private _waitForBeep: boolean\n  private _result: DetectorResult = 'UNKNOWN'\n  private _payload: CallingCallDetectEventParams\n  protected _eventMap: CallDetectListenersEventsMapping = {\n    onStarted: 'detect.started',\n    onUpdated: 'detect.updated',\n    onEnded: 'detect.ended',\n  }\n\n  constructor(options: CallDetectOptions) {\n    super({ swClient: options.call._sw })\n\n    this._payload = options.payload\n    this._waitForBeep = options.payload.waitForBeep\n\n    if (options.listeners) {\n      this.listen(options.listeners)\n    }\n  }\n\n  get id() {\n    return this._payload.control_id\n  }\n\n  get controlId() {\n    return this._payload.control_id\n  }\n\n  get callId() {\n    return this._payload.call_id\n  }\n\n  get nodeId() {\n    return this._payload.node_id\n  }\n\n  get detect() {\n    return this._payload.detect\n  }\n\n  get type() {\n    return this?.detect?.type\n  }\n\n  get result() {\n    return this._result\n  }\n\n  get waitForBeep() {\n    return this._waitForBeep\n  }\n\n  get beep() {\n    if (this.detect?.params.event === 'MACHINE') {\n      return Boolean(this.detect.params.beep)\n    }\n    return undefined\n  }\n\n  get hasEnded() {\n    const lastEvent = this._lastEvent()\n    if (lastEvent && ENDED_STATES.includes(lastEvent)) {\n      return true\n    }\n    return false\n  }\n\n  /** @internal */\n  setPayload(payload: CallingCallDetectEventParams) {\n    this._payload = payload\n\n    const lastEvent = this._lastEvent()\n    if (lastEvent && lastEvent !== 'finished') {\n      this._result = lastEvent\n    }\n  }\n\n  async stop() {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'calling.detect.stop',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    return this\n  }\n\n  /** @deprecated */\n  waitForResult() {\n    return this.ended()\n  }\n\n  ended() {\n    // Resolve the promise if the detect has already ended\n    const lastEvent = this._lastEvent()\n    if (lastEvent && ENDED_STATES.includes(lastEvent)) {\n      return Promise.resolve(this)\n    }\n\n    return new Promise<this>((resolve) => {\n      const handler = () => {\n        this.off('detect.ended', handler)\n        // It's important to notice that we're returning\n        // `this` instead of creating a brand new instance\n        // using the payload. `this` is the instance created by the\n        // `voiceCallDetectWorker` (singleton per\n        // `call.play()`) that gets auto updated (using\n        // the latest payload per event) by the\n        // `voiceCallDetectWorker`\n        resolve(this)\n      }\n      this.once('detect.ended', handler)\n    })\n  }\n\n  private _lastEvent() {\n    return this.detect?.params.event\n  }\n}\n", "import {\n  CallingCallDetectType,\n  Detector,\n  DetectorResult,\n  Promisify,\n} from '@signalwire/core'\nimport { Call } from '../Call'\nimport { CallDetect } from './CallDetect'\nimport { decoratePromise } from '../../decoratePromise'\nimport { CallDetectListeners } from '../../types'\n\nexport interface CallDetectEnded {\n  id: string\n  callId: string\n  nodeId: string\n  controlId: string\n  detect?: Detector\n  type?: CallingCallDetectType\n  result: DetectorResult\n  waitForBeep: boolean\n  beep?: boolean\n}\n\nexport interface CallDetectPromise\n  extends Promise<CallDetectEnded>,\n    Promisify<CallDetectEnded> {\n  onStarted: () => Promise<CallDetect>\n  onEnded: () => Promise<CallDetectEnded>\n  listen: (listeners: CallDetectListeners) => Promise<() => Promise<void>>\n  stop: () => Promise<CallDetect>\n  ended: () => Promise<CallDetect>\n}\n\nexport const getters = [\n  'id',\n  'callId',\n  'nodeId',\n  'controlId',\n  'detect',\n  'type',\n  'result',\n  'waitForBeep',\n  'beep',\n]\n\nexport const methods = ['stop', 'ended']\n\nexport function decorateDetectPromise(\n  this: Call,\n  innerPromise: Promise<CallDetect>\n) {\n  // prettier-ignore\n  return (decoratePromise<CallDetect, CallDetectEnded>).call(this, { \n    promise: innerPromise,\n    namespace: 'detect',\n    methods,\n    getters,\n  }) as CallDetectPromise\n}\n", "import { CallingCallStateEventParams, InstanceMap } from '@signalwire/core'\nimport { RealTimeCallListeners } from '../../../types'\nimport { Call } from '../../Call'\nimport { Voice } from '../../Voice'\n\ninterface CallStateEventsHandlerOptions {\n  payload: CallingCallStateEventParams\n  voice: Voice\n  instanceMap: InstanceMap\n  listeners?: RealTimeCallListeners\n}\n\nexport function handleCallStateEvents(options: CallStateEventsHandlerOptions) {\n  const {\n    payload,\n    voice,\n    listeners,\n    instanceMap: { get, set, remove },\n  } = options\n\n  let callInstance = get<Call>(payload.call_id)\n  if (!callInstance) {\n    callInstance = new Call({\n      voice,\n      payload,\n      listeners,\n    })\n  } else {\n    callInstance.setPayload(payload)\n  }\n  set<Call>(payload.call_id, callInstance)\n\n  switch (payload.call_state) {\n    case 'ended': {\n      callInstance.emit('call.state', callInstance)\n\n      // Resolves the promise when user disconnects using a peer call instance\n      // @ts-expect-error\n      callInstance.emit('connect.disconnected', callInstance)\n      remove<Call>(payload.call_id)\n\n      return true\n    }\n    default:\n      callInstance.emit('call.state', callInstance)\n      return false\n  }\n}\n", "import { CallingCallConnectEventParams, InstanceMap } from '@signalwire/core'\nimport { Call } from '../../Call'\nimport { Voice } from '../../Voice'\n\ninterface CallConnectEventsHandlerOptions {\n  payload: CallingCallConnectEventParams\n  instanceMap: InstanceMap\n  voice: Voice\n}\n\nexport function handleCallConnectEvents(\n  options: CallConnectEventsHandlerOptions\n) {\n  const { payload, instanceMap, voice } = options\n  const { get, set } = instanceMap\n\n  const callInstance = get<Call>(payload.call_id)\n  if (!callInstance) {\n    throw new Error('Missing call instance for connect')\n  }\n  callInstance.setConnectPayload(payload)\n  set<Call>(payload.call_id, callInstance)\n\n  // TODO: The below events seems to be not documented in @RealTimeCallApiEvents. For now, ingoring TS issues\n\n  callInstance.emit('call.state', callInstance)\n\n  switch (payload.connect_state) {\n    case 'connecting': {\n      // @ts-expect-error\n      callInstance.emit('connect.connecting', callInstance)\n      return false\n    }\n    case 'connected': {\n      let peerCallInstance = get<Call>(payload.peer.call_id)\n      if (!peerCallInstance) {\n        peerCallInstance = new Call({\n          voice,\n          connectPayload: payload,\n        })\n      } else {\n        peerCallInstance.setConnectPayload(payload)\n      }\n      set<Call>(payload.peer.call_id, peerCallInstance)\n      callInstance.peer = peerCallInstance\n      peerCallInstance.peer = callInstance\n      // @ts-expect-error\n      callInstance.emit('connect.connected', peerCallInstance)\n      return false\n    }\n    case 'disconnected': {\n      // @ts-expect-error\n      callInstance.emit('connect.disconnected')\n      callInstance.peer = undefined\n\n      const peerCallInstance = get<Call>(payload.peer.call_id)\n      // Add a check because peer call can be removed from the instance map throgh voiceCallStateWorker\n      if (peerCallInstance) {\n        console.log('emit peer disconnected', peerCallInstance.callId)\n        // @ts-expect-error\n        peerCallInstance.emit('connect.disconnected')\n        peerCallInstance.peer = undefined\n      }\n      return true\n    }\n    case 'failed': {\n      callInstance.peer = undefined\n      // @ts-expect-error\n      callInstance.emit('connect.failed', payload)\n      return true\n    }\n    default:\n      // @ts-expect-error\n      getLogger().warn(`Unknown connect state: \"${payload.connect_state}\"`)\n      return false\n  }\n}\n", "import { CallingCallDialEventParams, InstanceMap } from '@signalwire/core'\nimport { Call } from '../../Call'\nimport { Voice } from '../../Voice'\n\ninterface CallDialEventsHandlerOptions {\n  payload: CallingCallDialEventParams\n  instanceMap: InstanceMap\n  voice: Voice\n}\n\nexport function handleCallDialEvents(options: CallDialEventsHandlerOptions) {\n  const { payload, instanceMap, voice } = options\n  const { get } = instanceMap\n\n  switch (payload.dial_state) {\n    case 'failed': {\n      // @ts-expect-error\n      voice.emit('dial.failed', payload)\n      return true\n    }\n    case 'answered': {\n      const callInstance = get<Call>(payload.call.call_id)\n      callInstance.setPayload(payload.call)\n      // @ts-expect-error\n      voice.emit('dial.answered', callInstance)\n      return true\n    }\n    default:\n      return false\n  }\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  SDKWorker,\n  sagaEffects,\n  VoiceCallPlayAction,\n} from '@signalwire/core'\nimport type { Client } from '../../client/index'\nimport { CallPlaybackListeners } from '../../types'\nimport { CallPlayback } from '../CallPlayback'\nimport { Call } from '../Call'\nimport { SDKActions } from 'packages/core/dist/core/src'\n\ninterface VoiceCallPlayWorkerInitialState {\n  controlId: string\n  listeners?: CallPlaybackListeners\n}\n\nexport const voiceCallPlayWorker: SDKWorker<Client> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('voiceCallPlayWorker started')\n  const {\n    channels: { swEventChannel },\n    instanceMap: { get, set, remove },\n    initialState,\n  } = options\n\n  const { controlId, listeners } =\n    initialState as VoiceCallPlayWorkerInitialState\n\n  /**\n   * Playback listeners can be attached to both Call and CallPlayback objects\n   * So, we emit the events for both objects\n   * Some events are also being used to resolve the promise such as playback.started and playback.failed\n   * This worker is also responsible to handle CallPrompt events\n   */\n\n  function* worker(action: VoiceCallPlayAction) {\n    const { payload } = action\n\n    if (payload.control_id !== controlId) return\n\n    // CallPrompt events contains .prompt at the end of the control id\n    const [playbackControlId] = payload.control_id.split('.')\n\n    const removeFromInstanceMap = () => {\n      // Do not remove the CallPrompt instance. It will be removed by the @voiceCallCollectWorker\n      if (payload.control_id.includes('.prompt')) return\n      remove<CallPlayback>(playbackControlId)\n    }\n\n    const callInstance = get<Call>(payload.call_id)\n    if (!callInstance) {\n      throw new Error('Missing call instance for playback')\n    }\n\n    let playbackInstance = get<CallPlayback>(playbackControlId)\n    if (!playbackInstance) {\n      playbackInstance = new CallPlayback({\n        call: callInstance,\n        payload,\n        listeners,\n      })\n    } else {\n      playbackInstance.setPayload(payload)\n    }\n    set<CallPlayback>(playbackControlId, playbackInstance)\n\n    switch (payload.state) {\n      case 'playing': {\n        const type = playbackInstance._paused\n          ? 'playback.updated'\n          : 'playback.started'\n        playbackInstance._paused = false\n        callInstance.emit(type, playbackInstance)\n        playbackInstance.emit(type, playbackInstance)\n        return false\n      }\n      case 'paused': {\n        playbackInstance._paused = true\n        callInstance.emit('playback.updated', playbackInstance)\n        playbackInstance.emit('playback.updated', playbackInstance)\n        return false\n      }\n      case 'error': {\n        callInstance.emit('playback.failed', playbackInstance)\n        playbackInstance.emit('playback.failed', playbackInstance)\n        removeFromInstanceMap()\n        return true\n      }\n      case 'finished': {\n        callInstance.emit('playback.ended', playbackInstance)\n        playbackInstance.emit('playback.ended', playbackInstance)\n        removeFromInstanceMap()\n        return true\n      }\n      default:\n        getLogger().warn(`Unknown playback state: \"${payload.state}\"`)\n        return false\n    }\n  }\n\n  while (true) {\n    const action = yield sagaEffects.take(\n      swEventChannel,\n      (action: SDKActions) => action.type === 'calling.call.play'\n    )\n\n    const shouldStop = yield sagaEffects.fork(worker, action)\n\n    if (shouldStop.result()) break\n  }\n\n  getLogger().trace('voiceCallPlayWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  SDKWorker,\n  sagaEffects,\n  SDKActions,\n  VoiceCallRecordAction,\n} from '@signalwire/core'\nimport type { Client } from '../../client/index'\nimport { CallRecordingListeners } from '../../types'\nimport { Call } from '../Call'\nimport { CallRecording } from '../CallRecording'\n\ninterface VoiceCallRecordWorkerInitialState {\n  controlId: string\n  listeners?: CallRecordingListeners\n}\n\nexport const voiceCallRecordWorker: SDKWorker<Client> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('voiceCallRecordWorker started')\n  const {\n    channels: { swEventChannel },\n    instanceMap: { get, set, remove },\n    initialState,\n  } = options\n\n  const { controlId, listeners } =\n    initialState as VoiceCallRecordWorkerInitialState\n\n  function* worker(action: VoiceCallRecordAction) {\n    const { payload } = action\n\n    if (payload.control_id !== controlId) return\n\n    const callInstance = get<Call>(payload.call_id)\n    if (!callInstance) {\n      throw new Error('Missing call instance for recording')\n    }\n\n    let recordingInstance = get<CallRecording>(payload.control_id)\n    if (!recordingInstance) {\n      recordingInstance = new CallRecording({\n        call: callInstance,\n        payload,\n        listeners,\n      })\n    } else {\n      recordingInstance.setPayload(payload)\n    }\n    set<CallRecording>(payload.control_id, recordingInstance)\n\n    switch (payload.state) {\n      case 'recording': {\n        const type = recordingInstance._paused\n          ? 'recording.updated'\n          : 'recording.started'\n        recordingInstance._paused = false\n\n        callInstance.emit(type, recordingInstance)\n        recordingInstance.emit(type, recordingInstance)\n        return false\n      }\n      case 'paused': {\n        recordingInstance._paused = true\n        callInstance.emit('recording.updated', recordingInstance)\n        recordingInstance.emit('recording.updated', recordingInstance)\n        return false\n      }\n      case 'no_input':\n      case 'finished': {\n        const type =\n          payload.state === 'finished' ? 'recording.ended' : 'recording.failed'\n        callInstance.emit(type, recordingInstance)\n        recordingInstance.emit(type, recordingInstance)\n\n        remove<CallRecording>(payload.control_id)\n        return true\n      }\n      default:\n        getLogger().warn(`Unknown recording state: \"${payload.state}\"`)\n        return false\n    }\n  }\n\n  while (true) {\n    const action = yield sagaEffects.take(\n      swEventChannel,\n      (action: SDKActions) => action.type === 'calling.call.record'\n    )\n\n    const shouldStop = yield sagaEffects.fork(worker, action)\n\n    if (shouldStop.result()) break\n  }\n\n  getLogger().trace('voiceCallRecordWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  sagaEffects,\n  SDKActions,\n  VoiceCallCollectAction,\n  SDKWorker,\n} from '@signalwire/core'\nimport type { Client } from '../../client/index'\nimport { CallCollectListeners } from '../../types'\nimport type { Call } from '../Call'\nimport { CallPrompt } from '../CallPrompt'\nimport { CallCollect } from '../CallCollect'\n\ninterface VoiceCallCollectWorkerInitialState {\n  controlId: string\n  listeners?: CallCollectListeners\n}\n\nexport const voiceCallCollectWorker: SDKWorker<Client> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('voiceCallCollectWorker started')\n  const {\n    channels: { swEventChannel },\n    instanceMap: { get, set, remove },\n    initialState,\n  } = options\n\n  const { controlId } = initialState as VoiceCallCollectWorkerInitialState\n\n  function* worker(action: VoiceCallCollectAction) {\n    const { payload } = action\n\n    if (payload.control_id !== controlId) return\n\n    const callInstance = get<Call>(payload.call_id)\n    if (!callInstance) {\n      throw new Error('Missing call instance for collect')\n    }\n\n    const actionInstance = get<CallPrompt | CallCollect>(payload.control_id)\n    if (!actionInstance) {\n      throw new Error('Missing the instance')\n    }\n    actionInstance.setPayload(payload)\n    set<CallPrompt | CallCollect>(payload.control_id, actionInstance)\n\n    let eventPrefix = 'collect' as 'collect' | 'prompt'\n    if (actionInstance instanceof CallPrompt) {\n      eventPrefix = 'prompt'\n    }\n\n    // These two variables are here to solve the TypeScript problems\n    const promptInstance: CallPrompt = actionInstance as CallPrompt\n    const collectInstance: CallCollect = actionInstance as CallCollect\n\n    /**\n     * Only when partial_results: true\n     */\n    if (payload.final === false) {\n      if (eventPrefix === 'prompt') {\n        callInstance.emit('prompt.updated', promptInstance)\n        promptInstance.emit('prompt.updated', promptInstance)\n      } else {\n        callInstance.emit('collect.updated', collectInstance)\n        collectInstance.emit('collect.updated', collectInstance)\n      }\n      return false\n    } else if (payload.final === true && payload.state == \"collecting\") {\n      // Even if final is true but we are still collecting, we want an update\n      if (eventPrefix === 'prompt') {\n        callInstance.emit('prompt.updated', promptInstance)\n        promptInstance.emit('prompt.updated', promptInstance)\n      } else {\n        callInstance.emit('collect.updated', collectInstance)\n        collectInstance.emit('collect.updated', collectInstance)\n      }\n    }\n\n    switch (payload.result.type) {\n      case 'start_of_input': {\n        if (eventPrefix === 'prompt') return false\n        callInstance.emit('collect.startOfInput', collectInstance)\n        collectInstance.emit('collect.startOfInput', collectInstance)\n        return false\n      }\n      case 'no_input':\n      case 'no_match':\n      case 'error': {\n        if (payload.state === 'collecting') return false\n\n        if (eventPrefix === 'prompt') {\n          callInstance.emit('prompt.failed', promptInstance)\n          promptInstance.emit('prompt.failed', promptInstance)\n        } else {\n          callInstance.emit('collect.failed', collectInstance)\n          collectInstance.emit('collect.failed', collectInstance)\n        }\n        remove<CallPrompt | CallCollect>(payload.control_id)\n\n        return true\n      }\n      case 'speech':\n      case 'digit': {\n        if (payload.state === 'collecting') return false\n\n        if (eventPrefix === 'prompt') {\n          callInstance.emit('prompt.ended', promptInstance)\n          promptInstance.emit('prompt.ended', promptInstance)\n        } else {\n          callInstance.emit('collect.ended', collectInstance)\n          collectInstance.emit('collect.ended', collectInstance)\n        }\n        remove<CallPrompt | CallCollect>(payload.control_id)\n\n        return false\n      }\n      default:\n        getLogger().warn(\n          // @ts-expect-error\n          `Unknown prompt result type: \"${payload.result.type}\"`\n        )\n        return false\n    }\n  }\n\n  while (true) {\n    const action = yield sagaEffects.take(\n      swEventChannel,\n      (action: SDKActions) => action.type === 'calling.call.collect'\n    )\n\n    const shouldStop = yield sagaEffects.fork(worker, action)\n\n    if (shouldStop.result()) break\n  }\n\n  getLogger().trace('voiceCallCollectWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  sagaEffects,\n  SDKActions,\n  SDKWorker,\n  VoiceCallTapAction,\n} from '@signalwire/core'\nimport type { Client } from '../../client/index'\nimport { CallTapListeners } from '../../types'\nimport type { Call } from '../Call'\nimport { CallTap } from '../CallTap'\n\ninterface VoiceCallTapWorkerInitialState {\n  controlId: string\n  listeners?: CallTapListeners\n}\n\nexport const voiceCallTapWorker: SDKWorker<Client> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('voiceCallTapWorker started')\n  const {\n    channels: { swEventChannel },\n    instanceMap: { get, set, remove },\n    initialState,\n  } = options\n\n  const { controlId, listeners } =\n    initialState as VoiceCallTapWorkerInitialState\n\n  function* worker(action: VoiceCallTapAction) {\n    const { payload } = action\n\n    if (payload.control_id !== controlId) return\n\n    const callInstance = get(payload.call_id) as Call\n    if (!callInstance) {\n      throw new Error('Missing call instance for tap')\n    }\n\n    let tapInstance = get<CallTap>(payload.control_id)\n    if (!tapInstance) {\n      tapInstance = new CallTap({\n        call: callInstance,\n        payload,\n        listeners,\n      })\n    } else {\n      tapInstance.setPayload(payload)\n    }\n    set(payload.control_id, tapInstance)\n\n    switch (payload.state) {\n      case 'tapping':\n        callInstance.emit('tap.started', tapInstance)\n        tapInstance.emit('tap.started', tapInstance)\n        return false\n      case 'finished':\n        callInstance.emit('tap.ended', tapInstance)\n        tapInstance.emit('tap.ended', tapInstance)\n        remove<CallTap>(payload.control_id)\n        return true\n      default:\n        getLogger().warn(`Unknown tap state: \"${payload.state}\"`)\n        return false\n    }\n  }\n\n  while (true) {\n    const action = yield sagaEffects.take(\n      swEventChannel,\n      (action: SDKActions) => action.type === 'calling.call.tap'\n    )\n\n    const shouldStop = yield sagaEffects.fork(worker, action)\n\n    if (shouldStop.result()) break\n  }\n\n  getLogger().trace('voiceCallTapWorker ended')\n}\n", "import {\n  getLogger,\n  sagaEffects,\n  SagaIterator,\n  SDKActions,\n  SDKWorker,\n} from '@signalwire/core'\nimport type { Client } from '../../client/index'\nimport { Voice } from '../Voice'\nimport { handleCallConnectEvents, handleCallStateEvents } from './handlers'\n\ninterface VoiceCallConnectWorkerInitialState {\n  voice: Voice\n  tag: string\n}\n\nexport const voiceCallConnectWorker: SDKWorker<Client> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('voiceCallConnectWorker started')\n  const {\n    channels: { swEventChannel },\n    instanceMap,\n    initialState,\n  } = options\n\n  const { voice, tag } = initialState as VoiceCallConnectWorkerInitialState\n\n  const isCallConnectEvent = (action: SDKActions) =>\n    action.type === 'calling.call.connect'\n\n  const isCallStateEvent = (action: SDKActions) =>\n    action.type === 'calling.call.state' &&\n    action.payload.direction === 'outbound' &&\n    action.payload.tag === tag\n\n  function* callConnectWatcher(): SagaIterator {\n    while (true) {\n      const action = yield sagaEffects.take(swEventChannel, isCallConnectEvent)\n\n      const shouldStop = handleCallConnectEvents({\n        payload: action.payload,\n        instanceMap,\n        voice,\n      })\n\n      if (shouldStop) break\n    }\n  }\n\n  function* callStateWatcher(): SagaIterator {\n    while (true) {\n      const action = yield sagaEffects.take(swEventChannel, isCallStateEvent)\n\n      const shouldStop = handleCallStateEvents({\n        payload: action.payload,\n        voice,\n        instanceMap,\n      })\n\n      if (shouldStop) break\n    }\n  }\n\n  yield sagaEffects.fork(callConnectWatcher)\n  yield sagaEffects.fork(callStateWatcher)\n\n  getLogger().trace('voiceCallConnectWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  SDKWorker,\n  sagaEffects,\n  SDKActions,\n} from '@signalwire/core'\nimport type { Client } from '../../client/index'\nimport { RealTimeCallListeners } from '../../types'\nimport { Voice } from '../Voice'\nimport { handleCallDialEvents, handleCallStateEvents } from './handlers'\n\ninterface VoiceCallDialWorkerInitialState {\n  tag: string\n  voice: Voice\n  listeners?: RealTimeCallListeners\n}\n\nexport const voiceCallDialWorker: SDKWorker<Client> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('voiceCallDialWorker started')\n  const {\n    instanceMap,\n    channels: { swEventChannel },\n    initialState,\n  } = options\n\n  const { tag, voice, listeners } =\n    initialState as VoiceCallDialWorkerInitialState\n\n  const isCallDialEvent = (action: SDKActions) => {\n    return action.type === 'calling.call.dial' && action.payload.tag === tag\n  }\n\n  const isCallStateEvent = (action: SDKActions) => {\n    return (\n      action.type === 'calling.call.state' &&\n      action.payload.direction === 'outbound' &&\n      action.payload.tag === tag\n    )\n  }\n\n  function* callDialWatcher(): SagaIterator {\n    while (true) {\n      const action = yield sagaEffects.take(swEventChannel, isCallDialEvent)\n\n      const shouldStop = handleCallDialEvents({\n        payload: action.payload,\n        instanceMap,\n        voice,\n      })\n\n      if (shouldStop) break\n    }\n  }\n\n  function* callStateWatcher(): SagaIterator {\n    while (true) {\n      const action = yield sagaEffects.take(swEventChannel, isCallStateEvent)\n\n      const shouldStop = handleCallStateEvents({\n        payload: action.payload,\n        voice,\n        instanceMap,\n        listeners,\n      })\n\n      if (shouldStop) break\n    }\n  }\n\n  yield sagaEffects.fork(callDialWatcher)\n  yield sagaEffects.fork(callStateWatcher)\n\n  getLogger().trace('voiceCallDialWorker ended')\n}\n", "import {\n  getLogger,\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  VoiceCallSendDigitsAction,\n} from '@signalwire/core'\nimport type { Call } from '../Call'\nimport type { Client } from '../../client/index'\nimport { SDKActions } from 'packages/core/dist/core/src'\n\ninterface VoiceCallSendDigitsWorkerInitialState {\n  controlId: string\n}\n\nexport const voiceCallSendDigitsWorker: SDKWorker<Client> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('voiceCallSendDigitsWorker started')\n  const {\n    channels: { swEventChannel },\n    instanceMap: { get },\n    initialState,\n  } = options\n\n  const { controlId } = initialState as VoiceCallSendDigitsWorkerInitialState\n\n  function* worker(action: VoiceCallSendDigitsAction) {\n    const { payload } = action\n\n    if (payload.control_id !== controlId) return\n\n    const callInstance = get<Call>(payload.call_id)\n    if (!callInstance) {\n      throw new Error('Missing call instance for send digits')\n    }\n\n    switch (payload.state) {\n      case 'finished':\n        // @ts-expect-error\n        callInstance.emit('send_digits.finished', callInstance)\n        return true\n      default: {\n        const error = new Error(\n          `[voiceCallSendDigitsWorker] unhandled state: '${payload.state}'`\n        )\n        // @ts-expect-error\n        callInstance.emit('send_digits.failed', error)\n        return false\n      }\n    }\n  }\n\n  while (true) {\n    const action = yield sagaEffects.take(\n      swEventChannel,\n      (action: SDKActions) => action.type === 'calling.call.send_digits'\n    )\n\n    const shouldStop = yield sagaEffects.fork(worker, action)\n\n    if (shouldStop.result()) break\n  }\n\n  getLogger().trace('voiceCallSendDigitsWorker ended')\n}\n", "import {\n  getLogger,\n  sagaEffects,\n  SagaIterator,\n  SDKActions,\n  SDKWorker,\n  VoiceCallDetectAction,\n} from '@signalwire/core'\nimport type { Client } from '../../client/index'\nimport { CallDetectListeners } from '../../types'\nimport type { Call } from '../Call'\nimport { CallDetect } from '../CallDetect'\n\ninterface VoiceCallDetectWorkerInitialState {\n  controlId: string\n  listeners?: CallDetectListeners\n}\n\nexport const voiceCallDetectWorker: SDKWorker<Client> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('voiceCallDetectWorker started')\n  const {\n    channels: { swEventChannel },\n    instanceMap: { get, set, remove },\n    initialState,\n  } = options\n\n  const { controlId, listeners } =\n    initialState as VoiceCallDetectWorkerInitialState\n\n  function* worker(action: VoiceCallDetectAction) {\n    const { payload } = action\n\n    if (payload.control_id !== controlId) return\n\n    const callInstance = get<Call>(payload.call_id)\n    if (!callInstance) {\n      throw new Error('Missing call instance for collect')\n    }\n\n    let detectInstance = get<CallDetect>(payload.control_id)\n    if (!detectInstance) {\n      detectInstance = new CallDetect({\n        call: callInstance,\n        payload,\n        listeners,\n      })\n    } else {\n      detectInstance.setPayload(payload)\n    }\n    set<CallDetect>(payload.control_id, detectInstance)\n\n    const { detect } = payload\n    if (!detect) return\n\n    const { type, params } = detect\n    const { event } = params\n\n    switch (event) {\n      case 'finished':\n      case 'error': {\n        callInstance.emit('detect.ended', detectInstance)\n        detectInstance.emit('detect.ended', detectInstance)\n\n        remove<CallDetect>(payload.control_id)\n        return true\n      }\n      default:\n        callInstance.emit('detect.updated', detectInstance)\n        detectInstance.emit('detect.updated', detectInstance)\n        break\n    }\n\n    switch (type) {\n      case 'machine':\n        if (params.beep && detectInstance.waitForBeep) {\n          callInstance.emit('detect.ended', detectInstance)\n          detectInstance.emit('detect.ended', detectInstance)\n        }\n        break\n      case 'digit':\n      case 'fax':\n        break\n      default:\n        getLogger().warn(`Unknown detect type: \"${type}\"`)\n        break\n    }\n\n    return false\n  }\n\n  while (true) {\n    const action = yield sagaEffects.take(\n      swEventChannel,\n      (action: SDKActions) => action.type === 'calling.call.detect'\n    )\n\n    const shouldStop = yield sagaEffects.fork(worker, action)\n\n    if (shouldStop.result()) break\n  }\n\n  getLogger().trace('voiceCallDetectWorker ended')\n}\n", "import {\n  RoomSessionRecording,\n  RoomSessionPlayback,\n  validateEventsToSubscribe,\n  EventEmitter,\n} from '@signalwire/core'\nimport {\n  RealTimeRoomEvents,\n  RealTimeVideoEvents,\n  RealTimeVideoEventsHandlerMapping,\n  RealTimeRoomEventsHandlerMapping,\n  RealTimeVideoListenersEventsMapping,\n  RealTimeVideoListeners,\n} from '../types/video'\nimport { RoomSession, RoomSessionAPI } from './RoomSession'\nimport type {\n  RoomSessionMember,\n  RoomSessionMemberUpdated,\n} from './RoomSessionMember'\nimport { videoCallingWorker } from './workers'\nimport { SWClient } from '../SWClient'\nimport { BaseVideo } from './BaseVideo'\n\nexport class Video extends BaseVideo<\n  RealTimeVideoListeners,\n  RealTimeVideoEvents\n> {\n  protected _eventChannel = 'video.rooms'\n  protected _eventMap: RealTimeVideoListenersEventsMapping = {\n    onRoomStarted: 'room.started',\n    onRoomEnded: 'room.ended',\n  }\n\n  constructor(options: SWClient) {\n    super(options)\n\n    this._client.runWorker('videoCallingWorker', {\n      worker: videoCallingWorker,\n      initialState: {\n        video: this,\n      },\n    })\n  }\n\n  protected override getSubscriptions() {\n    const eventNamesWithPrefix = this.eventNames().map(\n      (event) => `video.${String(event)}`\n    ) as EventEmitter.EventNames<RealTimeVideoEvents>[]\n    return validateEventsToSubscribe(eventNamesWithPrefix)\n  }\n\n  async getRoomSessions() {\n    return new Promise<{ roomSessions: RoomSession[] }>(\n      async (resolve, reject) => {\n        try {\n          const { rooms = [] }: any = await this._client.execute({\n            method: 'video.rooms.get',\n            params: {},\n          })\n\n          const roomInstances: RoomSession[] = []\n          rooms.forEach((room: any) => {\n            let roomInstance = this._client.instanceMap.get<RoomSession>(\n              room.id\n            )\n            if (!roomInstance) {\n              roomInstance = new RoomSessionAPI({\n                video: this,\n                payload: { room_session: room },\n              })\n            } else {\n              roomInstance.setPayload({\n                room_session: room,\n              })\n            }\n            roomInstances.push(roomInstance)\n            this._client.instanceMap.set<RoomSession>(\n              roomInstance.id,\n              roomInstance\n            )\n          })\n\n          resolve({ roomSessions: roomInstances })\n        } catch (error) {\n          console.error('Error listing room sessions', error)\n          reject(error)\n        }\n      }\n    )\n  }\n\n  async getRoomSessionById(id: string) {\n    return new Promise<{ roomSession: RoomSession }>(\n      async (resolve, reject) => {\n        try {\n          const { room }: any = await this._client.execute({\n            method: 'video.room.get',\n            params: {\n              room_session_id: id,\n            },\n          })\n\n          let roomInstance = this._client.instanceMap.get<RoomSession>(room.id)\n          if (!roomInstance) {\n            roomInstance = new RoomSessionAPI({\n              video: this,\n              payload: { room_session: room },\n            })\n          } else {\n            roomInstance.setPayload({\n              room_session: room,\n            })\n          }\n          this._client.instanceMap.set<RoomSession>(\n            roomInstance.id,\n            roomInstance\n          )\n\n          resolve({ roomSession: roomInstance })\n        } catch (error) {\n          console.error('Error retrieving the room session', error)\n          reject(error)\n        }\n      }\n    )\n  }\n}\n\nexport type {\n  RealTimeRoomEvents,\n  RealTimeRoomEventsHandlerMapping,\n  RealTimeVideoEvents,\n  RealTimeVideoEventsHandlerMapping,\n  RoomSession,\n  RoomSessionMember,\n  RoomSessionMemberUpdated,\n  RoomSessionPlayback,\n  RoomSessionRecording,\n}\n\nexport type {\n  ClientEvents,\n  EmitterContract,\n  EntityUpdated,\n  GlobalVideoEvents,\n  InternalVideoMemberEntity,\n  LayoutChanged,\n  MEMBER_UPDATED_EVENTS,\n  MemberCommandParams,\n  MemberCommandWithValueParams,\n  MemberCommandWithVolumeParams,\n  MemberJoined,\n  MemberLeft,\n  MemberListUpdated,\n  MemberTalking,\n  MemberTalkingEnded,\n  MemberTalkingEventNames,\n  MemberTalkingStart,\n  MemberTalkingStarted,\n  MemberTalkingStop,\n  MemberUpdated,\n  MemberUpdatedEventNames,\n  PlaybackEnded,\n  PlaybackStarted,\n  PlaybackUpdated,\n  RecordingEnded,\n  RecordingStarted,\n  RecordingUpdated,\n  RoomEnded,\n  RoomStarted,\n  RoomSubscribed,\n  RoomUpdated,\n  SipCodec,\n  VideoLayoutEventNames,\n  VideoMemberContract,\n  VideoMemberEntity,\n  VideoMemberEventNames,\n  VideoMemberType,\n  VideoPlaybackEventNames,\n  VideoPosition,\n  VideoRecordingEventNames,\n} from '@signalwire/core'\n", "import {\n  extendComponent,\n  VideoRoomSessionMethods,\n  EventEmitter,\n  VideoRoomEventParams,\n  Optional,\n  validateEventsToSubscribe,\n  VideoMemberEntity,\n} from '@signalwire/core'\nimport {\n  RealTimeRoomEvents,\n  RealTimeRoomListeners,\n  RealtimeRoomListenersEventsMapping,\n  VideoRoomSessionContract,\n} from '../types'\nimport {\n  RoomSessionMember,\n  RoomSessionMemberAPI,\n  RoomSessionMemberEventParams,\n} from './RoomSessionMember'\nimport { RoomMethods } from './methods'\nimport { BaseVideo } from './BaseVideo'\nimport { Video } from './Video'\n\nexport interface RoomSessionFullState extends Omit<RoomSession, 'members'> {\n  /** List of members that are part of this room session */\n  members?: RoomSessionMember[]\n}\n\nexport interface RoomSession\n  extends VideoRoomSessionContract,\n    BaseVideo<RealTimeRoomListeners, RealTimeRoomEvents> {\n  /**\n   * Returns a list of members currently in the room.\n   *\n   * @example\n   * ```typescript\n   * await room.getMembers()\n   * ```\n   */\n  getMembers(): Promise<{ members: RoomSessionMember[] }>\n  /** @internal */\n  setPayload(payload: Optional<VideoRoomEventParams, 'room'>): void\n}\n\ntype RoomSessionPayload = Optional<VideoRoomEventParams, 'room'>\n\nexport interface RoomSessionOptions {\n  video: Video\n  payload: RoomSessionPayload\n}\n\nexport class RoomSession extends BaseVideo<\n  RealTimeRoomListeners,\n  RealTimeRoomEvents\n> {\n  private _payload: RoomSessionPayload\n  protected _eventMap: RealtimeRoomListenersEventsMapping = {\n    onRoomSubscribed: 'room.subscribed',\n    onRoomStarted: 'room.started',\n    onRoomUpdated: 'room.updated',\n    onRoomEnded: 'room.ended',\n    onRoomAudienceCount: 'room.audienceCount',\n    onLayoutChanged: 'layout.changed',\n    onMemberJoined: 'member.joined',\n    onMemberUpdated: 'member.updated',\n    onMemberLeft: 'member.left',\n    onMemberListUpdated: 'memberList.updated',\n    onMemberTalking: 'member.talking',\n    onMemberTalkingStarted: 'member.talking.started',\n    onMemberTalkingEnded: 'member.talking.ended',\n    onMemberDeaf: 'member.updated.deaf',\n    onMemberVisible: 'member.updated.visible',\n    onMemberAudioMuted: 'member.updated.audioMuted',\n    onMemberVideoMuted: 'member.updated.videoMuted',\n    onMemberInputVolume: 'member.updated.inputVolume',\n    onMemberOutputVolume: 'member.updated.outputVolume',\n    onMemberInputSensitivity: 'member.updated.inputSensitivity',\n    onPlaybackStarted: 'playback.started',\n    onPlaybackUpdated: 'playback.updated',\n    onPlaybackEnded: 'playback.ended',\n    onRecordingStarted: 'recording.started',\n    onRecordingUpdated: 'recording.updated',\n    onRecordingEnded: 'recording.ended',\n    onStreamStarted: 'stream.started',\n    onStreamEnded: 'stream.ended',\n  }\n\n  constructor(options: RoomSessionOptions) {\n    super(options.video._sw)\n\n    this._payload = options.payload\n  }\n\n  get id() {\n    return this._payload.room_session.id\n  }\n\n  get roomSessionId() {\n    return this._payload.room_session.id\n  }\n\n  get roomId() {\n    return this._payload.room_session.room_id\n  }\n\n  get name() {\n    return this._payload.room_session.name\n  }\n\n  get displayName() {\n    return this._payload.room_session.display_name\n  }\n\n  get hideVideoMuted() {\n    return this._payload.room_session.hide_video_muted\n  }\n\n  get layoutName() {\n    return this._payload.room_session.layout_name\n  }\n\n  get meta() {\n    return this._payload.room_session.meta\n  }\n\n  get previewUrl() {\n    return this._payload.room_session.preview_url\n  }\n\n  get recording() {\n    return this._payload.room_session.recording\n  }\n\n  get streaming() {\n    return this._payload.room_session.streaming\n  }\n\n  get locked() {\n    return this._payload.room_session.locked\n  }\n\n  get eventChannel() {\n    return this._payload.room_session.event_channel\n  }\n\n  get prioritizeHandraise() {\n    return this._payload.room_session.prioritize_handraise\n  }\n\n  get updated() {\n    // TODO: Fix type issue\n    return this._payload.room_session\n      .updated as VideoRoomSessionContract['updated']\n  }\n\n  /** @internal */\n  protected override getSubscriptions() {\n    const eventNamesWithPrefix = this.eventNames().map(\n      (event) => `video.${String(event)}`\n    ) as EventEmitter.EventNames<RealTimeRoomEvents>[]\n    return validateEventsToSubscribe(eventNamesWithPrefix)\n  }\n\n  /** @internal */\n  setPayload(payload: Optional<VideoRoomEventParams, 'room'>) {\n    this._payload = payload\n  }\n\n  getMembers() {\n    return new Promise<{\n      members: VideoMemberEntity[]\n    }>(async (resolve, reject) => {\n      try {\n        const { members } = await this._client.execute<\n          void,\n          { members: RoomSessionMemberEventParams['member'][] }\n        >({\n          method: 'video.members.get',\n          params: {\n            room_session_id: this.roomSessionId,\n          },\n        })\n\n        const memberInstances: RoomSessionMember[] = []\n        members.forEach((member) => {\n          let memberInstance = this._client.instanceMap.get<RoomSessionMember>(\n            member.id\n          )\n          if (!memberInstance) {\n            memberInstance = new RoomSessionMemberAPI({\n              roomSession: this,\n              payload: {\n                room_id: this.roomId,\n                room_session_id: this.roomSessionId,\n                member,\n              },\n            })\n          } else {\n            memberInstance.setPayload({\n              member,\n            } as RoomSessionMemberEventParams)\n          }\n          memberInstances.push(memberInstance)\n          this._client.instanceMap.set<RoomSessionMember>(\n            memberInstance.id,\n            memberInstance\n          )\n        })\n\n        resolve({ members: memberInstances })\n      } catch (error) {\n        reject(error)\n      }\n    })\n  }\n}\n\nexport const RoomSessionAPI = extendComponent<\n  RoomSession,\n  Omit<VideoRoomSessionMethods, 'getMembers'>\n>(RoomSession, {\n  videoMute: RoomMethods.videoMuteMember,\n  videoUnmute: RoomMethods.videoUnmuteMember,\n  audioMute: RoomMethods.audioMuteMember,\n  audioUnmute: RoomMethods.audioUnmuteMember,\n  deaf: RoomMethods.deafMember,\n  undeaf: RoomMethods.undeafMember,\n  setInputVolume: RoomMethods.setInputVolumeMember,\n  setOutputVolume: RoomMethods.setOutputVolumeMember,\n  setMicrophoneVolume: RoomMethods.setInputVolumeMember,\n  setSpeakerVolume: RoomMethods.setOutputVolumeMember,\n  setInputSensitivity: RoomMethods.setInputSensitivityMember,\n  removeMember: RoomMethods.removeMember,\n  removeAllMembers: RoomMethods.removeAllMembers,\n  setHideVideoMuted: RoomMethods.setHideVideoMuted,\n  getLayouts: RoomMethods.getLayouts,\n  setLayout: RoomMethods.setLayout,\n  setPositions: RoomMethods.setPositions,\n  setMemberPosition: RoomMethods.setMemberPosition,\n  getRecordings: RoomMethods.getRecordings,\n  startRecording: RoomMethods.startRecording,\n  getPlaybacks: RoomMethods.getPlaybacks,\n  play: RoomMethods.play,\n  getMeta: RoomMethods.getMeta,\n  setMeta: RoomMethods.setMeta,\n  updateMeta: RoomMethods.updateMeta,\n  deleteMeta: RoomMethods.deleteMeta,\n  getMemberMeta: RoomMethods.getMemberMeta,\n  setMemberMeta: RoomMethods.setMemberMeta,\n  updateMemberMeta: RoomMethods.updateMemberMeta,\n  deleteMemberMeta: RoomMethods.deleteMemberMeta,\n  promote: RoomMethods.promote,\n  demote: RoomMethods.demote,\n  getStreams: RoomMethods.getStreams,\n  startStream: RoomMethods.startStream,\n  lock: RoomMethods.lock,\n  unlock: RoomMethods.unlock,\n  setRaisedHand: RoomMethods.setRaisedHand,\n  setPrioritizeHandraise: RoomMethods.setPrioritizeHandraise,\n})\n", "import {\n  extendComponent,\n  VideoMemberContract,\n  VideoMemberMethods,\n  EntityUpdated,\n  VideoMemberJoinedEventParams,\n  VideoMemberLeftEventParams,\n  VideoMemberUpdatedEventParams,\n  VideoMemberTalkingEventParams,\n} from '@signalwire/core'\nimport { RoomSession } from '../RoomSession'\nimport { RoomMethods } from '../methods'\nimport type { Client } from '../../client/Client'\n\n/**\n * Represents a member of a room session. You receive instances of this type by\n * listening to room events, for example on a {@link RoomSession} object.\n *\n * > \u2139\uFE0F State of RoomSessionMember objects\n * >\n * > The state of RoomSessionMember objects, for example `member.visible`, is\n * > immutable. When you receive instances of RoomSessionMember from event\n * > listeners, the state of the member always refers to that specific point in\n * > time and remains fixed for the whole lifetime of the object.\n */\nexport interface RoomSessionMember extends VideoMemberContract {\n  setPayload(payload: RoomSessionMemberEventParams): void\n}\nexport type RoomSessionMemberUpdated = EntityUpdated<RoomSessionMember>\n\nexport type RoomSessionMemberEventParams =\n  | (\n      | VideoMemberJoinedEventParams\n      | VideoMemberLeftEventParams\n      | VideoMemberUpdatedEventParams\n    ) &\n      VideoMemberTalkingEventParams\n\nexport interface RoomSessionOptions {\n  roomSession: RoomSession\n  payload: RoomSessionMemberEventParams\n}\n\nexport class RoomSessionMember {\n  private _client: Client\n  private _payload: RoomSessionMemberEventParams\n\n  constructor(options: RoomSessionOptions) {\n    this._client = options.roomSession._sw.client\n    this._payload = options.payload\n  }\n\n  get id() {\n    return this._payload.member.id\n  }\n\n  get memberId() {\n    return this._payload.member.id\n  }\n\n  get roomSessionId() {\n    return this._payload.member.room_session_id\n  }\n\n  get roomId() {\n    return this._payload.member.room_id\n  }\n\n  get parentId() {\n    return this._payload.member.parent_id\n  }\n\n  get name() {\n    return this._payload.member.name\n  }\n\n  get type() {\n    return this._payload.member.type\n  }\n\n  get meta() {\n    return this._payload.member.meta\n  }\n\n  get requestedPosition() {\n    return this._payload.member.requested_position\n  }\n\n  get currentPosition() {\n    return this._payload.member.current_position\n  }\n\n  get visible() {\n    return this._payload.member.visible\n  }\n\n  get audioMuted() {\n    return this._payload.member.audio_muted\n  }\n\n  get videoMuted() {\n    return this._payload.member.video_muted\n  }\n\n  get deaf() {\n    return this._payload.member.deaf\n  }\n\n  get inputVolume() {\n    return this._payload.member.input_volume\n  }\n\n  get outputVolume() {\n    return this._payload.member.output_volume\n  }\n\n  get inputSensitivity() {\n    return this._payload.member.input_sensitivity\n  }\n\n  get talking() {\n    return this._payload.member.talking\n  }\n\n  get handraised() {\n    return this._payload.member.handraised\n  }\n\n  /** @internal */\n  setPayload(payload: RoomSessionMemberEventParams) {\n    // Reshape the payload since the `video.member.talking` event does not return all the parameters of a member\n    const newPayload = {\n      ...payload,\n      member: {\n        ...this._payload.member,\n        ...payload.member,\n      },\n    }\n    this._payload = newPayload\n  }\n\n  async remove() {\n    await this._client.execute({\n      method: 'video.member.remove',\n      params: {\n        room_session_id: this.roomSessionId,\n        member_id: this.memberId,\n      },\n    })\n  }\n}\n\nexport const RoomSessionMemberAPI = extendComponent<\n  RoomSessionMember,\n  // `remove` is defined by `RoomSessionMember`\n  Omit<VideoMemberMethods, 'remove'>\n>(RoomSessionMember, {\n  audioMute: RoomMethods.audioMuteMember,\n  audioUnmute: RoomMethods.audioUnmuteMember,\n  videoMute: RoomMethods.videoMuteMember,\n  videoUnmute: RoomMethods.videoUnmuteMember,\n  setDeaf: RoomMethods.setDeaf,\n  setMicrophoneVolume: RoomMethods.setInputVolumeMember,\n  setInputVolume: RoomMethods.setInputVolumeMember,\n  setSpeakerVolume: RoomMethods.setOutputVolumeMember,\n  setOutputVolume: RoomMethods.setOutputVolumeMember,\n  setInputSensitivity: RoomMethods.setInputSensitivityMember,\n  setRaisedHand: RoomMethods.setRaisedHand,\n})\n", "/**\n * Once we have new interface for Browser SDK;\n * methods.ts in core should be removed\n * methods.ts in realtime-api should be moved to core\n */\n\nimport {\n  type VideoMemberEntity,\n  type MemberCommandParams,\n  type VideoPosition,\n  type ExecuteExtendedOptions,\n  type RoomMethod,\n  type BaseRPCResult,\n  type MediaAllowed,\n  type VideoMeta,\n} from '@signalwire/core'\nimport {\n  RealTimeRoomPlaybackListeners,\n  RealTimeRoomRecordingListeners,\n  RealTimeRoomStreamListeners,\n} from '../../types'\nimport {\n  RoomSessionPlayback,\n  decoratePlaybackPromise,\n} from '../RoomSessionPlayback'\nimport {\n  RoomSessionRecording,\n  decorateRecordingPromise,\n} from '../RoomSessionRecording'\nimport { RoomSessionStream, decorateStreamPromise } from '../RoomSessionStream'\nimport { BaseRoomInterface } from '.'\n\ntype RoomMethodParams = Record<string, unknown>\n\ninterface RoomMethodPropertyDescriptor<OutputType, ParamsType>\n  extends PropertyDescriptor {\n  value: (params: ParamsType) => Promise<OutputType>\n}\n\ntype RoomMethodDescriptor<\n  OutputType = unknown,\n  ParamsType = RoomMethodParams\n> = RoomMethodPropertyDescriptor<OutputType, ParamsType> &\n  // TODO: Replace string with a tighter type\n  ThisType<BaseRoomInterface>\n\n/**\n * Transform for returning `undefined` for `execute`s that were\n * successully resolved. If the `execute` failed for some reason, then\n * the promise will be rejected and this transform will never be\n * executed.\n */\nconst baseCodeTransform = () => {}\n\nconst createRoomMethod = <\n  InputType,\n  OutputType = InputType,\n  ParamsType extends RoomMethodParams = RoomMethodParams\n>(\n  method: RoomMethod,\n  options: ExecuteExtendedOptions<InputType, OutputType, ParamsType> = {}\n): RoomMethodDescriptor<OutputType, ParamsType> => ({\n  value: function (params = {} as ParamsType): Promise<OutputType> {\n    return this._client.execute(\n      {\n        method,\n        params: {\n          room_session_id: this.roomSessionId,\n          ...params,\n        },\n      },\n      options\n    )\n  },\n})\n\n/**\n * Type the params for each room member method that uses the provided\n * memberId or fallback to the instance memberId. Additional params\n * can be passed as `value` or `volume`.\n */\ninterface RoomMemberMethodParams extends Record<string, unknown> {\n  memberId?: string\n}\n\nconst createRoomMemberMethod = <\n  InputType,\n  OutputType,\n  ParamsType extends RoomMemberMethodParams = RoomMemberMethodParams\n>(\n  method: RoomMethod,\n  options: ExecuteExtendedOptions<InputType, OutputType, ParamsType> = {}\n): RoomMethodDescriptor<OutputType, ParamsType> => ({\n  value: function ({ memberId, ...rest } = {} as ParamsType) {\n    return this._client.execute(\n      {\n        method,\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: memberId || this.memberId,\n          ...rest,\n        },\n      },\n      options\n    )\n  },\n})\n\n/**\n * Room Methods\n */\nexport const getLayouts = createRoomMethod<{ layouts: string[] }>(\n  'video.list_available_layouts',\n  {\n    transformResolve: (payload) => ({ layouts: payload.layouts }),\n  }\n)\nexport const getMembers = createRoomMethod<{ members: VideoMemberEntity[] }>(\n  'video.members.get',\n  {\n    transformResolve: (payload) => ({ members: payload.members }),\n  }\n)\nexport interface SetLayoutParams {\n  name: string\n  positions?: Record<string, VideoPosition>\n}\nexport const setLayout = createRoomMethod<BaseRPCResult, void>(\n  'video.set_layout',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport interface SetPositionsParams {\n  positions: Record<string, VideoPosition>\n}\nexport const setPositions = createRoomMethod<BaseRPCResult, void>(\n  'video.set_position',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const hideVideoMuted = createRoomMethod<BaseRPCResult, void>(\n  'video.hide_video_muted',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const showVideoMuted = createRoomMethod<BaseRPCResult, void>(\n  'video.show_video_muted',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const lock = createRoomMethod<BaseRPCResult, void>('video.lock', {\n  transformResolve: baseCodeTransform,\n})\nexport const unlock = createRoomMethod<BaseRPCResult, void>('video.unlock', {\n  transformResolve: baseCodeTransform,\n})\n\nexport const setHideVideoMuted: RoomMethodDescriptor<void, boolean> = {\n  value: function (value) {\n    return this._client.execute(\n      {\n        method: value ? 'video.hide_video_muted' : 'video.show_video_muted',\n        params: {\n          room_session_id: this.roomSessionId,\n        },\n      },\n      {\n        transformResolve: baseCodeTransform,\n      }\n    )\n  },\n}\n\nexport interface GetRecordingsOutput {\n  recordings: RoomSessionRecording[]\n}\n\nexport const getRecordings: RoomMethodDescriptor<GetRecordingsOutput> = {\n  value: function () {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const { recordings } = await this._client.execute<void, any>({\n          method: 'video.recording.list',\n          params: {\n            room_session_id: this.roomSessionId,\n          },\n        })\n\n        const recordingInstances: RoomSessionRecording[] = []\n        recordings.forEach((recording: any) => {\n          let recordingInstance =\n            this._client.instanceMap.get<RoomSessionRecording>(recording.id)\n          if (!recordingInstance) {\n            recordingInstance = new RoomSessionRecording({\n              payload: {\n                room_id: this.roomId,\n                room_session_id: this.roomSessionId,\n                recording,\n              },\n              roomSession: this as any,\n            })\n          } else {\n            recordingInstance.setPayload({\n              room_id: this.roomId,\n              room_session_id: this.roomSessionId,\n              recording,\n            })\n          }\n          recordingInstances.push(recordingInstance)\n          this._client.instanceMap.set<RoomSessionRecording>(\n            recordingInstance.id,\n            recordingInstance\n          )\n        })\n\n        resolve({ recordings: recordingInstances })\n      } catch (error) {\n        reject(error)\n      }\n    })\n  },\n}\n\nexport type StartRecordingParams = {\n  listen?: RealTimeRoomRecordingListeners\n}\nexport const startRecording: RoomMethodDescriptor<any> = {\n  value: function ({ listen }: StartRecordingParams = {}) {\n    const promise = new Promise<RoomSessionRecording>(\n      async (resolve, reject) => {\n        const resolveHandler = (recording: RoomSessionRecording) => {\n          this.off('recording.ended', rejectHandler)\n          resolve(recording)\n        }\n\n        const rejectHandler = (recording: RoomSessionRecording) => {\n          this.off('recording.started', resolveHandler)\n          reject(recording)\n        }\n\n        // Subsribe to listeners\n        if (listen) {\n          mapActionListenersToRoomListeners.call(this, {\n            listeners: listen,\n            action: 'recording',\n          })\n        }\n        this.once('recording.started', resolveHandler)\n        this.once('recording.ended', rejectHandler)\n\n        this._client\n          .execute<void, any>({\n            method: 'video.recording.start',\n            params: {\n              room_session_id: this.roomSessionId,\n            },\n          })\n          .then(() => {\n            // TODO: handle then?\n          })\n          .catch((e) => {\n            this.off('recording.started', resolveHandler)\n            this.off('recording.ended', rejectHandler)\n            reject(e)\n          })\n      }\n    )\n\n    return decorateRecordingPromise.call(this as any, promise)\n  },\n}\n\nexport interface GetPlaybacksOutput {\n  playbacks: RoomSessionPlayback[]\n}\n\nexport const getPlaybacks: RoomMethodDescriptor<GetPlaybacksOutput> = {\n  value: function () {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const { playbacks } = await this._client.execute<void, any>({\n          method: 'video.playback.list',\n          params: {\n            room_session_id: this.roomSessionId,\n          },\n        })\n\n        const playbackInstances: RoomSessionPlayback[] = []\n        playbacks.forEach((playback: any) => {\n          let playbackInstance =\n            this._client.instanceMap.get<RoomSessionPlayback>(playback.id)\n          if (!playbackInstance) {\n            playbackInstance = new RoomSessionPlayback({\n              payload: {\n                room_id: this.roomId,\n                room_session_id: this.roomSessionId,\n                playback,\n              },\n              roomSession: this as any,\n            })\n          } else {\n            playbackInstance.setPayload({\n              room_id: this.roomId,\n              room_session_id: this.roomSessionId,\n              playback,\n            })\n          }\n          playbackInstances.push(playbackInstance)\n          this._client.instanceMap.set<RoomSessionPlayback>(\n            playbackInstance.id,\n            playbackInstance\n          )\n        })\n\n        resolve({ playbacks: playbackInstances })\n      } catch (error) {\n        reject(error)\n      }\n    })\n  },\n}\n\nexport type PlayParams = {\n  url: string\n  volume?: number\n  positions?: Record<string, VideoPosition>\n  layout?: string\n  seekPosition?: number\n  /**\n   * @deprecated Use {@link seekPosition} instead.\n   * `currentTimecode` will be removed in v4.0.0\n   */\n  currentTimecode?: number\n  listen?: RealTimeRoomPlaybackListeners\n}\nexport const play: RoomMethodDescriptor<any, PlayParams> = {\n  value: function ({ seekPosition, currentTimecode, listen, ...params }) {\n    const promise = new Promise<RoomSessionPlayback>(\n      async (resolve, reject) => {\n        const seek_position = seekPosition || currentTimecode\n\n        const resolveHandler = (playback: RoomSessionPlayback) => {\n          this.off('playback.ended', rejectHandler)\n          resolve(playback)\n        }\n\n        const rejectHandler = (playback: RoomSessionPlayback) => {\n          this.off('playback.started', resolveHandler)\n          reject(playback)\n        }\n\n        // Subsribe to listeners\n        if (listen) {\n          mapActionListenersToRoomListeners.call(this, {\n            listeners: listen,\n            action: 'playback',\n          })\n        }\n\n        this.once('playback.started', resolveHandler)\n        this.once('playback.ended', rejectHandler)\n\n        this._client\n          .execute<void, any>({\n            method: 'video.playback.start',\n            params: {\n              room_session_id: this.roomSessionId,\n              seek_position,\n              ...params,\n            },\n          })\n          .then(() => {\n            // TODO: handle then?\n          })\n          .catch((e) => {\n            this.off('playback.started', resolveHandler)\n            this.off('playback.ended', rejectHandler)\n            reject(e)\n          })\n      }\n    )\n\n    return decoratePlaybackPromise.call(this as any, promise)\n  },\n}\n\nconst createRoomMetaMethod = <ParamsType extends RoomMethodParams>(\n  method: RoomMethod\n) => {\n  return createRoomMethod<BaseRPCResult, void, ParamsType>(method, {\n    transformResolve: baseCodeTransform,\n    transformParams: (params) => {\n      const { room_session_id, ...meta } = params\n      return { room_session_id, meta }\n    },\n  })\n}\n\ninterface GetMetaOutput {\n  meta: VideoMeta\n}\n\nexport const getMeta = createRoomMethod<GetMetaOutput>('video.get_meta', {\n  transformResolve: ({ meta }) => ({ meta }),\n})\n\nexport interface SetMetaParams extends Record<string, unknown> {}\nexport const setMeta = createRoomMetaMethod<SetMetaParams>('video.set_meta')\n\nexport interface UpdateMetaParams extends Record<string, unknown> {}\nexport const updateMeta =\n  createRoomMetaMethod<UpdateMetaParams>('video.update_meta')\n\nexport type DeleteMetaParams = string[]\nexport const deleteMeta: RoomMethodDescriptor<any, DeleteMetaParams> = {\n  value: function (params) {\n    return this._client.execute({\n      method: 'video.delete_meta',\n      params: {\n        room_session_id: this.roomSessionId,\n        keys: params,\n      },\n    })\n  },\n}\n\nexport interface GetStreamsOutput {\n  streams: RoomSessionStream[]\n}\n\nexport const getStreams: RoomMethodDescriptor<GetStreamsOutput> = {\n  value: function () {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const { streams } = await this._client.execute<void, any>({\n          method: 'video.stream.list',\n          params: {\n            room_session_id: this.roomSessionId,\n          },\n        })\n\n        const streamInstances: RoomSessionStream[] = []\n        streams.forEach((stream: any) => {\n          let streamInstance = this._client.instanceMap.get<RoomSessionStream>(\n            stream.id\n          )\n          if (!streamInstance) {\n            streamInstance = new RoomSessionStream({\n              payload: {\n                room_id: this.roomId,\n                room_session_id: this.roomSessionId,\n                stream,\n              },\n              roomSession: this as any,\n            })\n          } else {\n            streamInstance.setPayload({\n              room_id: this.roomId,\n              room_session_id: this.roomSessionId,\n              stream,\n            })\n          }\n          streamInstances.push(streamInstance)\n          this._client.instanceMap.set<RoomSessionStream>(\n            streamInstance.id,\n            streamInstance\n          )\n        })\n\n        resolve({ streams: streamInstances })\n      } catch (error) {\n        reject(error)\n      }\n    })\n  },\n}\n\nexport interface StartStreamParams {\n  url: string\n  listen?: RealTimeRoomStreamListeners\n}\nexport const startStream: RoomMethodDescriptor<any, StartStreamParams> = {\n  value: function ({ listen, ...params }) {\n    const promise = new Promise<RoomSessionStream>(async (resolve, reject) => {\n      const resolveHandler = (stream: RoomSessionStream) => {\n        this.off('stream.ended', rejectHandler)\n        resolve(stream)\n      }\n\n      const rejectHandler = (stream: RoomSessionStream) => {\n        this.off('stream.started', resolveHandler)\n        reject(stream)\n      }\n\n      // Subsribe to listeners\n      if (listen) {\n        mapActionListenersToRoomListeners.call(this, {\n          listeners: listen,\n          action: 'stream',\n        })\n      }\n\n      this.once('stream.started', resolveHandler)\n      this.once('stream.ended', rejectHandler)\n\n      this._client\n        .execute<StartStreamParams, any>({\n          method: 'video.stream.start',\n          params: {\n            room_session_id: this.roomSessionId,\n            ...params,\n          },\n        })\n        .then(() => {\n          // TODO: handle then?\n        })\n        .catch((e) => {\n          this.off('stream.started', resolveHandler)\n          this.off('stream.ended', rejectHandler)\n          reject(e)\n        })\n    })\n\n    return decorateStreamPromise.call(this as any, promise)\n  },\n}\n\nexport const setPrioritizeHandraise: RoomMethodDescriptor<any, boolean> = {\n  value: function (params) {\n    return this._client.execute({\n      method: 'video.prioritize_handraise',\n      params: {\n        room_session_id: this.roomSessionId,\n        enable: params,\n      },\n    })\n  },\n}\n\nexport type GetLayouts = ReturnType<typeof getLayouts.value>\nexport type GetMembers = ReturnType<typeof getMembers.value>\nexport type HideVideoMuted = ReturnType<typeof hideVideoMuted.value>\nexport type ShowVideoMuted = ReturnType<typeof showVideoMuted.value>\nexport type SetHideVideoMuted = ReturnType<typeof setHideVideoMuted.value>\n\nexport type GetRecordings = ReturnType<typeof getRecordings.value>\nexport type StartRecording = ReturnType<typeof startRecording.value>\n\nexport type GetPlaybacks = ReturnType<typeof getPlaybacks.value>\nexport type Play = ReturnType<typeof play.value>\nexport type GetMeta = ReturnType<typeof getMeta.value>\nexport type SetMeta = ReturnType<typeof setMeta.value>\nexport type UpdateMeta = ReturnType<typeof updateMeta.value>\nexport type DeleteMeta = ReturnType<typeof deleteMeta.value>\n\nexport type GetStreams = ReturnType<typeof getStreams.value>\nexport type StartStream = ReturnType<typeof startStream.value>\n\nexport type Lock = ReturnType<typeof lock.value>\nexport type Unlock = ReturnType<typeof unlock.value>\nexport type SetPrioritizeHandraise = ReturnType<\n  typeof setPrioritizeHandraise.value\n>\n// End Room Methods\n\n/**\n * Room Member Methods\n */\nexport const audioMuteMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.audio_mute',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const audioUnmuteMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.audio_unmute',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const videoMuteMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.video_mute',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const videoUnmuteMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.video_unmute',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const deafMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.deaf',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const undeafMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.undeaf',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\n// This is used on a RoomSessionMember instance where we have\n// `this.roomSessionId` and `this.memberId`\nexport const setDeaf: RoomMethodDescriptor<void, boolean> = {\n  value: function (value) {\n    return this._client.execute(\n      {\n        method: value ? 'video.member.deaf' : 'video.member.undeaf',\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: this.memberId,\n        },\n      },\n      {\n        transformResolve: baseCodeTransform,\n      }\n    )\n  },\n}\nexport const setInputVolumeMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.set_input_volume',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const setOutputVolumeMember = createRoomMemberMethod<\n  BaseRPCResult,\n  void\n>('video.member.set_output_volume', {\n  transformResolve: baseCodeTransform,\n})\nexport const setInputSensitivityMember = createRoomMemberMethod<\n  BaseRPCResult,\n  void\n>('video.member.set_input_sensitivity', {\n  transformResolve: baseCodeTransform,\n})\n\ninterface PromoteDemoteMemberParams extends Required<MemberCommandParams> {\n  mediaAllowed?: MediaAllowed\n}\n\nexport interface PromoteMemberParams extends PromoteDemoteMemberParams {\n  permissions?: string[]\n  meta?: VideoMeta\n  joinAudioMuted?: boolean\n  joinVideoMuted?: boolean\n}\nexport const promote: RoomMethodDescriptor<void, PromoteMemberParams> = {\n  value: function ({\n    memberId,\n    mediaAllowed,\n    joinAudioMuted,\n    joinVideoMuted,\n    ...rest\n  }) {\n    return this._client.execute<unknown, void, PromoteMemberParams>(\n      {\n        method: 'video.member.promote',\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: memberId,\n          media_allowed: mediaAllowed,\n          join_audio_muted: joinAudioMuted,\n          join_video_muted: joinVideoMuted,\n          ...rest,\n        },\n      },\n      {\n        transformResolve: baseCodeTransform as any,\n      }\n    )\n  },\n}\n\nexport interface DemoteMemberParams extends PromoteDemoteMemberParams {}\nexport const demote: RoomMethodDescriptor<void, DemoteMemberParams> = {\n  value: function ({ memberId, mediaAllowed }) {\n    return this._client.execute<unknown, void, DemoteMemberParams>(\n      {\n        method: 'video.member.demote',\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: memberId,\n          media_allowed: mediaAllowed,\n        },\n      },\n      {\n        transformResolve: baseCodeTransform as any,\n      }\n    )\n  },\n}\n\nexport interface SetMemberPositionParams extends MemberCommandParams {\n  position: VideoPosition\n}\nexport const setMemberPosition = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.set_position',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const removeMember: RoomMethodDescriptor<\n  void,\n  Required<RoomMemberMethodParams>\n> = {\n  value: function ({ memberId, ...rest }) {\n    if (!memberId) {\n      throw new TypeError('Invalid or missing \"memberId\" argument')\n    }\n    return this._client.execute(\n      {\n        method: 'video.member.remove',\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: memberId,\n          ...rest,\n        },\n      },\n      {\n        transformResolve: baseCodeTransform,\n      }\n    )\n  },\n}\n\nexport const removeAllMembers: RoomMethodDescriptor<void, void> = {\n  value: function () {\n    return this._client.execute(\n      {\n        method: 'video.member.remove',\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: 'all',\n        },\n      },\n      {\n        transformResolve: baseCodeTransform,\n      }\n    )\n  },\n}\n\ninterface GetMemberMetaOutput {\n  meta: VideoMeta\n}\n\nexport const getMemberMeta = createRoomMemberMethod<\n  BaseRPCResult & VideoMeta,\n  GetMemberMetaOutput\n>('video.member.get_meta', {\n  transformResolve: ({ meta }) => ({ meta }),\n})\nexport interface SetMemberMetaParams extends MemberCommandParams {\n  meta: VideoMeta\n}\nexport const setMemberMeta = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.set_meta',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\n\nexport interface UpdateMemberMetaParams extends MemberCommandParams {\n  meta: VideoMeta\n}\nexport const updateMemberMeta = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.update_meta',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport interface DeleteMemberMetaParams extends MemberCommandParams {\n  keys: string[]\n}\nexport const deleteMemberMeta = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.delete_meta',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\n\nexport interface SetRaisedHandRoomParams {\n  memberId: string\n  raised?: boolean\n}\n\nexport interface SetRaisedHandMemberParams {\n  raised?: boolean\n}\n\nexport const setRaisedHand: RoomMethodDescriptor<\n  void,\n  SetRaisedHandRoomParams | SetRaisedHandMemberParams\n> = {\n  value: function (value) {\n    const { raised = true, memberId = this.memberId } =\n      (value as SetRaisedHandRoomParams) || {}\n\n    if (!memberId) {\n      throw new TypeError('Invalid or missing \"memberId\" argument')\n    }\n\n    return this._client.execute(\n      {\n        method: raised ? 'video.member.raisehand' : 'video.member.lowerhand',\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: memberId,\n        },\n      },\n      {\n        transformResolve: baseCodeTransform,\n      }\n    )\n  },\n}\n\nexport type AudioMuteMember = ReturnType<typeof audioMuteMember.value>\nexport type AudioUnmuteMember = ReturnType<typeof audioUnmuteMember.value>\nexport type VideoMuteMember = ReturnType<typeof videoMuteMember.value>\nexport type VideoUnmuteMember = ReturnType<typeof videoUnmuteMember.value>\nexport type DeafMember = ReturnType<typeof deafMember.value>\nexport type UndeafMember = ReturnType<typeof undeafMember.value>\nexport type SetDeaf = ReturnType<typeof setDeaf.value>\nexport type SetLayout = ReturnType<typeof setLayout.value>\nexport type SetPositions = ReturnType<typeof setPositions.value>\nexport type SetInputVolumeMember = ReturnType<typeof setInputVolumeMember.value>\nexport type SetOutputVolumeMember = ReturnType<\n  typeof setOutputVolumeMember.value\n>\nexport type SetInputSensitivityMember = ReturnType<\n  typeof setInputSensitivityMember.value\n>\nexport type SetMemberPosition = ReturnType<typeof setMemberPosition.value>\nexport type RemoveMember = ReturnType<typeof removeMember.value>\nexport type RemoveAllMembers = ReturnType<typeof removeAllMembers.value>\nexport type GetMemberMeta = ReturnType<typeof getMemberMeta.value>\nexport type SetMemberMeta = ReturnType<typeof setMemberMeta.value>\nexport type UpdateMemberMeta = ReturnType<typeof updateMemberMeta.value>\nexport type DeleteMemberMeta = ReturnType<typeof deleteMemberMeta.value>\nexport type PromoteMember = ReturnType<typeof promote.value>\nexport type DemoteMember = ReturnType<typeof demote.value>\nexport type SetRaisedHand = ReturnType<typeof setRaisedHand.value>\n// End Room Member Methods\n\n/**\n * This function converts action listeners into room listeners and attach those to room\n * For eg: Playback's onStarted changes into onPlaybackStarted\n */\ninterface MapActionListenersToRoomListenerParams {\n  listeners:\n    | RealTimeRoomPlaybackListeners\n    | RealTimeRoomRecordingListeners\n    | RealTimeRoomStreamListeners\n  action: 'playback' | 'recording' | 'stream'\n}\nfunction mapActionListenersToRoomListeners(\n  this: BaseRoomInterface,\n  options: MapActionListenersToRoomListenerParams\n) {\n  const { listeners, action } = options\n\n  if (!['playback', 'recording', 'stream'].includes(action)) return\n\n  const playListenMapper = {\n    onStarted: 'onPlaybackStarted',\n    onUpdated: 'onPlaybackUpdated',\n    onEnded: 'onPlaybackEnded',\n  }\n\n  const recordListenMapper = {\n    onStarted: 'onRecordingStarted',\n    onUpdated: 'onRecordingUpdated',\n    onEnded: 'onRecordingEnded',\n  }\n\n  const streamListenMapper = {\n    onStarted: 'onStreamStarted',\n    onEnded: 'onStreamEnded',\n  }\n\n  let mapper: Record<string, string> = {}\n\n  if (action === 'playback') {\n    mapper = playListenMapper\n  }\n  if (action === 'recording') {\n    mapper = recordListenMapper\n  }\n  if (action === 'stream') {\n    mapper = streamListenMapper\n  }\n\n  const roomListeners = Object.keys(listeners).reduce((acc: any, key) => {\n    const mappedKey = mapper[key]\n    if (mappedKey) {\n      // @ts-expect-error\n      acc[mappedKey] = listeners[key]\n    }\n    return acc\n  }, {})\n  this.listen(roomListeners)\n}\n", "/**\n * Once we have new interface for Browser SDK;\n * RoomSessionPlayback in core should be removed\n * RoomSessionPlayback in realtime-api should be moved to core\n */\n\nimport type {\n  VideoPlaybackContract,\n  VideoPlaybackEventParams,\n} from '@signalwire/core'\nimport { ListenSubscriber } from '../../ListenSubscriber'\nimport {\n  RealTimeRoomPlaybackEvents,\n  RealTimeRoomPlaybackListeners,\n  RealtimeRoomPlaybackListenersEventsMapping,\n} from '../../types'\nimport { RoomSession } from '../RoomSession'\n\n/**\n * Instances of this class allow you to control (e.g., pause, resume, stop) the\n * playback inside a room session. You can obtain instances of this class by\n * starting a playback from the desired {@link RoomSession} (see\n * {@link RoomSession.play})\n */\n\nexport interface RoomSessionPlaybackOptions {\n  roomSession: RoomSession\n  payload: VideoPlaybackEventParams\n}\n\nexport class RoomSessionPlayback\n  extends ListenSubscriber<\n    RealTimeRoomPlaybackListeners,\n    RealTimeRoomPlaybackEvents\n  >\n  implements VideoPlaybackContract\n{\n  private _payload: VideoPlaybackEventParams\n  protected _eventMap: RealtimeRoomPlaybackListenersEventsMapping = {\n    onStarted: 'playback.started',\n    onUpdated: 'playback.updated',\n    onEnded: 'playback.ended',\n  }\n\n  constructor(options: RoomSessionPlaybackOptions) {\n    super({ swClient: options.roomSession._sw })\n\n    this._payload = options.payload\n  }\n\n  get id() {\n    return this._payload.playback.id\n  }\n\n  get roomId() {\n    return this._payload.room_id\n  }\n\n  get roomSessionId() {\n    return this._payload.room_session_id\n  }\n\n  get url() {\n    return this._payload.playback.url\n  }\n\n  get state() {\n    return this._payload.playback.state\n  }\n\n  get volume() {\n    return this._payload.playback.volume\n  }\n\n  get startedAt() {\n    if (!this._payload.playback.started_at) return undefined\n    return new Date(\n      (this._payload.playback.started_at as unknown as number) * 1000\n    )\n  }\n\n  get endedAt() {\n    if (!this._payload.playback.ended_at) return undefined\n    return new Date(\n      (this._payload.playback.ended_at as unknown as number) * 1000\n    )\n  }\n\n  get position() {\n    return this._payload.playback.position\n  }\n\n  get seekable() {\n    return this._payload.playback.seekable\n  }\n\n  get hasEnded() {\n    if (this.state === 'completed') {\n      return true\n    }\n    return false\n  }\n\n  /** @internal */\n  setPayload(payload: VideoPlaybackEventParams) {\n    this._payload = payload\n  }\n\n  async pause() {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'video.playback.pause',\n      params: {\n        room_session_id: this.roomSessionId,\n        playback_id: this.id,\n      },\n    })\n  }\n\n  async resume() {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'video.playback.resume',\n      params: {\n        room_session_id: this.roomSessionId,\n        playback_id: this.id,\n      },\n    })\n  }\n\n  async stop() {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'video.playback.stop',\n      params: {\n        room_session_id: this.roomSessionId,\n        playback_id: this.id,\n      },\n    })\n  }\n\n  async setVolume(volume: number) {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'video.playback.set_volume',\n      params: {\n        room_session_id: this.roomSessionId,\n        playback_id: this.id,\n        volume,\n      },\n    })\n  }\n\n  async seek(timecode: number) {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'video.playback.seek_absolute',\n      params: {\n        room_session_id: this.roomSessionId,\n        playback_id: this.id,\n        position: Math.abs(timecode),\n      },\n    })\n  }\n\n  async forward(offset: number = 5000) {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'video.playback.seek_relative',\n      params: {\n        room_session_id: this.roomSessionId,\n        playback_id: this.id,\n        position: Math.abs(offset),\n      },\n    })\n  }\n\n  async rewind(offset: number = 5000) {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'video.playback.seek_relative',\n      params: {\n        room_session_id: this.roomSessionId,\n        playback_id: this.id,\n        position: -Math.abs(offset),\n      },\n    })\n  }\n}\n", "import { Promisify } from '@signalwire/core'\nimport { RoomSession } from '../RoomSession'\nimport { RoomSessionPlayback } from './RoomSessionPlayback'\nimport { decoratePromise } from '../../decoratePromise'\nimport { RealTimeRoomPlaybackListeners } from '../../types'\n\nexport interface RoomSessionPlaybackEnded {\n  id: string\n  roomId: string\n  roomSessionId: string\n  url: string\n  state: RoomSessionPlayback['state']\n  volume: number\n  startedAt?: Date\n  endedAt?: Date\n  position: number\n  seekable: boolean\n}\n\nexport interface RoomSessionPlaybackPromise\n  extends Promise<RoomSessionPlaybackEnded>,\n    Promisify<RoomSessionPlaybackEnded> {\n  onStarted: () => Promise<RoomSessionPlayback>\n  onEnded: () => Promise<RoomSessionPlaybackEnded>\n  listen: (\n    listeners: RealTimeRoomPlaybackListeners\n  ) => Promise<() => Promise<void>>\n  pause: () => Promise<void>\n  resume: () => Promise<void>\n  stop: () => Promise<void>\n  setVolume: (volume: number) => Promise<void>\n  seek: (timecode: number) => Promise<void>\n  forward: (offset: number) => Promise<void>\n  rewind: (offset: number) => Promise<void>\n}\n\nexport const getters = [\n  'id',\n  'roomId',\n  'roomSessionId',\n  'url',\n  'state',\n  'volume',\n  'startedAt',\n  'endedAt',\n  'position',\n  'seekable',\n]\n\nexport const methods = [\n  'pause',\n  'resume',\n  'stop',\n  'setVolume',\n  'seek',\n  'forward',\n  'rewind',\n]\n\nexport function decoratePlaybackPromise(\n  this: RoomSession,\n  innerPromise: Promise<RoomSessionPlayback>\n) {\n  // prettier-ignore\n  return (decoratePromise<RoomSessionPlayback, RoomSessionPlaybackEnded>).call(this, { \n    promise: innerPromise,\n    namespace: 'playback',\n    methods,\n    getters,\n  }) as RoomSessionPlaybackPromise\n}\n", "/**\n * Once we have new interface for Browser SDK;\n * RoomSessionRecording in core should be removed\n * RoomSessionRecording in realtime-api should be moved to core\n */\n\nimport type {\n  VideoRecordingEventParams,\n  VideoRecordingMethods,\n} from '@signalwire/core'\nimport {\n  RealTimeRoomRecordingEvents,\n  RealTimeRoomRecordingListeners,\n  RealtimeRoomRecordingListenersEventsMapping,\n} from '../../types'\nimport { ListenSubscriber } from '../../ListenSubscriber'\nimport { RoomSession } from '../RoomSession'\n\nexport interface RoomSessionRecordingOptions {\n  roomSession: RoomSession\n  payload: VideoRecordingEventParams\n}\n\nexport class RoomSessionRecording\n  extends ListenSubscriber<\n    RealTimeRoomRecordingListeners,\n    RealTimeRoomRecordingEvents\n  >\n  implements VideoRecordingMethods\n{\n  private _payload: VideoRecordingEventParams\n  protected _eventMap: RealtimeRoomRecordingListenersEventsMapping = {\n    onStarted: 'recording.started',\n    onUpdated: 'recording.updated',\n    onEnded: 'recording.ended',\n  }\n\n  constructor(options: RoomSessionRecordingOptions) {\n    super({ swClient: options.roomSession._sw })\n\n    this._payload = options.payload\n  }\n\n  get id() {\n    return this._payload.recording.id\n  }\n\n  get roomId() {\n    return this._payload.room_id\n  }\n\n  get roomSessionId() {\n    return this._payload.room_session_id\n  }\n\n  get state() {\n    return this._payload.recording.state\n  }\n\n  get duration() {\n    return this._payload.recording.duration\n  }\n\n  get startedAt() {\n    if (!this._payload.recording.started_at) return undefined\n    return new Date(\n      (this._payload.recording.started_at as unknown as number) * 1000\n    )\n  }\n\n  get endedAt() {\n    if (!this._payload.recording.ended_at) return undefined\n    return new Date(\n      (this._payload.recording.ended_at as unknown as number) * 1000\n    )\n  }\n\n  get hasEnded() {\n    if (this.state === 'completed') {\n      return true\n    }\n    return false\n  }\n\n  /** @internal */\n  setPayload(payload: VideoRecordingEventParams) {\n    this._payload = payload\n  }\n\n  async pause() {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'video.recording.pause',\n      params: {\n        room_session_id: this.roomSessionId,\n        recording_id: this.id,\n      },\n    })\n  }\n\n  async resume() {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'video.recording.resume',\n      params: {\n        room_session_id: this.roomSessionId,\n        recording_id: this.id,\n      },\n    })\n  }\n\n  async stop() {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'video.recording.stop',\n      params: {\n        room_session_id: this.roomSessionId,\n        recording_id: this.id,\n      },\n    })\n  }\n}\n", "import { Promisify } from '@signalwire/core'\nimport { RoomSession } from '../RoomSession'\nimport { RoomSessionRecording } from './RoomSessionRecording'\nimport { decoratePromise } from '../../decoratePromise'\nimport { RealTimeRoomRecordingListeners } from '../../types'\n\nexport interface RoomSessionRecordingEnded {\n  id: string\n  roomId: string\n  roomSessionId: string\n  state: RoomSessionRecording['state']\n  duration?: number\n  startedAt?: Date\n  endedAt?: Date\n}\n\nexport interface RoomSessionRecordingPromise\n  extends Promise<RoomSessionRecordingEnded>,\n    Promisify<RoomSessionRecordingEnded> {\n  onStarted: () => Promise<RoomSessionRecording>\n  onEnded: () => Promise<RoomSessionRecordingEnded>\n  listen: (\n    listeners: RealTimeRoomRecordingListeners\n  ) => Promise<() => Promise<void>>\n  pause: () => Promise<void>\n  resume: () => Promise<void>\n  stop: () => Promise<void>\n}\n\nexport const getters = [\n  'id',\n  'roomId',\n  'roomSessionId',\n  'state',\n  'duration',\n  'startedAt',\n  'endedAt',\n]\n\nexport const methods = ['pause', 'resume', 'stop']\n\nexport function decorateRecordingPromise(\n  this: RoomSession,\n  innerPromise: Promise<RoomSessionRecording>\n) {\n  // prettier-ignore\n  return (decoratePromise<RoomSessionRecording, RoomSessionRecordingEnded>).call(this, { \n    promise: innerPromise,\n    namespace: 'recording',\n    methods,\n    getters,\n  }) as RoomSessionRecordingPromise\n}\n", "/**\n * Once we have new interface for Browser SDK;\n * RoomSessionStream in core should be removed\n * RoomSessionStream in realtime-api should be moved to core\n */\n\nimport type {\n  VideoStreamEventParams,\n  VideoStreamMethods,\n} from '@signalwire/core'\nimport { RoomSession } from '../RoomSession'\nimport {\n  RealTimeRoomStreamEvents,\n  RealTimeRoomStreamListeners,\n  RealtimeRoomStreamListenersEventsMapping,\n} from '../../types'\nimport { ListenSubscriber } from '../../ListenSubscriber'\n\nexport interface RoomSessionStreamOptions {\n  roomSession: RoomSession\n  payload: VideoStreamEventParams\n}\n\nexport class RoomSessionStream\n  extends ListenSubscriber<\n    RealTimeRoomStreamListeners,\n    RealTimeRoomStreamEvents\n  >\n  implements VideoStreamMethods\n{\n  private _payload: VideoStreamEventParams\n  protected _eventMap: RealtimeRoomStreamListenersEventsMapping = {\n    onStarted: 'stream.started',\n    onEnded: 'stream.ended',\n  }\n\n  constructor(options: RoomSessionStreamOptions) {\n    super({ swClient: options.roomSession._sw })\n\n    this._payload = options.payload\n  }\n\n  get id() {\n    return this._payload.stream.id\n  }\n\n  get roomId() {\n    return this._payload.room_id\n  }\n\n  get roomSessionId() {\n    return this._payload.room_session_id\n  }\n\n  get state() {\n    return this._payload.stream.state\n  }\n\n  get duration() {\n    return this._payload.stream.duration\n  }\n\n  get url() {\n    return this._payload.stream.url\n  }\n\n  get startedAt() {\n    if (!this._payload.stream.started_at) return undefined\n    return new Date(\n      (this._payload.stream.started_at as unknown as number) * 1000\n    )\n  }\n\n  get endedAt() {\n    if (!this._payload.stream.ended_at) return undefined\n    return new Date((this._payload.stream.ended_at as unknown as number) * 1000)\n  }\n\n  get hasEnded() {\n    if (this.state === 'completed') {\n      return true\n    }\n    return false\n  }\n\n  /** @internal */\n  setPayload(payload: VideoStreamEventParams) {\n    this._payload = payload\n  }\n\n  async stop() {\n    if (this.hasEnded) {\n      throw new Error('Action has ended')\n    }\n\n    await this._client.execute({\n      method: 'video.stream.stop',\n      params: {\n        room_session_id: this.roomSessionId,\n        stream_id: this.id,\n      },\n    })\n  }\n}\n", "import { Promisify } from '@signalwire/core'\nimport { RoomSession } from '../RoomSession'\nimport { RoomSessionStream } from './RoomSessionStream'\nimport { decoratePromise } from '../../decoratePromise'\nimport { RealTimeRoomStreamListeners } from '../../types'\n\nexport interface RoomSessionStreamEnded {\n  id: string\n  roomId: string\n  roomSessionId: string\n  state: RoomSessionStream['state']\n  duration?: number\n  url?: string\n  startedAt?: Date\n  endedAt?: Date\n}\n\nexport interface RoomSessionStreamPromise\n  extends Promise<RoomSessionStreamEnded>,\n    Promisify<RoomSessionStreamEnded> {\n  onStarted: () => Promise<RoomSessionStream>\n  onEnded: () => Promise<RoomSessionStreamEnded>\n  listen: (\n    listeners: RealTimeRoomStreamListeners\n  ) => Promise<() => Promise<void>>\n  stop: () => Promise<void>\n}\n\nexport const getters = [\n  'id',\n  'roomId',\n  'roomSessionId',\n  'url',\n  'state',\n  'duration',\n  'startedAt',\n  'endedAt',\n]\n\nexport const methods = ['stop']\n\nexport function decorateStreamPromise(\n  this: RoomSession,\n  innerPromise: Promise<RoomSessionStream>\n) {\n  // prettier-ignore\n  return (decoratePromise<RoomSessionStream, RoomSessionStreamEnded>).call(this, { \n    promise: innerPromise,\n    namespace: 'stream',\n    methods,\n    getters,\n  }) as RoomSessionStreamPromise\n}\n", "import {\n  ExecuteParams,\n  EventEmitter,\n  JSONRPCSubscribeMethod,\n  validateEventsToSubscribe,\n  uuid,\n} from '@signalwire/core'\nimport { ListenSubscriber } from '../ListenSubscriber'\nimport { SWClient } from '../SWClient'\n\nexport class BaseVideo<\n  T extends {},\n  EventTypes extends EventEmitter.ValidEventTypes\n> extends ListenSubscriber<T, EventTypes> {\n  protected subscribeMethod: JSONRPCSubscribeMethod = 'signalwire.subscribe'\n  protected _subscribeParams?: Record<string, any> = {}\n  protected _eventChannel?: string = ''\n  private _subscribedEvents = new Map<\n    string,\n    EventEmitter.EventNames<EventTypes>[]\n  >()\n\n  constructor(options: SWClient) {\n    super({ swClient: options })\n  }\n\n  protected get eventChannel() {\n    return this._eventChannel\n  }\n\n  protected getSubscriptions() {\n    return validateEventsToSubscribe(this.eventNames())\n  }\n\n  protected async subscribe(listeners: T) {\n    const _uuid = uuid()\n\n    // Attach listeners\n    this._attachListeners(listeners)\n\n    // Subscribe to video events\n    await this.addEvents()\n\n    const unsub = () => {\n      return new Promise<void>(async (resolve, reject) => {\n        try {\n          // Detach listeners\n          this._detachListeners(listeners)\n\n          // Remove listeners from the listener map\n          this.removeFromListenerMap(_uuid)\n\n          resolve()\n        } catch (error) {\n          reject(error)\n        }\n      })\n    }\n\n    // Add listeners to the listener map\n    this.addToListenerMap(_uuid, {\n      listeners,\n      unsub,\n    })\n\n    return unsub\n  }\n\n  protected async addEvents() {\n    const subscriptions = this.getSubscriptions()\n    const channelSubscribedEvents = this.getSubscribedEvents()\n\n    // Filter out events that are already subscribed\n    const newSubscriptions = subscriptions.filter(\n      (event) => !channelSubscribedEvents?.includes(event)\n    )\n\n    if (!newSubscriptions.length) {\n      // All events are already subscribed for this channel\n      this._client.logger.debug('No new events to subscribe', subscriptions)\n      return\n    }\n\n    const executeParams: ExecuteParams = {\n      method: this.subscribeMethod,\n      params: {\n        get_initial_state: true,\n        event_channel: this.eventChannel,\n        events: newSubscriptions,\n      },\n    }\n    const result = await this._client.execute<unknown, void>(executeParams)\n\n    // Update subscribed events map\n    this.updateSubscribedEvents(newSubscriptions)\n\n    return result\n  }\n\n  private getSubscribedEvents() {\n    if (!this.eventChannel) return []\n    return this._subscribedEvents.get(this.eventChannel)\n  }\n\n  private updateSubscribedEvents(\n    newSubscriptions: EventEmitter.EventNames<EventTypes>[]\n  ) {\n    if (!this.eventChannel) return\n    if (this._subscribedEvents.has(this.eventChannel)) {\n      const prevEvents = this._subscribedEvents.get(this.eventChannel) || []\n      const newEvents = [...prevEvents, ...newSubscriptions]\n      this._subscribedEvents.set(this.eventChannel, newEvents)\n    } else {\n      this._subscribedEvents.set(this.eventChannel, newSubscriptions)\n    }\n  }\n}\n", "import {\n  MapToPubSubShape,\n  SDKActions,\n  SDKWorker,\n  SagaIterator,\n  VideoAPIEventParams,\n  getLogger,\n  sagaEffects,\n  sagaHelpers,\n  SDKWorkerParams,\n} from '@signalwire/core'\nimport type { Client } from '../../client/index'\nimport { videoRoomWorker } from './videoRoomWorker'\nimport { videoMemberWorker } from './videoMemberWorker'\nimport { videoLayoutWorker } from './videoLayoutWorker'\nimport { videoRoomAudienceWorker } from './videoRoomAudienceWorker'\nimport { videoRecordingWorker } from './videoRecordingWorker'\nimport { videoPlaybackWorker } from './videoPlaybackWorker'\nimport { Video } from '../Video'\nimport { videoStreamWorker } from './videoStreamWorker'\n\nexport type VideoCallWorkerParams<T> = SDKWorkerParams<Client> & {\n  action: T\n  video: Video\n}\n\ninterface VideoCallingWorkerInitialState {\n  video: Video\n}\n\nexport const videoCallingWorker: SDKWorker<Client> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('videoCallingWorker started')\n  const {\n    channels: { swEventChannel },\n    initialState,\n  } = options\n\n  const { video } = initialState as VideoCallingWorkerInitialState\n\n  function* worker(action: MapToPubSubShape<VideoAPIEventParams>) {\n    const { type } = action\n\n    switch (type) {\n      case 'video.room.started':\n      case 'video.room.updated':\n      case 'video.room.ended':\n      case 'video.room.subscribed':\n        yield sagaEffects.fork(videoRoomWorker, {\n          action,\n          video,\n          ...options,\n        })\n        break\n      case 'video.member.joined':\n      case 'video.member.left':\n      case 'video.member.updated':\n      case 'video.member.talking':\n        yield sagaEffects.fork(videoMemberWorker, {\n          action,\n          video,\n          ...options,\n        })\n        break\n      case 'video.layout.changed':\n        yield sagaEffects.fork(videoLayoutWorker, {\n          action,\n          video,\n          ...options,\n        })\n        break\n      case 'video.room.audience_count':\n        yield sagaEffects.fork(videoRoomAudienceWorker, {\n          action,\n          video,\n          ...options,\n        })\n        break\n      case 'video.playback.started':\n      case 'video.playback.updated':\n      case 'video.playback.ended':\n        yield sagaEffects.fork(videoPlaybackWorker, {\n          action,\n          video,\n          ...options,\n        })\n        break\n      case 'video.recording.started':\n      case 'video.recording.updated':\n      case 'video.recording.ended':\n        yield sagaEffects.fork(videoRecordingWorker, {\n          action,\n          video,\n          ...options,\n        })\n        break\n      case 'video.stream.started':\n      case 'video.stream.ended':\n        yield sagaEffects.fork(videoStreamWorker, {\n          action,\n          video,\n          ...options,\n        })\n        break\n      default:\n        getLogger().warn(`Unknown video event: \"${type}\"`)\n        break\n    }\n  }\n\n  const workerCatchable = sagaHelpers.createCatchableSaga<\n    MapToPubSubShape<VideoAPIEventParams>\n  >(worker, (error) => {\n    getLogger().error('Voice calling event error', error)\n  })\n\n  const isVideoEvent = (action: SDKActions) => action.type.startsWith('video.')\n\n  while (true) {\n    const action: MapToPubSubShape<VideoAPIEventParams> =\n      yield sagaEffects.take(swEventChannel, isVideoEvent)\n\n    yield sagaEffects.fork(workerCatchable, action)\n  }\n\n  getLogger().trace('videoCallingWorker ended')\n}\n", "import {\n  getLogger,\n  InternalVideoMemberEntity,\n  SagaIterator,\n  MemberPosition,\n  MapToPubSubShape,\n  InternalMemberUpdatedEventNames,\n  VideoRoomEvent,\n  sagaEffects,\n} from '@signalwire/core'\nimport { videoMemberWorker } from './videoMemberWorker'\nimport { RoomSessionMember, RoomSessionMemberAPI } from '../RoomSessionMember'\nimport { VideoCallWorkerParams } from './videoCallingWorker'\nimport { RoomSession, RoomSessionAPI } from '../RoomSession'\n\nexport const videoRoomWorker = function* (\n  options: VideoCallWorkerParams<MapToPubSubShape<VideoRoomEvent>>\n): SagaIterator {\n  getLogger().trace('videoRoomWorker started')\n  const { video, action, ...memberPositionWorkerParams } = options\n  const { type, payload } = action\n  const { get, set, remove } = options.instanceMap\n\n  let roomSessionInstance = get<RoomSession>(payload.room_session.id)\n  if (!roomSessionInstance) {\n    roomSessionInstance = new RoomSessionAPI({\n      video,\n      payload,\n    })\n  } else {\n    roomSessionInstance.setPayload(payload)\n  }\n  set<RoomSession>(payload.room_session.id, roomSessionInstance)\n\n  // Create and set member instance if exists\n  if ((payload.room_session.members?.length || 0) > 0) {\n    ;(payload.room_session.members || []).forEach((member) => {\n      let memberInstance = get<RoomSessionMember>(member.id)\n      if (!memberInstance) {\n        memberInstance = new RoomSessionMemberAPI({\n          roomSession: roomSessionInstance,\n          payload: {\n            room_id: payload.room_session.room_id,\n            room_session_id: payload.room_session.id,\n            member,\n          },\n        })\n      } else {\n        memberInstance.setPayload({\n          room_id: payload.room_session.room_id,\n          room_session_id: payload.room_session.id,\n          member: member as InternalVideoMemberEntity & { talking: boolean },\n        })\n      }\n      set<RoomSessionMember>(member.id, memberInstance)\n    })\n  }\n\n  switch (type) {\n    case 'video.room.started': {\n      video.emit('room.started', roomSessionInstance)\n      roomSessionInstance.emit('room.started', roomSessionInstance)\n      break\n    }\n    case 'video.room.updated': {\n      roomSessionInstance.emit('room.updated', roomSessionInstance)\n      break\n    }\n    case 'video.room.ended': {\n      video.emit('room.ended', roomSessionInstance)\n      roomSessionInstance.emit('room.ended', roomSessionInstance)\n      remove<RoomSession>(payload.room_session.id)\n      break\n    }\n    case 'video.room.subscribed': {\n      yield sagaEffects.spawn(MemberPosition.memberPositionWorker, {\n        ...memberPositionWorkerParams,\n        instance: roomSessionInstance,\n        initialState: payload,\n        dispatcher: function* (\n          subType: InternalMemberUpdatedEventNames,\n          subPayload\n        ) {\n          yield sagaEffects.fork(videoMemberWorker, {\n            ...options,\n            action: { type: subType, payload: subPayload },\n          })\n        },\n      })\n      roomSessionInstance.emit('room.subscribed', roomSessionInstance)\n      break\n    }\n    default:\n      break\n  }\n\n  getLogger().trace('videoRoomWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  MapToPubSubShape,\n  VideoMemberJoinedEvent,\n  VideoMemberLeftEvent,\n  VideoMemberUpdatedEvent,\n  VideoMemberTalkingEvent,\n  InternalVideoMemberUpdatedEvent,\n  fromSnakeToCamelCase,\n  stripNamespacePrefix,\n  VideoMemberEventNames,\n  MemberTalkingEventNames,\n} from '@signalwire/core'\nimport { RoomSession } from '../RoomSession'\nimport {\n  RoomSessionMember,\n  RoomSessionMemberAPI,\n  RoomSessionMemberEventParams,\n} from '../RoomSessionMember'\nimport { VideoCallWorkerParams } from './videoCallingWorker'\n\ntype VideoMemberEvents = MapToPubSubShape<\n  | VideoMemberJoinedEvent\n  | VideoMemberLeftEvent\n  | VideoMemberUpdatedEvent\n  | VideoMemberTalkingEvent\n  | InternalVideoMemberUpdatedEvent\n>\n\nexport const videoMemberWorker = function* (\n  options: VideoCallWorkerParams<VideoMemberEvents>\n): SagaIterator {\n  getLogger().trace('videoMemberWorker started')\n  const {\n    action: { type, payload },\n    instanceMap: { get, set, remove },\n  } = options\n\n  const roomSessionInstance = get<RoomSession>(payload.room_session_id)\n  if (!roomSessionInstance) {\n    throw new Error('Missing room session instance for member')\n  }\n\n  let memberInstance = get<RoomSessionMember>(payload.member.id)\n  if (!memberInstance) {\n    memberInstance = new RoomSessionMemberAPI({\n      roomSession: roomSessionInstance,\n      payload: payload as RoomSessionMemberEventParams,\n    })\n  } else {\n    memberInstance.setPayload(payload as RoomSessionMemberEventParams)\n  }\n  set<RoomSessionMember>(payload.member.id, memberInstance)\n\n  const event = stripNamespacePrefix(type) as VideoMemberEventNames\n\n  if (type.startsWith('video.member.updated.')) {\n    const clientType = fromSnakeToCamelCase(event)\n    // @ts-expect-error\n    roomSessionInstance.emit(clientType, memberInstance)\n  }\n\n  switch (type) {\n    case 'video.member.joined':\n    case 'video.member.updated':\n      roomSessionInstance.emit(event, memberInstance)\n      break\n    case 'video.member.left':\n      roomSessionInstance.emit(event, memberInstance)\n      remove<RoomSessionMember>(payload.member.id)\n      break\n    case 'video.member.talking':\n      roomSessionInstance.emit(event, memberInstance)\n      if ('talking' in payload.member) {\n        const suffix = payload.member.talking ? 'started' : 'ended'\n        roomSessionInstance.emit(\n          `${event}.${suffix}` as MemberTalkingEventNames,\n          memberInstance\n        )\n\n        // Keep for backwards compatibility\n        const deprecatedSuffix = payload.member.talking ? 'start' : 'stop'\n        roomSessionInstance.emit(\n          `${event}.${deprecatedSuffix}` as MemberTalkingEventNames,\n          memberInstance\n        )\n      }\n      break\n    default:\n      break\n  }\n\n  getLogger().trace('videoMemberWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  MapToPubSubShape,\n  VideoLayoutChangedEvent,\n  toExternalJSON,\n  stripNamespacePrefix,\n  VideoLayoutEventNames,\n} from '@signalwire/core'\nimport { RoomSession } from '../RoomSession'\nimport { VideoCallWorkerParams } from './videoCallingWorker'\n\nexport const videoLayoutWorker = function* (\n  options: VideoCallWorkerParams<MapToPubSubShape<VideoLayoutChangedEvent>>\n): SagaIterator {\n  getLogger().trace('videoLayoutWorker started')\n  const {\n    action: { type, payload },\n    instanceMap: { get },\n  } = options\n\n  const roomSessionInstance = get<RoomSession>(payload.room_session_id)\n  if (!roomSessionInstance) {\n    throw new Error('Missing room session instance for playback')\n  }\n\n  // TODO: Implement a Layout object when we have a proper payload from the backend\n  // Create a layout instance and emit that instance\n\n  const event = stripNamespacePrefix(type) as VideoLayoutEventNames\n\n  switch (type) {\n    case 'video.layout.changed':\n      roomSessionInstance.emit(event, toExternalJSON(payload))\n      break\n    default:\n      break\n  }\n\n  getLogger().trace('videoLayoutWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  MapToPubSubShape,\n  toExternalJSON,\n  VideoRoomAudienceCountEvent,\n} from '@signalwire/core'\nimport { RoomSession } from '../RoomSession'\nimport { VideoCallWorkerParams } from './videoCallingWorker'\n\nexport const videoRoomAudienceWorker = function* (\n  options: VideoCallWorkerParams<MapToPubSubShape<VideoRoomAudienceCountEvent>>\n): SagaIterator {\n  getLogger().trace('videoRoomAudienceWorker started')\n  const {\n    action: { type, payload },\n    instanceMap: { get },\n  } = options\n\n  const roomSessionInstance = get<RoomSession>(payload.room_session_id)\n  if (!roomSessionInstance) {\n    throw new Error('Missing room session instance for playback')\n  }\n\n  switch (type) {\n    case 'video.room.audience_count':\n      // @ts-expect-error\n      roomSessionInstance.emit('room.audienceCount', toExternalJSON(payload))\n      break\n    default:\n      break\n  }\n\n  getLogger().trace('videoRoomAudienceWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  VideoRecordingEventNames,\n  stripNamespacePrefix,\n  VideoRecordingAction,\n} from '@signalwire/core'\nimport { RoomSession } from '../RoomSession'\nimport { VideoCallWorkerParams } from './videoCallingWorker'\nimport { RoomSessionRecording } from '../RoomSessionRecording'\n\nexport const videoRecordingWorker = function* (\n  options: VideoCallWorkerParams<VideoRecordingAction>\n): SagaIterator {\n  getLogger().trace('videoRecordingWorker started')\n  const {\n    action: { type, payload },\n    instanceMap: { get, set, remove },\n  } = options\n\n  const roomSessionInstance = get<RoomSession>(payload.room_session_id)\n  if (!roomSessionInstance) {\n    throw new Error('Missing room session instance for playback')\n  }\n\n  let recordingInstance = get<RoomSessionRecording>(payload.recording.id)\n  if (!recordingInstance) {\n    recordingInstance = new RoomSessionRecording({\n      roomSession: roomSessionInstance,\n      payload,\n    })\n  } else {\n    recordingInstance.setPayload(payload)\n  }\n  set<RoomSessionRecording>(payload.recording.id, recordingInstance)\n\n  const event = stripNamespacePrefix(type) as VideoRecordingEventNames\n\n  switch (type) {\n    case 'video.recording.started':\n    case 'video.recording.updated':\n      roomSessionInstance.emit(event, recordingInstance)\n      recordingInstance.emit(event, recordingInstance)\n      break\n    case 'video.recording.ended':\n      roomSessionInstance.emit(event, recordingInstance)\n      recordingInstance.emit(event, recordingInstance)\n      remove<RoomSessionRecording>(payload.recording.id)\n      break\n    default:\n      break\n  }\n\n  getLogger().trace('videoRecordingWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  stripNamespacePrefix,\n  VideoPlaybackEventNames,\n  VideoPlaybackAction,\n} from '@signalwire/core'\nimport { RoomSession } from '../RoomSession'\nimport { VideoCallWorkerParams } from './videoCallingWorker'\nimport { RoomSessionPlayback } from '../RoomSessionPlayback'\n\nexport const videoPlaybackWorker = function* (\n  options: VideoCallWorkerParams<VideoPlaybackAction>\n): SagaIterator {\n  getLogger().trace('videoPlaybackWorker started')\n  const {\n    action: { type, payload },\n    instanceMap: { get, set, remove },\n  } = options\n\n  const roomSessionInstance = get<RoomSession>(payload.room_session_id)\n  if (!roomSessionInstance) {\n    throw new Error('Missing room session instance for playback')\n  }\n\n  let playbackInstance = get<RoomSessionPlayback>(payload.playback.id)\n  if (!playbackInstance) {\n    playbackInstance = new RoomSessionPlayback({\n      roomSession: roomSessionInstance,\n      payload,\n    })\n  } else {\n    playbackInstance.setPayload(payload)\n  }\n  set<RoomSessionPlayback>(payload.playback.id, playbackInstance)\n\n  const event = stripNamespacePrefix(type) as VideoPlaybackEventNames\n\n  switch (type) {\n    case 'video.playback.started':\n    case 'video.playback.updated':\n      roomSessionInstance.emit(event, playbackInstance)\n      playbackInstance.emit(event, playbackInstance)\n      break\n    case 'video.playback.ended':\n      roomSessionInstance.emit(event, playbackInstance)\n      playbackInstance.emit(event, playbackInstance)\n      remove<RoomSessionPlayback>(payload.playback.id)\n      break\n    default:\n      break\n  }\n\n  getLogger().trace('videoPlaybackWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  stripNamespacePrefix,\n  VideoStreamEventNames,\n  VideoStreamAction,\n} from '@signalwire/core'\nimport { RoomSession } from '../RoomSession'\nimport { VideoCallWorkerParams } from './videoCallingWorker'\nimport { RoomSessionStream } from '../RoomSessionStream'\n\nexport const videoStreamWorker = function* (\n  options: VideoCallWorkerParams<VideoStreamAction>\n): SagaIterator {\n  getLogger().trace('videoStreamWorker started')\n  const {\n    action: { type, payload },\n    instanceMap: { get, set, remove },\n  } = options\n\n  const roomSessionInstance = get<RoomSession>(payload.room_session_id)\n  if (!roomSessionInstance) {\n    throw new Error('Missing room session instance for stream')\n  }\n\n  let streamInstance = get<RoomSessionStream>(payload.stream.id)\n  if (!streamInstance) {\n    streamInstance = new RoomSessionStream({\n      roomSession: roomSessionInstance,\n      payload,\n    })\n  } else {\n    streamInstance.setPayload(payload)\n  }\n  set<RoomSessionStream>(payload.stream.id, streamInstance)\n\n  const event = stripNamespacePrefix(type) as VideoStreamEventNames\n\n  switch (type) {\n    case 'video.stream.started':\n      roomSessionInstance.emit(event, streamInstance)\n      streamInstance.emit(event, streamInstance)\n      break\n    case 'video.stream.ended':\n      roomSessionInstance.emit(event, streamInstance)\n      streamInstance.emit(event, streamInstance)\n      remove<RoomSessionStream>(payload.stream.id)\n      break\n    default:\n      break\n  }\n\n  getLogger().trace('videoStreamWorker ended')\n}\n", "import { connect, ClientEvents, SDKStore } from '@signalwire/core'\nimport { setupInternals } from '../utils/internals'\nimport { Client } from './Client'\n\nexport const createClient = (userOptions: {\n  project: string\n  token: string\n  logLevel?: 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'silent'\n  store?: SDKStore\n}) => {\n  const { emitter, store } = setupInternals(userOptions)\n  const client = connect<ClientEvents, Client, Client>({\n    store: userOptions.store ?? store,\n    Component: Client,\n  })({ ...userOptions, store, emitter })\n\n  return client\n}\n", "/**\n * Note: This file will eventually replace\n * packages/realtime-api/src/Client.ts\n */\n\nimport {\n  BaseClient as CoreBaseClient,\n  ClientContract,\n  ClientEvents,\n} from '@signalwire/core'\n\nexport interface RealtimeClient\n  extends ClientContract<RealtimeClient, ClientEvents> {\n  /**\n   * Connects this client to the SignalWire network.\n   *\n   * As a general best practice, it is suggested to connect the event listeners\n   * *before* connecting the client, so that no events are lost.\n   *\n   * @returns Upon connection, asynchronously returns an instance of this same\n   * object.\n   *\n   * @example\n   * ```typescript\n   * const client = await createClient({project, token})\n   * client.video.on('room.started', async (roomSession) => { })  // connect events\n   * await client.connect()\n   * ```\n   */\n  connect(): Promise<RealtimeClient>\n\n  /**\n   * Disconnects this client from the SignalWire network.\n   */\n  disconnect(): void\n}\n\nexport class Client extends CoreBaseClient<ClientEvents> {}\n", "import { RealtimeClient } from './Client'\n\nexport const clientConnect = (client: RealtimeClient) => {\n  /**\n   * We swallow the (possible) error here to avoid polluting\n   * the stdout. The error itself won't be swallowed from\n   * the user (it will be handled by our `rootSaga`) and we\n   * can extend that behavior by adding the following\n   * listener:\n   * client.on('session.auth_error', () => { ... })\n   */\n  return client.connect().catch(() => {})\n}\n", "import { createClient } from './client/createClient'\nimport type { Client } from './client/Client'\nimport { clientConnect } from './client/clientConnect'\nimport { Task } from './task/Task'\nimport { Messaging } from './messaging/Messaging'\nimport { PubSub } from './pubSub/PubSub'\nimport { Chat } from './chat/Chat'\nimport { Voice } from './voice/Voice'\nimport { Video } from './video/Video'\n\nexport interface SWClientOptions {\n  host?: string\n  project: string\n  token: string\n  logLevel?: 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'silent'\n  debug?: {\n    logWsTraffic?: boolean\n  }\n}\n\nexport class SWClient {\n  private _task: Task\n  private _messaging: Messaging\n  private _pubSub: PubSub\n  private _chat: Chat\n  private _voice: Voice\n  private _video: Video\n\n  public userOptions: SWClientOptions\n  public client: Client\n\n  constructor(options: SWClientOptions) {\n    this.userOptions = options\n    this.client = createClient(options)\n  }\n\n  async connect() {\n    await clientConnect(this.client)\n  }\n\n  disconnect() {\n    return new Promise<void>((resolve) => {\n      const { sessionEmitter } = this.client\n      sessionEmitter.on('session.disconnected', () => {\n        resolve()\n      })\n\n      this.client.disconnect()\n    })\n  }\n\n  get task() {\n    if (!this._task) {\n      this._task = new Task(this)\n    }\n    return this._task\n  }\n\n  get messaging() {\n    if (!this._messaging) {\n      this._messaging = new Messaging(this)\n    }\n    return this._messaging\n  }\n\n  get pubSub() {\n    if (!this._pubSub) {\n      this._pubSub = new PubSub(this)\n    }\n    return this._pubSub\n  }\n\n  get chat() {\n    if (!this._chat) {\n      this._chat = new Chat(this)\n    }\n    return this._chat\n  }\n\n  get voice() {\n    if (!this._voice) {\n      this._voice = new Voice(this)\n    }\n    return this._voice\n  }\n\n  get video() {\n    if (!this._video) {\n      this._video = new Video(this)\n    }\n    return this._video\n  }\n}\n", "import { SWClient, SWClientOptions } from './SWClient'\n\nexport const SignalWire = (options: SWClientOptions): Promise<SWClient> => {\n  return new Promise(async (resolve, reject) => {\n    const swClient = new SWClient(options)\n\n    try {\n      await swClient.connect()\n      resolve(swClient)\n    } catch (error) {\n      reject(error)\n    }\n  })\n}\n\nexport type { SWClient } from './SWClient'\n"],
  "mappings": "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",
  "names": []
}
