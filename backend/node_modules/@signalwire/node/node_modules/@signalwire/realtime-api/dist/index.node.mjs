var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/configure/index.ts
var GLOBAL_CONFIG = {};
var getConfig = () => {
  return GLOBAL_CONFIG;
};
var config = (_a) => {
  var _b = _a, {
    cache = GLOBAL_CONFIG
  } = _b, options = __objRest(_b, [
    "cache"
  ]);
  if (cache) {
    GLOBAL_CONFIG = cache;
  }
  Object.entries(options).forEach(([key, value]) => {
    GLOBAL_CONFIG[key] = value;
  });
};

// src/messaging/Messaging.ts
var Messaging_exports = {};
__export(Messaging_exports, {
  Message: () => Message,
  Messaging: () => Messaging
});
import { toExternalJSON } from "@signalwire/core";

// src/BaseNamespace.ts
import { uuid as uuid2 } from "@signalwire/core";

// src/utils/internals.ts
import { configureStore, getEventEmitter } from "@signalwire/core";

// src/Session.ts
import { BaseSession, SWCloseEvent } from "@signalwire/core";
import WebSocket from "ws";
var Session = class extends BaseSession {
  constructor() {
    super(...arguments);
    __publicField(this, "WebSocketConstructor", WebSocket);
    __publicField(this, "CloseEventConstructor", SWCloseEvent);
    __publicField(this, "agent", "@signalwire/nodejs/realtime-api/4.0.1");
  }
};

// src/utils/internals.ts
var setupInternals = (userOptions) => {
  const emitter = getEventEmitter();
  const baseOptions = __spreadProps(__spreadValues({}, userOptions), {
    emitter
  });
  const store = configureStore({
    userOptions: baseOptions,
    SessionConstructor: Session
  });
  return { store, emitter };
};
var prefixEvent = (prefix, event) => {
  if (typeof prefix !== "string" || typeof event !== "string")
    return event;
  return `${prefix}.${event}`;
};

// src/ListenSubscriber.ts
import { EventEmitter, getLogger as getLogger2, uuid } from "@signalwire/core";
var ListenSubscriber = class {
  constructor(options) {
    __publicField(this, "_sw");
    __publicField(this, "_client");
    __publicField(this, "_listenerMap", /* @__PURE__ */ new Map());
    __publicField(this, "_eventMap");
    __publicField(this, "_emitter", new EventEmitter());
    this._sw = options.swClient;
    this._client = options.swClient.client;
  }
  get emitter() {
    return this._emitter;
  }
  eventNames() {
    return this.emitter.eventNames();
  }
  emit(event, ...args) {
    return this.emitter.emit(event, ...args);
  }
  on(event, fn) {
    return this.emitter.on(event, fn);
  }
  once(event, fn) {
    return this.emitter.once(event, fn);
  }
  off(event, fn) {
    return this.emitter.off(event, fn);
  }
  listen(listeners) {
    return new Promise(async (resolve, reject) => {
      try {
        if (!listeners || (listeners == null ? void 0 : listeners.constructor) !== Object || Object.keys(listeners).length < 1) {
          throw new Error("Invalid params!");
        }
        const unsub = await this.subscribe(listeners);
        resolve(unsub);
      } catch (error) {
        reject(error);
      }
    });
  }
  async subscribe(listeners) {
    const _uuid = uuid();
    this._attachListeners(listeners);
    const unsub = () => {
      return new Promise(async (resolve, reject) => {
        try {
          this._detachListeners(listeners);
          this.removeFromListenerMap(_uuid);
          resolve();
        } catch (error) {
          reject(error);
        }
      });
    };
    this.addToListenerMap(_uuid, {
      listeners,
      unsub
    });
    return unsub;
  }
  _attachListeners(listeners) {
    const listenerKeys = Object.keys(listeners);
    listenerKeys.forEach((key) => {
      if (typeof listeners[key] === "function" && this._eventMap[key]) {
        this.on(this._eventMap[key], listeners[key]);
      } else {
        getLogger2().warn(`Unsupported listener: ${listeners[key]}`);
      }
    });
  }
  _detachListeners(listeners) {
    const listenerKeys = Object.keys(listeners);
    listenerKeys.forEach((key) => {
      if (typeof listeners[key] === "function" && this._eventMap[key]) {
        this.off(this._eventMap[key], listeners[key]);
      }
    });
  }
  addToListenerMap(id, value) {
    return this._listenerMap.set(id, value);
  }
  removeFromListenerMap(id) {
    return this._listenerMap.delete(id);
  }
};

// src/BaseNamespace.ts
var BaseNamespace = class extends ListenSubscriber {
  constructor(options) {
    super({ swClient: options });
  }
  addTopics(topics) {
    const executeParams = {
      method: "signalwire.receive",
      params: {
        contexts: topics
      }
    };
    return this._client.execute(executeParams);
  }
  removeTopics(topics) {
    const executeParams = {
      method: "signalwire.unreceive",
      params: {
        contexts: topics
      }
    };
    return this._client.execute(executeParams);
  }
  listen(listenOptions) {
    return new Promise(async (resolve, reject) => {
      try {
        const { topics } = listenOptions;
        if (!Array.isArray(topics) || (topics == null ? void 0 : topics.length) < 1) {
          throw new Error("Invalid options: topics should be an array with at least one topic!");
        }
        const unsub = await this.subscribe(listenOptions);
        resolve(unsub);
      } catch (error) {
        reject(error);
      }
    });
  }
  async subscribe(listenOptions) {
    const _a = listenOptions, { topics } = _a, listeners = __objRest(_a, ["topics"]);
    const _uuid = uuid2();
    this._attachListenersWithTopics(topics, listeners);
    await this.addTopics(topics);
    const unsub = () => {
      return new Promise(async (resolve, reject) => {
        try {
          this._detachListenersWithTopics(topics, listeners);
          this.removeFromListenerMap(_uuid);
          const topicsToRemove = topics.filter((topic) => !this.hasOtherListeners(_uuid, topic));
          if (topicsToRemove.length > 0) {
            await this.removeTopics(topicsToRemove);
          }
          resolve();
        } catch (error) {
          reject(error);
        }
      });
    };
    this.addToListenerMap(_uuid, {
      topics: /* @__PURE__ */ new Set([...topics]),
      listeners,
      unsub
    });
    return unsub;
  }
  _attachListenersWithTopics(topics, listeners) {
    const listenerKeys = Object.keys(listeners);
    topics.forEach((topic) => {
      listenerKeys.forEach((key) => {
        const _key = key;
        if (typeof listeners[_key] === "function" && this._eventMap[_key]) {
          const event = prefixEvent(topic, this._eventMap[_key]);
          this.on(event, listeners[_key]);
        }
      });
    });
  }
  _detachListenersWithTopics(topics, listeners) {
    const listenerKeys = Object.keys(listeners);
    topics.forEach((topic) => {
      listenerKeys.forEach((key) => {
        const _key = key;
        if (typeof listeners[_key] === "function" && this._eventMap[_key]) {
          const event = prefixEvent(topic, this._eventMap[_key]);
          this.off(event, listeners[_key]);
        }
      });
    });
  }
  hasOtherListeners(uuid7, topic) {
    var _a;
    for (const [key, listener] of this._listenerMap) {
      if (key !== uuid7 && ((_a = listener.topics) == null ? void 0 : _a.has(topic))) {
        return true;
      }
    }
    return false;
  }
  async unsubscribeAll() {
    await Promise.all([...this._listenerMap.values()].map(({ unsub }) => unsub()));
    this._listenerMap.clear();
  }
};

// src/messaging/workers/messagingWorker.ts
import {
  getLogger as getLogger3,
  sagaEffects
} from "@signalwire/core";
var messagingWorker = function* (options) {
  getLogger3().trace("messagingWorker started");
  const {
    channels: { swEventChannel },
    initialState
  } = options;
  const { messaging } = initialState;
  function* worker(action) {
    const { payload, type } = action;
    const message = new Message(payload);
    switch (type) {
      case "messaging.receive":
        messaging.emit(prefixEvent(payload.context, "message.received"), message);
        break;
      case "messaging.state":
        messaging.emit(prefixEvent(payload.context, "message.updated"), message);
        break;
      default:
        getLogger3().warn(`Unknown message event: "${action.type}"`);
        break;
    }
  }
  const isMessagingEvent = (action) => action.type.startsWith("messaging.");
  while (true) {
    const action = yield sagaEffects.take(swEventChannel, isMessagingEvent);
    yield sagaEffects.fork(worker, action);
  }
  getLogger3().trace("messagingWorker ended");
};

// src/messaging/Message.ts
var Message = class {
  constructor(options) {
    __publicField(this, "id");
    __publicField(this, "state");
    __publicField(this, "context");
    __publicField(this, "from");
    __publicField(this, "to");
    __publicField(this, "body");
    __publicField(this, "direction");
    __publicField(this, "media");
    __publicField(this, "segments");
    __publicField(this, "tags");
    __publicField(this, "reason");
    this.id = options.message_id;
    this.state = options.message_state;
    this.context = options.context;
    this.from = options.from_number;
    this.to = options.to_number;
    this.body = options.body;
    this.direction = options.direction;
    this.media = options.media || [];
    this.segments = options.segments;
    this.tags = options.tags || [];
    this.reason = options.reason;
  }
};

// src/messaging/Messaging.ts
var Messaging = class extends BaseNamespace {
  constructor(options) {
    super(options);
    __publicField(this, "_eventMap", {
      onMessageReceived: "message.received",
      onMessageUpdated: "message.updated"
    });
    this._client.runWorker("messagingWorker", {
      worker: messagingWorker,
      initialState: {
        messaging: this
      }
    });
  }
  async send(params) {
    const _a = params, { from = "", to = "" } = _a, rest = __objRest(_a, ["from", "to"]);
    const sendParams = __spreadProps(__spreadValues({}, rest), {
      from_number: from,
      to_number: to
    });
    try {
      const response = await this._client.execute({
        method: "messaging.send",
        params: sendParams
      });
      return toExternalJSON(response);
    } catch (error) {
      this._client.logger.error("Error sending message", error);
      throw error;
    }
  }
};

// src/chat/Chat.ts
var Chat_exports = {};
__export(Chat_exports, {
  Chat: () => Chat,
  ChatMember: () => ChatMember3,
  ChatMessage: () => ChatMessage3
});
import {
  Chat as ChatCore
} from "@signalwire/core";

// src/chat/BaseChat.ts
import {
  uuid as uuid3
} from "@signalwire/core";
var BaseChat = class extends BaseNamespace {
  listen(listenOptions) {
    return new Promise(async (resolve, reject) => {
      try {
        const { channels } = listenOptions;
        if (!Array.isArray(channels) || (channels == null ? void 0 : channels.length) < 1) {
          throw new Error("Invalid options: channels should be an array with at least one channel!");
        }
        const unsub = await this.subscribe(listenOptions);
        resolve(unsub);
      } catch (error) {
        reject(error);
      }
    });
  }
  async subscribe(listenOptions) {
    const _a = listenOptions, { channels } = _a, listeners = __objRest(_a, ["channels"]);
    const _uuid = uuid3();
    this._attachListenersWithTopics(channels, listeners);
    const listenerKeys = Object.keys(listeners);
    const events = [];
    listenerKeys.forEach((key) => {
      const _key = key;
      if (this._eventMap[_key])
        events.push(this._eventMap[_key]);
    });
    await this.addChannels(channels, events);
    const unsub = () => {
      return new Promise(async (resolve, reject) => {
        try {
          const channelsToRemove = channels.filter((channel) => !this.hasOtherListeners(_uuid, channel));
          if (channelsToRemove.length > 0) {
            await this.removeChannels(channelsToRemove);
          }
          this._detachListenersWithTopics(channels, listeners);
          this.removeFromListenerMap(_uuid);
          resolve();
        } catch (error) {
          reject(error);
        }
      });
    };
    this.addToListenerMap(_uuid, {
      topics: /* @__PURE__ */ new Set([...channels]),
      listeners,
      unsub
    });
    return unsub;
  }
  addChannels(channels, events) {
    return new Promise(async (resolve, reject) => {
      try {
        const execParams = {
          method: "chat.subscribe",
          params: {
            channels: channels.map((channel) => ({
              name: channel
            })),
            events
          }
        };
        await this._client.execute(execParams);
        resolve(void 0);
      } catch (error) {
        reject(error);
      }
    });
  }
  removeChannels(channels) {
    return new Promise(async (resolve, reject) => {
      try {
        const execParams = {
          method: "chat.unsubscribe",
          params: {
            channels: channels.map((channel) => ({
              name: channel
            }))
          }
        };
        await this._client.execute(execParams);
        resolve(void 0);
      } catch (error) {
        reject(error);
      }
    });
  }
  publish(params) {
    return new Promise((resolve, reject) => {
      try {
        const publish = this._client.execute({
          method: "chat.publish",
          params
        });
        resolve(publish);
      } catch (error) {
        reject(error);
      }
    });
  }
};

// src/chat/workers/chatWorker.ts
import {
  sagaEffects as sagaEffects2,
  getLogger as getLogger4,
  toExternalJSON as toExternalJSON2,
  ChatMessage,
  ChatMember
} from "@signalwire/core";
var chatWorker = function* (options) {
  getLogger4().trace("chatWorker started");
  const {
    channels: { swEventChannel },
    initialState
  } = options;
  const { chat } = initialState;
  function* worker(action) {
    const { type, payload } = action;
    switch (type) {
      case "chat.channel.message": {
        const { channel, message } = payload;
        const externalJSON = toExternalJSON2(__spreadProps(__spreadValues({}, message), {
          channel
        }));
        const chatMessage = new ChatMessage(externalJSON);
        chat.emit(prefixEvent(channel, "chat.message"), chatMessage);
        break;
      }
      case "chat.member.joined":
      case "chat.member.updated":
      case "chat.member.left": {
        const { member, channel } = payload;
        const externalJSON = toExternalJSON2(member);
        const chatMember = new ChatMember(externalJSON);
        chat.emit(prefixEvent(channel, type), chatMember);
        break;
      }
      default:
        getLogger4().warn(`Unknown chat event: "${type}"`, payload);
        break;
    }
  }
  const isChatEvent = (action) => action.type.startsWith("chat.");
  while (true) {
    const action = yield sagaEffects2.take(swEventChannel, isChatEvent);
    yield sagaEffects2.fork(worker, action);
  }
  getLogger4().trace("chatWorker ended");
};

// src/chat/Chat.ts
import { ChatMember as ChatMember3, ChatMessage as ChatMessage3 } from "@signalwire/core";
var Chat = class extends ChatCore.applyCommonMethods(BaseChat) {
  constructor(options) {
    super(options);
    __publicField(this, "_eventMap", {
      onMessageReceived: "chat.message",
      onMemberJoined: "chat.member.joined",
      onMemberUpdated: "chat.member.updated",
      onMemberLeft: "chat.member.left"
    });
    this._client.runWorker("chatWorker", {
      worker: chatWorker,
      initialState: {
        chat: this
      }
    });
  }
};

// src/pubSub/PubSub.ts
var PubSub_exports = {};
__export(PubSub_exports, {
  PubSub: () => PubSub
});

// src/pubSub/workers/pubSubWorker.ts
import {
  sagaEffects as sagaEffects3,
  getLogger as getLogger5,
  PubSubMessage,
  toExternalJSON as toExternalJSON3
} from "@signalwire/core";
var pubSubWorker = function* (options) {
  getLogger5().trace("pubSubWorker started");
  const {
    channels: { swEventChannel },
    initialState
  } = options;
  const { pubSub } = initialState;
  function* worker(action) {
    const { type, payload } = action;
    switch (type) {
      case "chat.channel.message": {
        const {
          channel,
          message: _a
        } = payload, _b = _a, { member } = _b, restMessage = __objRest(_b, ["member"]);
        const externalJSON = toExternalJSON3(__spreadProps(__spreadValues({}, restMessage), {
          channel
        }));
        const pubSubMessage = new PubSubMessage(externalJSON);
        pubSub.emit(prefixEvent(channel, "chat.message"), pubSubMessage);
        break;
      }
      default:
        getLogger5().warn(`Unknown pubsub event: "${type}"`, payload);
        break;
    }
  }
  const isPubSubEvent = (action) => action.type.startsWith("chat.");
  while (true) {
    const action = yield sagaEffects3.take(swEventChannel, isPubSubEvent);
    yield sagaEffects3.fork(worker, action);
  }
  getLogger5().trace("pubSubWorker ended");
};

// src/pubSub/PubSub.ts
var PubSub = class extends BaseChat {
  constructor(options) {
    super(options);
    __publicField(this, "_eventMap", {
      onMessageReceived: "chat.message"
    });
    this._client.runWorker("pubSubWorker", {
      worker: pubSubWorker,
      initialState: {
        pubSub: this
      }
    });
  }
};

// src/task/Task.ts
var Task_exports = {};
__export(Task_exports, {
  PATH: () => PATH,
  Task: () => Task
});
import { request } from "https";
import {
  getLogger as getLogger7
} from "@signalwire/core";

// src/task/workers/taskWorker.ts
import {
  getLogger as getLogger6,
  sagaEffects as sagaEffects4
} from "@signalwire/core";
var taskWorker = function* (options) {
  getLogger6().trace("taskWorker started");
  const {
    channels: { swEventChannel },
    initialState
  } = options;
  const { task } = initialState;
  function* worker(action) {
    const { context } = action.payload;
    task.emit(prefixEvent(context, "task.received"), action.payload.message);
  }
  const isTaskEvent = (action) => action.type === "queuing.relay.tasks";
  while (true) {
    const action = yield sagaEffects4.take(swEventChannel, isTaskEvent);
    yield sagaEffects4.fork(worker, action);
  }
  getLogger6().trace("taskWorker ended");
};

// src/task/Task.ts
var PATH = "/api/relay/rest/tasks";
var HOST = "relay.signalwire.com";
var Task = class extends BaseNamespace {
  constructor(options) {
    super(options);
    __publicField(this, "_eventMap", {
      onTaskReceived: "task.received"
    });
    this._client.runWorker("taskWorker", {
      worker: taskWorker,
      initialState: {
        task: this
      }
    });
  }
  send({
    topic,
    message
  }) {
    const { userOptions } = this._sw;
    if (!userOptions.project || !userOptions.token) {
      throw new Error("Invalid options: project and token are required!");
    }
    return new Promise((resolve, reject) => {
      var _a;
      try {
        const Authorization = `Basic ${Buffer.from(`${userOptions.project}:${userOptions.token}`).toString("base64")}`;
        const data = JSON.stringify({ context: topic, message });
        const options = {
          host: (_a = userOptions.host) != null ? _a : HOST,
          port: 443,
          method: "POST",
          path: PATH,
          headers: {
            Authorization,
            "Content-Type": "application/json",
            "Content-Length": data.length
          }
        };
        getLogger7().debug("Task send -", data);
        const req = request(options, ({ statusCode }) => {
          statusCode === 204 ? resolve() : reject();
        });
        req.on("error", reject);
        req.write(data);
        req.end();
      } catch (error) {
        reject(error);
      }
    });
  }
};

// src/voice/Voice.ts
var Voice_exports = {};
__export(Voice_exports, {
  Call: () => Call,
  DeviceBuilder: () => DeviceBuilder,
  Playlist: () => Playlist,
  Voice: () => Voice
});
import { toExternalJSON as toExternalJSON5, uuid as uuid5 } from "@signalwire/core";

// src/voice/workers/voiceCallReceiveWorker.ts
import {
  getLogger as getLogger8,
  sagaEffects as sagaEffects5
} from "@signalwire/core";

// src/voice/Call.ts
import {
  uuid as uuid4,
  toSnakeCaseKeys as toSnakeCaseKeys2,
  toExternalJSON as toExternalJSON4
} from "@signalwire/core";

// src/voice/utils.ts
import { toSnakeCaseKeys } from "@signalwire/core";
var toInternalDevice = (device) => {
  switch (device.type) {
    case "sip": {
      const _a = device, { type } = _a, params = __objRest(_a, ["type"]);
      return {
        type,
        params: toSnakeCaseKeys(params)
      };
    }
    case "phone": {
      const _b = device, { to, from, type } = _b, rest = __objRest(_b, ["to", "from", "type"]);
      return {
        type,
        params: toSnakeCaseKeys(__spreadProps(__spreadValues({}, rest), {
          to_number: to,
          from_number: from
        }))
      };
    }
  }
  return device;
};
var toInternalDevices = (params, internalDevices = []) => {
  params.forEach((dev, index) => {
    if (Array.isArray(dev)) {
      internalDevices[index] = toInternalDevices(dev);
    } else {
      internalDevices[index] = toInternalDevice(dev);
    }
  });
  return internalDevices;
};
var toInternalPlay = (media) => {
  const _a = media, { type } = _a, params = __objRest(_a, ["type"]);
  return { type, params };
};
var toInternalPlayParams = (params, result = []) => {
  params.forEach((media, index) => {
    if (Array.isArray(media)) {
      result[index] = toInternalPlayParams(media);
    } else {
      result[index] = toInternalPlay(media);
    }
  });
  return result;
};

// src/voice/Playlist.ts
var Playlist = class {
  constructor(params = {}) {
    this.params = params;
    __publicField(this, "_media", []);
  }
  get volume() {
    var _a;
    return (_a = this.params) == null ? void 0 : _a.volume;
  }
  get media() {
    return this._media;
  }
  add(params) {
    this._media.push(params);
    return this;
  }
  static Audio(params) {
    return __spreadValues({ type: "audio" }, params);
  }
  static TTS(params) {
    return __spreadValues({ type: "tts" }, params);
  }
  static Silence(params) {
    return __spreadValues({ type: "silence" }, params);
  }
  static Ringtone(params) {
    return __spreadValues({ type: "ringtone" }, params);
  }
};

// src/voice/CallPlayback/CallPlayback.ts
var ENDED_STATES = ["finished", "error"];
var CallPlayback = class extends ListenSubscriber {
  constructor(options) {
    super({ swClient: options.call._sw });
    __publicField(this, "_paused");
    __publicField(this, "_volume");
    __publicField(this, "_payload");
    __publicField(this, "_eventMap", {
      onStarted: "playback.started",
      onUpdated: "playback.updated",
      onFailed: "playback.failed",
      onEnded: "playback.ended"
    });
    this._payload = options.payload;
    this._paused = false;
    if (options.listeners) {
      this.listen(options.listeners);
    }
  }
  get id() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.control_id.split(".")[0];
  }
  get volume() {
    return this._volume;
  }
  get callId() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.call_id;
  }
  get nodeId() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.node_id;
  }
  get controlId() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.control_id;
  }
  get state() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.state;
  }
  get hasEnded() {
    if (ENDED_STATES.includes(this.state)) {
      return true;
    }
    return false;
  }
  setPayload(payload) {
    this._payload = payload;
  }
  async pause() {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "calling.play.pause",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId
      }
    });
    return this;
  }
  async resume() {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "calling.play.resume",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId
      }
    });
    return this;
  }
  async stop() {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "calling.play.stop",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId
      }
    });
    return this;
  }
  async setVolume(volume) {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    this._volume = volume;
    await this._client.execute({
      method: "calling.play.volume",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId,
        volume
      }
    });
    return this;
  }
  waitForEnded() {
    return this.ended();
  }
  ended() {
    return new Promise((resolve) => {
      const handler = () => {
        this.off("playback.ended", handler);
        this.off("playback.failed", handler);
        resolve(this);
      };
      this.once("playback.ended", handler);
      this.once("playback.failed", handler);
      if (this.hasEnded) {
        handler();
      }
    });
  }
};

// src/decoratePromise.ts
function decoratePromise(options) {
  const { promise: innerPromise, namespace, methods: methods10, getters: getters10 } = options;
  const promise = new Promise((resolve, reject) => {
    const endedHandler = (instance) => {
      this.off(`${namespace}.ended`, endedHandler);
      resolve(instance);
    };
    this.once(`${namespace}.ended`, endedHandler);
    innerPromise.catch((error) => {
      this.off(`${namespace}.ended`, endedHandler);
      reject(error);
    });
  });
  Object.defineProperties(promise, __spreadValues(__spreadValues({
    onStarted: {
      value: function() {
        return new Promise((resolve, reject) => {
          promise.catch(reject);
          innerPromise.then(resolve).catch(reject);
        });
      },
      enumerable: true
    },
    onEnded: {
      value: async function() {
        const instance = await this.onStarted();
        if (instance.hasEnded) {
          return this;
        }
        return await promise;
      },
      enumerable: true
    },
    listen: {
      value: async function(...args) {
        const instance = await this.onStarted();
        return instance.listen(...args);
      },
      enumerable: true
    }
  }, methods10.reduce((acc, method) => {
    acc[method] = {
      value: async function(...args) {
        const instance = await this.onStarted();
        return instance[method](...args);
      },
      enumerable: true
    };
    return acc;
  }, {})), getters10.reduce((acc, gettter) => {
    acc[gettter] = {
      get: async function() {
        const instance = await this.onStarted();
        return instance[gettter];
      },
      enumerable: true
    };
    return acc;
  }, {})));
  return promise;
}

// src/voice/CallPlayback/decoratePlaybackPromise.ts
var getters = [
  "id",
  "volume",
  "callId",
  "nodeId",
  "controlId",
  "state"
];
var methods = ["pause", "resume", "stop", "setVolume", "ended"];
function decoratePlaybackPromise(innerPromise) {
  return decoratePromise.call(this, {
    promise: innerPromise,
    namespace: "playback",
    methods,
    getters
  });
}

// src/voice/CallRecording/CallRecording.ts
var ENDED_STATES2 = ["finished", "no_input"];
var CallRecording = class extends ListenSubscriber {
  constructor(options) {
    super({ swClient: options.call._sw });
    __publicField(this, "_paused");
    __publicField(this, "_payload");
    __publicField(this, "_eventMap", {
      onStarted: "recording.started",
      onUpdated: "recording.updated",
      onFailed: "recording.failed",
      onEnded: "recording.ended"
    });
    this._payload = options.payload;
    this._paused = false;
    if (options.listeners) {
      this.listen(options.listeners);
    }
  }
  get id() {
    return this._payload.control_id;
  }
  get callId() {
    return this._payload.call_id;
  }
  get nodeId() {
    return this._payload.node_id;
  }
  get controlId() {
    return this._payload.control_id;
  }
  get state() {
    return this._payload.state;
  }
  get url() {
    return this._payload.url;
  }
  get size() {
    return this._payload.size;
  }
  get duration() {
    return this._payload.duration;
  }
  get record() {
    return this._payload.record;
  }
  get hasEnded() {
    if (ENDED_STATES2.includes(this.state)) {
      return true;
    }
    return false;
  }
  setPayload(payload) {
    this._payload = payload;
  }
  async pause(params) {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    const { behavior = "silence" } = params || {};
    await this._client.execute({
      method: "calling.record.pause",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId,
        behavior
      }
    });
    return this;
  }
  async resume() {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "calling.record.resume",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId
      }
    });
    return this;
  }
  async stop() {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "calling.record.stop",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId
      }
    });
    return this;
  }
  ended() {
    return new Promise((resolve) => {
      const handler = () => {
        this.off("recording.ended", handler);
        this.off("recording.failed", handler);
        resolve(this);
      };
      this.once("recording.ended", handler);
      this.once("recording.failed", handler);
      if (this.hasEnded) {
        handler();
      }
    });
  }
};

// src/voice/CallRecording/decorateRecordingPromise.ts
var getters2 = [
  "id",
  "callId",
  "nodeId",
  "controlId",
  "state",
  "url",
  "size",
  "duration",
  "record"
];
var methods2 = ["pause", "resume", "stop", "ended"];
function decorateRecordingPromise(innerPromise) {
  return decoratePromise.call(this, {
    promise: innerPromise,
    namespace: "recording",
    methods: methods2,
    getters: getters2
  });
}

// src/voice/CallPrompt/CallPrompt.ts
var ENDED_STATES3 = [
  "no_input",
  "error",
  "no_match",
  "digit",
  "speech"
];
var CallPrompt = class extends ListenSubscriber {
  constructor(options) {
    super({ swClient: options.call._sw });
    __publicField(this, "_payload");
    __publicField(this, "_eventMap", {
      onStarted: "prompt.started",
      onUpdated: "prompt.updated",
      onFailed: "prompt.failed",
      onEnded: "prompt.ended"
    });
    this._payload = options.payload;
    if (options.listeners) {
      this.listen(options.listeners);
    }
  }
  get id() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.control_id.split(".")[0];
  }
  get controlId() {
    return this._payload.control_id;
  }
  get callId() {
    return this._payload.call_id;
  }
  get nodeId() {
    return this._payload.node_id;
  }
  get result() {
    return this._payload.result;
  }
  get type() {
    var _a;
    return (_a = this.result) == null ? void 0 : _a.type;
  }
  get reason() {
    return this.type;
  }
  get digits() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "digit") {
      return this.result.params.digits;
    }
    return void 0;
  }
  get speech() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "speech") {
      return this.result.params.text;
    }
    return void 0;
  }
  get terminator() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "digit") {
      return this.result.params.terminator;
    }
    return void 0;
  }
  get text() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "speech") {
      return this.result.params.text;
    }
    return void 0;
  }
  get confidence() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "speech") {
      return this.result.params.confidence;
    }
    return void 0;
  }
  get hasEnded() {
    var _a;
    if (ENDED_STATES3.includes((_a = this.result) == null ? void 0 : _a.type)) {
      return true;
    }
    return false;
  }
  setPayload(payload) {
    this._payload = payload;
  }
  async stop() {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "calling.play_and_collect.stop",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId
      }
    });
    return this;
  }
  async setVolume(volume) {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "calling.play_and_collect.volume",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId,
        volume
      }
    });
    return this;
  }
  waitForResult() {
    return this.ended();
  }
  ended() {
    return new Promise((resolve) => {
      const handler = () => {
        this.off("prompt.ended", handler);
        this.off("prompt.failed", handler);
        resolve(this);
      };
      this.once("prompt.ended", handler);
      this.once("prompt.failed", handler);
      if (this.hasEnded) {
        handler();
      }
    });
  }
};

// src/voice/CallPrompt/decoratePromptPromise.ts
var getters3 = [
  "id",
  "controlId",
  "callId",
  "nodeId",
  "result",
  "type",
  "reason",
  "digits",
  "speech",
  "terminator",
  "text",
  "confidence"
];
var methods3 = ["stop", "setVolume", "ended"];
function decoratePromptPromise(innerPromise) {
  return decoratePromise.call(this, {
    promise: innerPromise,
    namespace: "prompt",
    methods: methods3,
    getters: getters3
  });
}

// src/voice/CallCollect/CallCollect.ts
var ENDED_STATES4 = [
  "error",
  "no_input",
  "no_match",
  "digit",
  "speech"
];
var CallCollect = class extends ListenSubscriber {
  constructor(options) {
    super({ swClient: options.call._sw });
    __publicField(this, "_payload");
    __publicField(this, "_eventMap", {
      onStarted: "collect.started",
      onInputStarted: "collect.startOfInput",
      onUpdated: "collect.updated",
      onFailed: "collect.failed",
      onEnded: "collect.ended"
    });
    this._payload = options.payload;
    if (options.listeners) {
      this.listen(options.listeners);
    }
  }
  get id() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.control_id.split(".")[0];
  }
  get controlId() {
    return this._payload.control_id;
  }
  get callId() {
    return this._payload.call_id;
  }
  get nodeId() {
    return this._payload.node_id;
  }
  get result() {
    return this._payload.result;
  }
  get type() {
    var _a;
    return (_a = this.result) == null ? void 0 : _a.type;
  }
  get reason() {
    return this.type;
  }
  get digits() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "digit") {
      return this.result.params.digits;
    }
    return void 0;
  }
  get speech() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "speech") {
      return this.result.params.text;
    }
    return void 0;
  }
  get terminator() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "digit") {
      return this.result.params.terminator;
    }
    return void 0;
  }
  get text() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "speech") {
      return this.result.params.text;
    }
    return void 0;
  }
  get confidence() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "speech") {
      return this.result.params.confidence;
    }
    return void 0;
  }
  get state() {
    return this._payload.state;
  }
  get final() {
    return this._payload.final;
  }
  get hasEnded() {
    var _a;
    if (this.state !== "collecting" && this.final !== false && ENDED_STATES4.includes((_a = this.result) == null ? void 0 : _a.type)) {
      return true;
    }
    return false;
  }
  setPayload(payload) {
    this._payload = payload;
  }
  async stop() {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "calling.collect.stop",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId
      }
    });
    return this;
  }
  async startInputTimers() {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "calling.collect.start_input_timers",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId
      }
    });
    return this;
  }
  ended() {
    return new Promise((resolve) => {
      const handler = () => {
        this.off("collect.ended", handler);
        this.off("collect.failed", handler);
        resolve(this);
      };
      this.once("collect.ended", handler);
      this.once("collect.failed", handler);
      if (this.hasEnded) {
        handler();
      }
    });
  }
};

// src/voice/CallCollect/decorateCollectPromise.ts
var getters4 = [
  "id",
  "callId",
  "nodeId",
  "controlId",
  "result",
  "type",
  "reason",
  "digits",
  "speech",
  "terminator",
  "text",
  "confidence"
];
var methods4 = ["stop", "startInputTimers", "ended"];
function decorateCollectPromise(innerPromise) {
  return decoratePromise.call(this, {
    promise: innerPromise,
    namespace: "collect",
    methods: methods4,
    getters: getters4
  });
}

// src/voice/CallTap/CallTap.ts
var ENDED_STATES5 = ["finished"];
var CallTap = class extends ListenSubscriber {
  constructor(options) {
    super({ swClient: options.call._sw });
    __publicField(this, "_payload");
    __publicField(this, "_eventMap", {
      onStarted: "tap.started",
      onEnded: "tap.ended"
    });
    this._payload = options.payload;
    if (options.listeners) {
      this.listen(options.listeners);
    }
  }
  get id() {
    return this._payload.control_id;
  }
  get controlId() {
    return this._payload.control_id;
  }
  get nodeId() {
    return this._payload.node_id;
  }
  get callId() {
    return this._payload.call_id;
  }
  get state() {
    return this._payload.state;
  }
  get hasEnded() {
    if (ENDED_STATES5.includes(this.state)) {
      return true;
    }
    return false;
  }
  setPayload(payload) {
    this._payload = payload;
  }
  async stop() {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "calling.tap.stop",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId
      }
    });
    return this;
  }
  ended() {
    return new Promise((resolve) => {
      const handler = () => {
        this.off("tap.ended", handler);
        resolve(this);
      };
      this.once("tap.ended", handler);
      if (this.hasEnded) {
        handler();
      }
    });
  }
};

// src/voice/CallTap/decorateTapPromise.ts
var getters5 = ["id", "callId", "nodeId", "controlId", "state"];
var methods5 = ["stop", "ended"];
function decorateTapPromise(innerPromise) {
  return decoratePromise.call(this, {
    promise: innerPromise,
    namespace: "tap",
    methods: methods5,
    getters: getters5
  });
}

// src/voice/DeviceBuilder.ts
var DeviceBuilder = class {
  constructor() {
    __publicField(this, "_devices", []);
  }
  get devices() {
    return this._devices;
  }
  add(params) {
    if (Array.isArray(params)) {
      this._devices.push(params);
    } else {
      this._devices.push([params]);
    }
    return this;
  }
  static Phone(params) {
    return __spreadValues({ type: "phone" }, params);
  }
  static Sip(params) {
    return __spreadValues({ type: "sip" }, params);
  }
};

// src/voice/CallDetect/CallDetect.ts
var ENDED_STATES6 = ["finished", "error"];
var CallDetect = class extends ListenSubscriber {
  constructor(options) {
    super({ swClient: options.call._sw });
    __publicField(this, "_waitForBeep");
    __publicField(this, "_result", "UNKNOWN");
    __publicField(this, "_payload");
    __publicField(this, "_eventMap", {
      onStarted: "detect.started",
      onUpdated: "detect.updated",
      onEnded: "detect.ended"
    });
    this._payload = options.payload;
    this._waitForBeep = options.payload.waitForBeep;
    if (options.listeners) {
      this.listen(options.listeners);
    }
  }
  get id() {
    return this._payload.control_id;
  }
  get controlId() {
    return this._payload.control_id;
  }
  get callId() {
    return this._payload.call_id;
  }
  get nodeId() {
    return this._payload.node_id;
  }
  get detect() {
    return this._payload.detect;
  }
  get type() {
    var _a;
    return (_a = this == null ? void 0 : this.detect) == null ? void 0 : _a.type;
  }
  get result() {
    return this._result;
  }
  get waitForBeep() {
    return this._waitForBeep;
  }
  get beep() {
    var _a;
    if (((_a = this.detect) == null ? void 0 : _a.params.event) === "MACHINE") {
      return Boolean(this.detect.params.beep);
    }
    return void 0;
  }
  get hasEnded() {
    const lastEvent = this._lastEvent();
    if (lastEvent && ENDED_STATES6.includes(lastEvent)) {
      return true;
    }
    return false;
  }
  setPayload(payload) {
    this._payload = payload;
    const lastEvent = this._lastEvent();
    if (lastEvent && lastEvent !== "finished") {
      this._result = lastEvent;
    }
  }
  async stop() {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "calling.detect.stop",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId
      }
    });
    return this;
  }
  waitForResult() {
    return this.ended();
  }
  ended() {
    const lastEvent = this._lastEvent();
    if (lastEvent && ENDED_STATES6.includes(lastEvent)) {
      return Promise.resolve(this);
    }
    return new Promise((resolve) => {
      const handler = () => {
        this.off("detect.ended", handler);
        resolve(this);
      };
      this.once("detect.ended", handler);
    });
  }
  _lastEvent() {
    var _a;
    return (_a = this.detect) == null ? void 0 : _a.params.event;
  }
};

// src/voice/CallDetect/decorateDetectPromise.ts
var getters6 = [
  "id",
  "callId",
  "nodeId",
  "controlId",
  "detect",
  "type",
  "result",
  "waitForBeep",
  "beep"
];
var methods6 = ["stop", "ended"];
function decorateDetectPromise(innerPromise) {
  return decoratePromise.call(this, {
    promise: innerPromise,
    namespace: "detect",
    methods: methods6,
    getters: getters6
  });
}

// src/voice/Call.ts
var Call = class extends ListenSubscriber {
  constructor(options) {
    var _a;
    super({ swClient: options.voice._sw });
    __publicField(this, "_voice");
    __publicField(this, "_context");
    __publicField(this, "_peer");
    __publicField(this, "_payload");
    __publicField(this, "_connectPayload");
    __publicField(this, "_eventMap", {
      onStateChanged: "call.state",
      onPlaybackStarted: "playback.started",
      onPlaybackUpdated: "playback.updated",
      onPlaybackFailed: "playback.failed",
      onPlaybackEnded: "playback.ended",
      onRecordingStarted: "recording.started",
      onRecordingUpdated: "recording.updated",
      onRecordingFailed: "recording.failed",
      onRecordingEnded: "recording.ended",
      onPromptStarted: "prompt.started",
      onPromptUpdated: "prompt.updated",
      onPromptFailed: "prompt.failed",
      onPromptEnded: "prompt.ended",
      onCollectStarted: "collect.started",
      onCollectInputStarted: "collect.startOfInput",
      onCollectUpdated: "collect.updated",
      onCollectFailed: "collect.failed",
      onCollectEnded: "collect.ended",
      onTapStarted: "tap.started",
      onTapEnded: "tap.ended",
      onDetectStarted: "detect.started",
      onDetectUpdated: "detect.updated",
      onDetectEnded: "detect.ended"
    });
    __publicField(this, "detectAnsweringMachine", this.amd);
    this._voice = options.voice;
    this._payload = options.payload;
    this._context = (_a = options.payload) == null ? void 0 : _a.context;
    this._connectPayload = options.connectPayload;
    if (options.listeners) {
      this.listen(options.listeners);
    }
  }
  get id() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.call_id;
  }
  get callId() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.call_id;
  }
  get state() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.call_state;
  }
  get callState() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.call_state;
  }
  get tag() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.tag;
  }
  get nodeId() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.node_id;
  }
  get device() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.device;
  }
  get type() {
    var _a, _b;
    return (_b = (_a = this.device) == null ? void 0 : _a.type) != null ? _b : "";
  }
  get from() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (this.type === "phone") {
      return (_e = ((_b = (_a = this.device) == null ? void 0 : _a.params) == null ? void 0 : _b.from_number) || ((_d = (_c = this.device) == null ? void 0 : _c.params) == null ? void 0 : _d.fromNumber)) != null ? _e : "";
    }
    return (_h = (_g = (_f = this.device) == null ? void 0 : _f.params) == null ? void 0 : _g.from) != null ? _h : "";
  }
  get to() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (this.type === "phone") {
      return (_e = ((_b = (_a = this.device) == null ? void 0 : _a.params) == null ? void 0 : _b.to_number) || ((_d = (_c = this.device) == null ? void 0 : _c.params) == null ? void 0 : _d.toNumber)) != null ? _e : "";
    }
    return (_h = (_g = (_f = this.device) == null ? void 0 : _f.params) == null ? void 0 : _g.to) != null ? _h : "";
  }
  get headers() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.device) == null ? void 0 : _a.params) == null ? void 0 : _b.headers) != null ? _c : [];
  }
  get active() {
    return this.state === "answered";
  }
  get connected() {
    return this.connectState === "connected";
  }
  get direction() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.direction;
  }
  get context() {
    return this._context;
  }
  get connectState() {
    var _a;
    return (_a = this._connectPayload) == null ? void 0 : _a.connect_state;
  }
  get peer() {
    return this._peer;
  }
  set peer(callInstance) {
    this._peer = callInstance;
  }
  setPayload(payload) {
    this._payload = payload;
  }
  setConnectPayload(payload) {
    this._connectPayload = payload;
  }
  hangup(reason = "hangup") {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call hangup() on a call that hasn't been established.`));
      }
      this.on("call.state", (params) => {
        if (params.callState === "ended") {
          resolve();
        }
      });
      this._client.execute({
        method: "calling.end",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          reason
        }
      }).catch((e) => {
        reject(e);
      });
    });
  }
  pass() {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call pass() on a call without callId.`));
      }
      this._client.execute({
        method: "calling.pass",
        params: {
          node_id: this.nodeId,
          call_id: this.callId
        }
      }).then(() => {
        resolve();
      }).catch((e) => {
        reject(e);
      });
    });
  }
  answer() {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call answer() on a call without callId.`));
      }
      this.on("call.state", (params) => {
        if (params.state === "answered") {
          resolve(this);
        } else if (params.state === "ended") {
          reject(new Error("Failed to answer the call."));
        }
      });
      this._client.execute({
        method: "calling.answer",
        params: {
          node_id: this.nodeId,
          call_id: this.callId
        }
      }).catch((e) => {
        reject(e);
      });
    });
  }
  play(params) {
    const promise = new Promise((resolve, reject) => {
      const { playlist, listen } = params;
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call play() on a call not established yet.`));
      }
      const resolveHandler = (callPlayback) => {
        this.off("playback.failed", rejectHandler);
        resolve(callPlayback);
      };
      const rejectHandler = (callPlayback) => {
        this.off("playback.started", resolveHandler);
        reject(callPlayback);
      };
      this.once("playback.started", resolveHandler);
      this.once("playback.failed", rejectHandler);
      const controlId = uuid4();
      this._client.runWorker("voiceCallPlayWorker", {
        worker: voiceCallPlayWorker,
        initialState: {
          controlId,
          listeners: listen
        }
      });
      this._client.execute({
        method: "calling.play",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          volume: playlist.volume,
          play: toInternalPlayParams(playlist.media)
        }
      }).then(() => {
      }).catch((e) => {
        this.off("playback.started", resolveHandler);
        this.off("playback.failed", rejectHandler);
        reject(e);
      });
    });
    return decoratePlaybackPromise.call(this, promise);
  }
  playAudio(params) {
    const _a = params, { volume, listen } = _a, rest = __objRest(_a, ["volume", "listen"]);
    const playlist = new Playlist({ volume }).add(Playlist.Audio(rest));
    return this.play({ playlist, listen });
  }
  playSilence(params) {
    const _a = params, { listen } = _a, rest = __objRest(_a, ["listen"]);
    const playlist = new Playlist().add(Playlist.Silence(rest));
    return this.play({ playlist, listen });
  }
  playRingtone(params) {
    const _a = params, { volume, listen } = _a, rest = __objRest(_a, ["volume", "listen"]);
    const playlist = new Playlist({ volume }).add(Playlist.Ringtone(rest));
    return this.play({ playlist, listen });
  }
  playTTS(params) {
    const _a = params, { volume, listen } = _a, rest = __objRest(_a, ["volume", "listen"]);
    const playlist = new Playlist({ volume }).add(Playlist.TTS(rest));
    return this.play({ playlist, listen });
  }
  record(params) {
    const promise = new Promise((resolve, reject) => {
      const { audio, listen } = params;
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call record() on a call not established yet.`));
      }
      const resolveHandler = (callRecording) => {
        resolve(callRecording);
      };
      const rejectHandler = (callRecording) => {
        this.off("recording.started", resolveHandler);
        reject(callRecording);
      };
      this.once("recording.started", resolveHandler);
      this.once("recording.failed", rejectHandler);
      const controlId = uuid4();
      const record = toSnakeCaseKeys2({ audio });
      this._client.runWorker("voiceCallRecordWorker", {
        worker: voiceCallRecordWorker,
        initialState: {
          controlId,
          listeners: listen
        }
      });
      this._client.execute({
        method: "calling.record",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          record
        }
      }).then(() => {
      }).catch((e) => {
        this.off("recording.started", resolveHandler);
        this.off("recording.failed", rejectHandler);
        reject(e);
      });
    });
    return decorateRecordingPromise.call(this, promise);
  }
  recordAudio(params = {}) {
    const _a = params, { listen } = _a, rest = __objRest(_a, ["listen"]);
    return this.record({
      audio: rest,
      listen
    });
  }
  prompt(params) {
    const promise = new Promise((resolve, reject) => {
      const _a = params, { listen } = _a, rest = __objRest(_a, ["listen"]);
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call record() on a call not established yet.`));
      }
      if (!params.playlist) {
        reject(new Error(`Missing 'playlist' params.`));
      }
      const controlId = `${uuid4()}.prompt`;
      const { volume, media } = params.playlist;
      const { initial_timeout, digits, speech } = toSnakeCaseKeys2(rest);
      const collect = {
        initial_timeout,
        digits,
        speech
      };
      this._client.runWorker("voiceCallPlayWorker", {
        worker: voiceCallPlayWorker,
        initialState: {
          controlId
        }
      });
      this._client.runWorker("voiceCallCollectWorker", {
        worker: voiceCallCollectWorker,
        initialState: {
          controlId
        }
      });
      this._client.execute({
        method: "calling.play_and_collect",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          volume,
          play: toInternalPlayParams(media),
          collect
        }
      }).then(() => {
        const promptInstance = new CallPrompt({
          call: this,
          listeners: listen,
          payload: {
            control_id: controlId,
            call_id: this.id,
            node_id: this.nodeId
          }
        });
        this._client.instanceMap.set(controlId, promptInstance);
        this.emit("prompt.started", promptInstance);
        promptInstance.emit("prompt.started", promptInstance);
        resolve(promptInstance);
      }).catch((e) => {
        this.emit("prompt.failed", e);
        reject(e);
      });
    });
    return decoratePromptPromise.call(this, promise);
  }
  promptAudio(params) {
    const _a = params, { url, volume } = _a, rest = __objRest(_a, ["url", "volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.Audio({ url }));
    return this.prompt(__spreadValues({
      playlist
    }, rest));
  }
  promptRingtone(params) {
    const _a = params, { name, duration, volume } = _a, rest = __objRest(_a, ["name", "duration", "volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.Ringtone({ name, duration }));
    return this.prompt(__spreadValues({
      playlist
    }, rest));
  }
  promptTTS(params) {
    const _a = params, { text, language, gender, volume } = _a, rest = __objRest(_a, ["text", "language", "gender", "volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.TTS({ text, language, gender }));
    return this.prompt(__spreadValues({
      playlist
    }, rest));
  }
  sendDigits(digits) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call sendDigits() on a call not established yet.`));
      }
      const callStateHandler = (params) => {
        if (params.callState === "ended" || params.callState === "ending") {
          reject(new Error("Call is ended or about to end, couldn't send digits in time."));
        }
      };
      this.once("call.state", callStateHandler);
      const cleanup = () => {
        this.off("call.state", callStateHandler);
      };
      const resolveHandler = (call) => {
        cleanup();
        this.off("send_digits.failed", rejectHandler);
        resolve(call);
      };
      const rejectHandler = (error) => {
        cleanup();
        this.off("send_digits.finished", resolveHandler);
        reject(error);
      };
      this.once("send_digits.finished", resolveHandler);
      this.once("send_digits.failed", rejectHandler);
      const controlId = uuid4();
      this._client.runWorker("voiceCallSendDigitsWorker", {
        worker: voiceCallSendDigitsWorker,
        initialState: {
          controlId
        }
      });
      this._client.execute({
        method: "calling.send_digits",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          digits
        }
      }).catch((e) => {
        reject(e);
      });
    });
  }
  tap(params) {
    const promise = new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call tap() on a call not established yet.`));
      }
      const resolveHandler = (callTap) => {
        this.off("tap.ended", rejectHandler);
        resolve(callTap);
      };
      const rejectHandler = (callTap) => {
        this.off("tap.started", resolveHandler);
        reject(callTap);
      };
      this.once("tap.started", resolveHandler);
      this.once("tap.ended", rejectHandler);
      const controlId = uuid4();
      const _a = params, {
        audio = {},
        device: _b
      } = _a, _c = _b, { type } = _c, rest = __objRest(_c, ["type"]), {
        listen
      } = _a;
      this._client.runWorker("voiceCallTapWorker", {
        worker: voiceCallTapWorker,
        initialState: {
          controlId,
          listeners: listen
        }
      });
      this._client.execute({
        method: "calling.tap",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          tap: {
            type: "audio",
            params: audio
          },
          device: {
            type,
            params: rest
          }
        }
      }).then(() => {
      }).catch((e) => {
        this.off("tap.started", resolveHandler);
        this.off("tap.ended", rejectHandler);
        reject(e);
      });
    });
    return decorateTapPromise.call(this, promise);
  }
  tapAudio(params) {
    const _a = params, { direction } = _a, rest = __objRest(_a, ["direction"]);
    return this.tap(__spreadValues({ audio: { direction } }, rest));
  }
  connect(params) {
    return new Promise((resolve, reject) => {
      var _b, _c;
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call connect() on a call not established yet.`));
      }
      const _tag = uuid4();
      const _a = params, { devices, ringback } = _a, rest = __objRest(_a, ["devices", "ringback"]);
      const executeParams = __spreadValues({
        tag: _tag
      }, toSnakeCaseKeys2(rest));
      if ("ringback" in params) {
        executeParams.ringback = toInternalPlayParams((_c = (_b = params.ringback) == null ? void 0 : _b.media) != null ? _c : []);
      }
      if (params instanceof DeviceBuilder) {
        executeParams.devices = toInternalDevices(params.devices);
      } else if (devices instanceof DeviceBuilder) {
        executeParams.devices = toInternalDevices(devices.devices);
      } else {
        throw new Error('[connect] Invalid "devices" parameter.');
      }
      const resolveHandler = (payload) => {
        this.off("connect.failed", rejectHandler);
        resolve(payload);
      };
      const rejectHandler = (payload) => {
        this.off("connect.connected", resolveHandler);
        reject(toExternalJSON4(payload));
      };
      this.once("connect.connected", resolveHandler);
      this.once("connect.failed", rejectHandler);
      this._client.runWorker("voiceCallConnectWorker", {
        worker: voiceCallConnectWorker,
        initialState: {
          voice: this._voice,
          tag: _tag
        }
      });
      this._client.execute({
        method: "calling.connect",
        params: __spreadValues({
          node_id: this.nodeId,
          call_id: this.callId,
          tag: _tag
        }, executeParams)
      }).catch((e) => {
        this.off("connect.connected", resolveHandler);
        this.off("connect.failed", rejectHandler);
        reject(e);
      });
    });
  }
  connectPhone(_a) {
    var _b = _a, {
      ringback,
      maxPricePerMinute
    } = _b, params = __objRest(_b, [
      "ringback",
      "maxPricePerMinute"
    ]);
    const devices = new DeviceBuilder().add(DeviceBuilder.Phone(params));
    return this.connect({ devices, maxPricePerMinute, ringback });
  }
  connectSip(_c) {
    var _d = _c, {
      ringback,
      maxPricePerMinute
    } = _d, params = __objRest(_d, [
      "ringback",
      "maxPricePerMinute"
    ]);
    const devices = new DeviceBuilder().add(DeviceBuilder.Sip(params));
    return this.connect({ devices, maxPricePerMinute, ringback });
  }
  disconnect() {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId || !this.peer) {
        reject(new Error(`Can't call disconnect() on a call not connected yet.`));
      }
      const resolveHandler = () => {
        resolve();
      };
      this.once("connect.disconnected", resolveHandler);
      this._client.execute({
        method: "calling.disconnect",
        params: {
          node_id: this.nodeId,
          call_id: this.callId
        }
      }).catch((e) => {
        this.off("connect.disconnected", resolveHandler);
        reject(e);
      });
    });
  }
  waitForDisconnected() {
    return this.disconnect;
  }
  disconnected() {
    return new Promise((resolve) => {
      const resolveHandler = () => {
        resolve(this);
      };
      this.once("connect.disconnected", resolveHandler);
      this.once("connect.failed", resolveHandler);
      if (this.state === "ended" || this.state === "ending") {
        return resolveHandler();
      }
    });
  }
  detect(params) {
    const promise = new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call detect() on a call not established yet.`));
      }
      const controlId = uuid4();
      const _a = params, { listen, timeout, type, waitForBeep = false } = _a, rest = __objRest(_a, ["listen", "timeout", "type", "waitForBeep"]);
      this._client.runWorker("voiceCallDetectWorker", {
        worker: voiceCallDetectWorker,
        initialState: {
          controlId,
          listeners: listen
        }
      });
      this._client.execute({
        method: "calling.detect",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          timeout,
          detect: {
            type,
            params: toSnakeCaseKeys2(rest)
          }
        }
      }).then(() => {
        var _a2;
        const detectInstance = new CallDetect({
          call: this,
          payload: {
            control_id: controlId,
            call_id: this.id,
            node_id: this.nodeId,
            waitForBeep: (_a2 = params.waitForBeep) != null ? _a2 : false
          },
          listeners: listen
        });
        this._client.instanceMap.set(controlId, detectInstance);
        this.emit("detect.started", detectInstance);
        detectInstance.emit("detect.started", detectInstance);
        resolve(detectInstance);
      }).catch((e) => {
        this.emit("detect.ended", e);
        reject(e);
      });
    });
    return decorateDetectPromise.call(this, promise);
  }
  amd(params = {}) {
    return this.detect(__spreadProps(__spreadValues({}, params), {
      type: "machine"
    }));
  }
  detectFax(params = {}) {
    return this.detect(__spreadProps(__spreadValues({}, params), {
      type: "fax"
    }));
  }
  detectDigit(params = {}) {
    return this.detect(__spreadProps(__spreadValues({}, params), {
      type: "digit"
    }));
  }
  collect(params) {
    const promise = new Promise((resolve, reject) => {
      const _a = params, { listen } = _a, rest = __objRest(_a, ["listen"]);
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call collect() on a call not established yet.`));
      }
      const controlId = uuid4();
      const {
        initial_timeout,
        partial_results,
        digits,
        speech,
        continuous,
        send_start_of_input,
        start_input_timers
      } = toSnakeCaseKeys2(rest);
      this._client.runWorker("voiceCallCollectWorker", {
        worker: voiceCallCollectWorker,
        initialState: {
          controlId
        }
      });
      this._client.execute({
        method: "calling.collect",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          initial_timeout,
          digits,
          speech,
          partial_results,
          continuous,
          send_start_of_input,
          start_input_timers
        }
      }).then(() => {
        const collectInstance = new CallCollect({
          call: this,
          listeners: listen,
          payload: {
            control_id: controlId,
            call_id: this.id,
            node_id: this.nodeId
          }
        });
        this._client.instanceMap.set(controlId, collectInstance);
        this.emit("collect.started", collectInstance);
        collectInstance.emit("collect.started", collectInstance);
        resolve(collectInstance);
      }).catch((e) => {
        this.emit("collect.failed", e);
        reject(e);
      });
    });
    return decorateCollectPromise.call(this, promise);
  }
  waitFor(params) {
    return new Promise((resolve) => {
      if (!params) {
        resolve(true);
      }
      const events = Array.isArray(params) ? params : [params];
      const emittedCallStates = /* @__PURE__ */ new Set();
      const shouldResolve = () => emittedCallStates.size === events.length;
      const shouldWaitForEnded = events.includes("ended");
      const shouldResolveUnsuccessful = (state) => {
        return !shouldWaitForEnded && state === "ended";
      };
      this.on("call.state", (params2) => {
        if (events.includes(params2.state)) {
          emittedCallStates.add(params2.state);
        } else if (shouldResolveUnsuccessful(params2.state)) {
          return resolve(false);
        }
        if (shouldResolve()) {
          resolve(true);
        }
      });
    });
  }
};

// src/voice/workers/handlers/callStateEventsHandler.ts
function handleCallStateEvents(options) {
  const {
    payload,
    voice,
    listeners,
    instanceMap: { get, set, remove }
  } = options;
  let callInstance = get(payload.call_id);
  if (!callInstance) {
    callInstance = new Call({
      voice,
      payload,
      listeners
    });
  } else {
    callInstance.setPayload(payload);
  }
  set(payload.call_id, callInstance);
  switch (payload.call_state) {
    case "ended": {
      callInstance.emit("call.state", callInstance);
      callInstance.emit("connect.disconnected", callInstance);
      remove(payload.call_id);
      return true;
    }
    default:
      callInstance.emit("call.state", callInstance);
      return false;
  }
}

// src/voice/workers/handlers/callConnectEventsHandler.ts
function handleCallConnectEvents(options) {
  const { payload, instanceMap, voice } = options;
  const { get, set } = instanceMap;
  const callInstance = get(payload.call_id);
  if (!callInstance) {
    throw new Error("Missing call instance for connect");
  }
  callInstance.setConnectPayload(payload);
  set(payload.call_id, callInstance);
  callInstance.emit("call.state", callInstance);
  switch (payload.connect_state) {
    case "connecting": {
      callInstance.emit("connect.connecting", callInstance);
      return false;
    }
    case "connected": {
      let peerCallInstance = get(payload.peer.call_id);
      if (!peerCallInstance) {
        peerCallInstance = new Call({
          voice,
          connectPayload: payload
        });
      } else {
        peerCallInstance.setConnectPayload(payload);
      }
      set(payload.peer.call_id, peerCallInstance);
      callInstance.peer = peerCallInstance;
      peerCallInstance.peer = callInstance;
      callInstance.emit("connect.connected", peerCallInstance);
      return false;
    }
    case "disconnected": {
      callInstance.emit("connect.disconnected");
      callInstance.peer = void 0;
      const peerCallInstance = get(payload.peer.call_id);
      if (peerCallInstance) {
        console.log("emit peer disconnected", peerCallInstance.callId);
        peerCallInstance.emit("connect.disconnected");
        peerCallInstance.peer = void 0;
      }
      return true;
    }
    case "failed": {
      callInstance.peer = void 0;
      callInstance.emit("connect.failed", payload);
      return true;
    }
    default:
      getLogger().warn(`Unknown connect state: "${payload.connect_state}"`);
      return false;
  }
}

// src/voice/workers/handlers/callDialEventsHandler.ts
function handleCallDialEvents(options) {
  const { payload, instanceMap, voice } = options;
  const { get } = instanceMap;
  switch (payload.dial_state) {
    case "failed": {
      voice.emit("dial.failed", payload);
      return true;
    }
    case "answered": {
      const callInstance = get(payload.call.call_id);
      callInstance.setPayload(payload.call);
      voice.emit("dial.answered", callInstance);
      return true;
    }
    default:
      return false;
  }
}

// src/voice/workers/voiceCallReceiveWorker.ts
var voiceCallReceiveWorker = function* (options) {
  getLogger8().trace("voiceCallReceiveWorker started");
  const {
    channels: { swEventChannel },
    instanceMap,
    initialState
  } = options;
  const { voice } = initialState;
  function* callReceiveWorker(action) {
    const { get, set } = instanceMap;
    const { payload } = action;
    if (!payload.context || !payload.context.length) {
      throw new Error("Invalid context to receive inbound call");
    }
    let callInstance = get(payload.call_id);
    if (!callInstance) {
      callInstance = new Call({
        voice,
        payload
      });
    } else {
      callInstance.setPayload(payload);
    }
    set(payload.call_id, callInstance);
    voice.emit(prefixEvent(payload.context, "call.received"), callInstance);
  }
  function* worker(action) {
    if (action.type === "calling.call.receive") {
      yield sagaEffects5.fork(callReceiveWorker, action);
    } else {
      handleCallStateEvents({
        payload: action.payload,
        voice,
        instanceMap
      });
    }
  }
  while (true) {
    const action = yield sagaEffects5.take(swEventChannel, (action2) => {
      return action2.type === "calling.call.receive" || action2.type === "calling.call.state" && action2.payload.direction === "inbound";
    });
    yield sagaEffects5.fork(worker, action);
  }
  getLogger8().trace("voiceCallReceiveWorker ended");
};

// src/voice/workers/voiceCallPlayWorker.ts
import {
  getLogger as getLogger9,
  sagaEffects as sagaEffects6
} from "@signalwire/core";
var voiceCallPlayWorker = function* (options) {
  getLogger9().trace("voiceCallPlayWorker started");
  const {
    channels: { swEventChannel },
    instanceMap: { get, set, remove },
    initialState
  } = options;
  const { controlId, listeners } = initialState;
  function* worker(action) {
    const { payload } = action;
    if (payload.control_id !== controlId)
      return;
    const [playbackControlId] = payload.control_id.split(".");
    const removeFromInstanceMap = () => {
      if (payload.control_id.includes(".prompt"))
        return;
      remove(playbackControlId);
    };
    const callInstance = get(payload.call_id);
    if (!callInstance) {
      throw new Error("Missing call instance for playback");
    }
    let playbackInstance = get(playbackControlId);
    if (!playbackInstance) {
      playbackInstance = new CallPlayback({
        call: callInstance,
        payload,
        listeners
      });
    } else {
      playbackInstance.setPayload(payload);
    }
    set(playbackControlId, playbackInstance);
    switch (payload.state) {
      case "playing": {
        const type = playbackInstance._paused ? "playback.updated" : "playback.started";
        playbackInstance._paused = false;
        callInstance.emit(type, playbackInstance);
        playbackInstance.emit(type, playbackInstance);
        return false;
      }
      case "paused": {
        playbackInstance._paused = true;
        callInstance.emit("playback.updated", playbackInstance);
        playbackInstance.emit("playback.updated", playbackInstance);
        return false;
      }
      case "error": {
        callInstance.emit("playback.failed", playbackInstance);
        playbackInstance.emit("playback.failed", playbackInstance);
        removeFromInstanceMap();
        return true;
      }
      case "finished": {
        callInstance.emit("playback.ended", playbackInstance);
        playbackInstance.emit("playback.ended", playbackInstance);
        removeFromInstanceMap();
        return true;
      }
      default:
        getLogger9().warn(`Unknown playback state: "${payload.state}"`);
        return false;
    }
  }
  while (true) {
    const action = yield sagaEffects6.take(swEventChannel, (action2) => action2.type === "calling.call.play");
    const shouldStop = yield sagaEffects6.fork(worker, action);
    if (shouldStop.result())
      break;
  }
  getLogger9().trace("voiceCallPlayWorker ended");
};

// src/voice/workers/voiceCallRecordWorker.ts
import {
  getLogger as getLogger10,
  sagaEffects as sagaEffects7
} from "@signalwire/core";
var voiceCallRecordWorker = function* (options) {
  getLogger10().trace("voiceCallRecordWorker started");
  const {
    channels: { swEventChannel },
    instanceMap: { get, set, remove },
    initialState
  } = options;
  const { controlId, listeners } = initialState;
  function* worker(action) {
    const { payload } = action;
    if (payload.control_id !== controlId)
      return;
    const callInstance = get(payload.call_id);
    if (!callInstance) {
      throw new Error("Missing call instance for recording");
    }
    let recordingInstance = get(payload.control_id);
    if (!recordingInstance) {
      recordingInstance = new CallRecording({
        call: callInstance,
        payload,
        listeners
      });
    } else {
      recordingInstance.setPayload(payload);
    }
    set(payload.control_id, recordingInstance);
    switch (payload.state) {
      case "recording": {
        const type = recordingInstance._paused ? "recording.updated" : "recording.started";
        recordingInstance._paused = false;
        callInstance.emit(type, recordingInstance);
        recordingInstance.emit(type, recordingInstance);
        return false;
      }
      case "paused": {
        recordingInstance._paused = true;
        callInstance.emit("recording.updated", recordingInstance);
        recordingInstance.emit("recording.updated", recordingInstance);
        return false;
      }
      case "no_input":
      case "finished": {
        const type = payload.state === "finished" ? "recording.ended" : "recording.failed";
        callInstance.emit(type, recordingInstance);
        recordingInstance.emit(type, recordingInstance);
        remove(payload.control_id);
        return true;
      }
      default:
        getLogger10().warn(`Unknown recording state: "${payload.state}"`);
        return false;
    }
  }
  while (true) {
    const action = yield sagaEffects7.take(swEventChannel, (action2) => action2.type === "calling.call.record");
    const shouldStop = yield sagaEffects7.fork(worker, action);
    if (shouldStop.result())
      break;
  }
  getLogger10().trace("voiceCallRecordWorker ended");
};

// src/voice/workers/voiceCallCollectWorker.ts
import {
  getLogger as getLogger11,
  sagaEffects as sagaEffects8
} from "@signalwire/core";
var voiceCallCollectWorker = function* (options) {
  getLogger11().trace("voiceCallCollectWorker started");
  const {
    channels: { swEventChannel },
    instanceMap: { get, set, remove },
    initialState
  } = options;
  const { controlId } = initialState;
  function* worker(action) {
    const { payload } = action;
    if (payload.control_id !== controlId)
      return;
    const callInstance = get(payload.call_id);
    if (!callInstance) {
      throw new Error("Missing call instance for collect");
    }
    const actionInstance = get(payload.control_id);
    if (!actionInstance) {
      throw new Error("Missing the instance");
    }
    actionInstance.setPayload(payload);
    set(payload.control_id, actionInstance);
    let eventPrefix = "collect";
    if (actionInstance instanceof CallPrompt) {
      eventPrefix = "prompt";
    }
    const promptInstance = actionInstance;
    const collectInstance = actionInstance;
    if (payload.final === false) {
      if (eventPrefix === "prompt") {
        callInstance.emit("prompt.updated", promptInstance);
        promptInstance.emit("prompt.updated", promptInstance);
      } else {
        callInstance.emit("collect.updated", collectInstance);
        collectInstance.emit("collect.updated", collectInstance);
      }
      return false;
    } else if (payload.final === true && payload.state == "collecting") {
      if (eventPrefix === "prompt") {
        callInstance.emit("prompt.updated", promptInstance);
        promptInstance.emit("prompt.updated", promptInstance);
      } else {
        callInstance.emit("collect.updated", collectInstance);
        collectInstance.emit("collect.updated", collectInstance);
      }
    }
    switch (payload.result.type) {
      case "start_of_input": {
        if (eventPrefix === "prompt")
          return false;
        callInstance.emit("collect.startOfInput", collectInstance);
        collectInstance.emit("collect.startOfInput", collectInstance);
        return false;
      }
      case "no_input":
      case "no_match":
      case "error": {
        if (payload.state === "collecting")
          return false;
        if (eventPrefix === "prompt") {
          callInstance.emit("prompt.failed", promptInstance);
          promptInstance.emit("prompt.failed", promptInstance);
        } else {
          callInstance.emit("collect.failed", collectInstance);
          collectInstance.emit("collect.failed", collectInstance);
        }
        remove(payload.control_id);
        return true;
      }
      case "speech":
      case "digit": {
        if (payload.state === "collecting")
          return false;
        if (eventPrefix === "prompt") {
          callInstance.emit("prompt.ended", promptInstance);
          promptInstance.emit("prompt.ended", promptInstance);
        } else {
          callInstance.emit("collect.ended", collectInstance);
          collectInstance.emit("collect.ended", collectInstance);
        }
        remove(payload.control_id);
        return false;
      }
      default:
        getLogger11().warn(`Unknown prompt result type: "${payload.result.type}"`);
        return false;
    }
  }
  while (true) {
    const action = yield sagaEffects8.take(swEventChannel, (action2) => action2.type === "calling.call.collect");
    const shouldStop = yield sagaEffects8.fork(worker, action);
    if (shouldStop.result())
      break;
  }
  getLogger11().trace("voiceCallCollectWorker ended");
};

// src/voice/workers/voiceCallTapWorker.ts
import {
  getLogger as getLogger12,
  sagaEffects as sagaEffects9
} from "@signalwire/core";
var voiceCallTapWorker = function* (options) {
  getLogger12().trace("voiceCallTapWorker started");
  const {
    channels: { swEventChannel },
    instanceMap: { get, set, remove },
    initialState
  } = options;
  const { controlId, listeners } = initialState;
  function* worker(action) {
    const { payload } = action;
    if (payload.control_id !== controlId)
      return;
    const callInstance = get(payload.call_id);
    if (!callInstance) {
      throw new Error("Missing call instance for tap");
    }
    let tapInstance = get(payload.control_id);
    if (!tapInstance) {
      tapInstance = new CallTap({
        call: callInstance,
        payload,
        listeners
      });
    } else {
      tapInstance.setPayload(payload);
    }
    set(payload.control_id, tapInstance);
    switch (payload.state) {
      case "tapping":
        callInstance.emit("tap.started", tapInstance);
        tapInstance.emit("tap.started", tapInstance);
        return false;
      case "finished":
        callInstance.emit("tap.ended", tapInstance);
        tapInstance.emit("tap.ended", tapInstance);
        remove(payload.control_id);
        return true;
      default:
        getLogger12().warn(`Unknown tap state: "${payload.state}"`);
        return false;
    }
  }
  while (true) {
    const action = yield sagaEffects9.take(swEventChannel, (action2) => action2.type === "calling.call.tap");
    const shouldStop = yield sagaEffects9.fork(worker, action);
    if (shouldStop.result())
      break;
  }
  getLogger12().trace("voiceCallTapWorker ended");
};

// src/voice/workers/voiceCallConnectWorker.ts
import {
  getLogger as getLogger13,
  sagaEffects as sagaEffects10
} from "@signalwire/core";
var voiceCallConnectWorker = function* (options) {
  getLogger13().trace("voiceCallConnectWorker started");
  const {
    channels: { swEventChannel },
    instanceMap,
    initialState
  } = options;
  const { voice, tag } = initialState;
  const isCallConnectEvent = (action) => action.type === "calling.call.connect";
  const isCallStateEvent = (action) => action.type === "calling.call.state" && action.payload.direction === "outbound" && action.payload.tag === tag;
  function* callConnectWatcher() {
    while (true) {
      const action = yield sagaEffects10.take(swEventChannel, isCallConnectEvent);
      const shouldStop = handleCallConnectEvents({
        payload: action.payload,
        instanceMap,
        voice
      });
      if (shouldStop)
        break;
    }
  }
  function* callStateWatcher() {
    while (true) {
      const action = yield sagaEffects10.take(swEventChannel, isCallStateEvent);
      const shouldStop = handleCallStateEvents({
        payload: action.payload,
        voice,
        instanceMap
      });
      if (shouldStop)
        break;
    }
  }
  yield sagaEffects10.fork(callConnectWatcher);
  yield sagaEffects10.fork(callStateWatcher);
  getLogger13().trace("voiceCallConnectWorker ended");
};

// src/voice/workers/voiceCallDialWorker.ts
import {
  getLogger as getLogger14,
  sagaEffects as sagaEffects11
} from "@signalwire/core";
var voiceCallDialWorker = function* (options) {
  getLogger14().trace("voiceCallDialWorker started");
  const {
    instanceMap,
    channels: { swEventChannel },
    initialState
  } = options;
  const { tag, voice, listeners } = initialState;
  const isCallDialEvent = (action) => {
    return action.type === "calling.call.dial" && action.payload.tag === tag;
  };
  const isCallStateEvent = (action) => {
    return action.type === "calling.call.state" && action.payload.direction === "outbound" && action.payload.tag === tag;
  };
  function* callDialWatcher() {
    while (true) {
      const action = yield sagaEffects11.take(swEventChannel, isCallDialEvent);
      const shouldStop = handleCallDialEvents({
        payload: action.payload,
        instanceMap,
        voice
      });
      if (shouldStop)
        break;
    }
  }
  function* callStateWatcher() {
    while (true) {
      const action = yield sagaEffects11.take(swEventChannel, isCallStateEvent);
      const shouldStop = handleCallStateEvents({
        payload: action.payload,
        voice,
        instanceMap,
        listeners
      });
      if (shouldStop)
        break;
    }
  }
  yield sagaEffects11.fork(callDialWatcher);
  yield sagaEffects11.fork(callStateWatcher);
  getLogger14().trace("voiceCallDialWorker ended");
};

// src/voice/workers/VoiceCallSendDigitWorker.ts
import {
  getLogger as getLogger15,
  sagaEffects as sagaEffects12
} from "@signalwire/core";
var voiceCallSendDigitsWorker = function* (options) {
  getLogger15().trace("voiceCallSendDigitsWorker started");
  const {
    channels: { swEventChannel },
    instanceMap: { get },
    initialState
  } = options;
  const { controlId } = initialState;
  function* worker(action) {
    const { payload } = action;
    if (payload.control_id !== controlId)
      return;
    const callInstance = get(payload.call_id);
    if (!callInstance) {
      throw new Error("Missing call instance for send digits");
    }
    switch (payload.state) {
      case "finished":
        callInstance.emit("send_digits.finished", callInstance);
        return true;
      default: {
        const error = new Error(`[voiceCallSendDigitsWorker] unhandled state: '${payload.state}'`);
        callInstance.emit("send_digits.failed", error);
        return false;
      }
    }
  }
  while (true) {
    const action = yield sagaEffects12.take(swEventChannel, (action2) => action2.type === "calling.call.send_digits");
    const shouldStop = yield sagaEffects12.fork(worker, action);
    if (shouldStop.result())
      break;
  }
  getLogger15().trace("voiceCallSendDigitsWorker ended");
};

// src/voice/workers/voiceCallDetectWorker.ts
import {
  getLogger as getLogger16,
  sagaEffects as sagaEffects13
} from "@signalwire/core";
var voiceCallDetectWorker = function* (options) {
  getLogger16().trace("voiceCallDetectWorker started");
  const {
    channels: { swEventChannel },
    instanceMap: { get, set, remove },
    initialState
  } = options;
  const { controlId, listeners } = initialState;
  function* worker(action) {
    const { payload } = action;
    if (payload.control_id !== controlId)
      return;
    const callInstance = get(payload.call_id);
    if (!callInstance) {
      throw new Error("Missing call instance for collect");
    }
    let detectInstance = get(payload.control_id);
    if (!detectInstance) {
      detectInstance = new CallDetect({
        call: callInstance,
        payload,
        listeners
      });
    } else {
      detectInstance.setPayload(payload);
    }
    set(payload.control_id, detectInstance);
    const { detect } = payload;
    if (!detect)
      return;
    const { type, params } = detect;
    const { event } = params;
    switch (event) {
      case "finished":
      case "error": {
        callInstance.emit("detect.ended", detectInstance);
        detectInstance.emit("detect.ended", detectInstance);
        remove(payload.control_id);
        return true;
      }
      default:
        callInstance.emit("detect.updated", detectInstance);
        detectInstance.emit("detect.updated", detectInstance);
        break;
    }
    switch (type) {
      case "machine":
        if (params.beep && detectInstance.waitForBeep) {
          callInstance.emit("detect.ended", detectInstance);
          detectInstance.emit("detect.ended", detectInstance);
        }
        break;
      case "digit":
      case "fax":
        break;
      default:
        getLogger16().warn(`Unknown detect type: "${type}"`);
        break;
    }
    return false;
  }
  while (true) {
    const action = yield sagaEffects13.take(swEventChannel, (action2) => action2.type === "calling.call.detect");
    const shouldStop = yield sagaEffects13.fork(worker, action);
    if (shouldStop.result())
      break;
  }
  getLogger16().trace("voiceCallDetectWorker ended");
};

// src/voice/Voice.ts
var Voice = class extends BaseNamespace {
  constructor(options) {
    super(options);
    __publicField(this, "_eventMap", {
      onCallReceived: "call.received"
    });
    this._client.runWorker("voiceCallReceiveWorker", {
      worker: voiceCallReceiveWorker,
      initialState: {
        voice: this
      }
    });
  }
  dial(params) {
    return new Promise((resolve, reject) => {
      const _tag = uuid5();
      this._client.runWorker("voiceCallDialWorker", {
        worker: voiceCallDialWorker,
        initialState: {
          voice: this,
          tag: _tag,
          listeners: params.listen
        }
      });
      const resolveHandler = (call) => {
        this.off("dial.failed", rejectHandler);
        resolve(call);
      };
      const rejectHandler = (error) => {
        this.off("dial.answered", resolveHandler);
        reject(toExternalJSON5(error));
      };
      this.once("dial.answered", resolveHandler);
      this.once("dial.failed", rejectHandler);
      let executeParams;
      if (params instanceof DeviceBuilder) {
        const { devices } = params;
        executeParams = {
          tag: _tag,
          devices: toInternalDevices(devices)
        };
      } else if ("region" in params) {
        const { region, nodeId, devices: deviceBuilder } = params;
        executeParams = {
          tag: _tag,
          region,
          node_id: nodeId,
          devices: toInternalDevices(deviceBuilder.devices)
        };
      } else {
        throw new Error("[dial] Invalid input");
      }
      this._client.execute({
        method: "calling.dial",
        params: executeParams
      }).catch((e) => {
        reject(e);
      });
    });
  }
  dialPhone(_a) {
    var _b = _a, {
      region,
      maxPricePerMinute,
      nodeId,
      listen
    } = _b, params = __objRest(_b, [
      "region",
      "maxPricePerMinute",
      "nodeId",
      "listen"
    ]);
    const devices = new DeviceBuilder().add(DeviceBuilder.Phone(params));
    return this.dial({
      maxPricePerMinute,
      region,
      nodeId,
      devices,
      listen
    });
  }
  dialSip(_c) {
    var _d = _c, {
      region,
      maxPricePerMinute,
      nodeId,
      listen
    } = _d, params = __objRest(_d, [
      "region",
      "maxPricePerMinute",
      "nodeId",
      "listen"
    ]);
    const devices = new DeviceBuilder().add(DeviceBuilder.Sip(params));
    return this.dial({
      maxPricePerMinute,
      region,
      nodeId,
      devices,
      listen
    });
  }
};

// src/video/Video.ts
var Video_exports = {};
__export(Video_exports, {
  Video: () => Video
});
import {
  validateEventsToSubscribe as validateEventsToSubscribe3
} from "@signalwire/core";

// src/video/RoomSession.ts
import {
  extendComponent as extendComponent2,
  validateEventsToSubscribe as validateEventsToSubscribe2
} from "@signalwire/core";

// src/video/RoomSessionMember/RoomSessionMember.ts
import {
  extendComponent
} from "@signalwire/core";

// src/video/methods/methods.ts
var methods_exports = {};
__export(methods_exports, {
  audioMuteMember: () => audioMuteMember,
  audioUnmuteMember: () => audioUnmuteMember,
  deafMember: () => deafMember,
  deleteMemberMeta: () => deleteMemberMeta,
  deleteMeta: () => deleteMeta,
  demote: () => demote,
  getLayouts: () => getLayouts,
  getMemberMeta: () => getMemberMeta,
  getMembers: () => getMembers,
  getMeta: () => getMeta,
  getPlaybacks: () => getPlaybacks,
  getRecordings: () => getRecordings,
  getStreams: () => getStreams,
  hideVideoMuted: () => hideVideoMuted,
  lock: () => lock,
  play: () => play,
  promote: () => promote,
  removeAllMembers: () => removeAllMembers,
  removeMember: () => removeMember,
  setDeaf: () => setDeaf,
  setHideVideoMuted: () => setHideVideoMuted,
  setInputSensitivityMember: () => setInputSensitivityMember,
  setInputVolumeMember: () => setInputVolumeMember,
  setLayout: () => setLayout,
  setMemberMeta: () => setMemberMeta,
  setMemberPosition: () => setMemberPosition,
  setMeta: () => setMeta,
  setOutputVolumeMember: () => setOutputVolumeMember,
  setPositions: () => setPositions,
  setPrioritizeHandraise: () => setPrioritizeHandraise,
  setRaisedHand: () => setRaisedHand,
  showVideoMuted: () => showVideoMuted,
  startRecording: () => startRecording,
  startStream: () => startStream,
  undeafMember: () => undeafMember,
  unlock: () => unlock,
  updateMemberMeta: () => updateMemberMeta,
  updateMeta: () => updateMeta,
  videoMuteMember: () => videoMuteMember,
  videoUnmuteMember: () => videoUnmuteMember
});

// src/video/RoomSessionPlayback/RoomSessionPlayback.ts
var RoomSessionPlayback = class extends ListenSubscriber {
  constructor(options) {
    super({ swClient: options.roomSession._sw });
    __publicField(this, "_payload");
    __publicField(this, "_eventMap", {
      onStarted: "playback.started",
      onUpdated: "playback.updated",
      onEnded: "playback.ended"
    });
    this._payload = options.payload;
  }
  get id() {
    return this._payload.playback.id;
  }
  get roomId() {
    return this._payload.room_id;
  }
  get roomSessionId() {
    return this._payload.room_session_id;
  }
  get url() {
    return this._payload.playback.url;
  }
  get state() {
    return this._payload.playback.state;
  }
  get volume() {
    return this._payload.playback.volume;
  }
  get startedAt() {
    if (!this._payload.playback.started_at)
      return void 0;
    return new Date(this._payload.playback.started_at * 1e3);
  }
  get endedAt() {
    if (!this._payload.playback.ended_at)
      return void 0;
    return new Date(this._payload.playback.ended_at * 1e3);
  }
  get position() {
    return this._payload.playback.position;
  }
  get seekable() {
    return this._payload.playback.seekable;
  }
  get hasEnded() {
    if (this.state === "completed") {
      return true;
    }
    return false;
  }
  setPayload(payload) {
    this._payload = payload;
  }
  async pause() {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "video.playback.pause",
      params: {
        room_session_id: this.roomSessionId,
        playback_id: this.id
      }
    });
  }
  async resume() {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "video.playback.resume",
      params: {
        room_session_id: this.roomSessionId,
        playback_id: this.id
      }
    });
  }
  async stop() {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "video.playback.stop",
      params: {
        room_session_id: this.roomSessionId,
        playback_id: this.id
      }
    });
  }
  async setVolume(volume) {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "video.playback.set_volume",
      params: {
        room_session_id: this.roomSessionId,
        playback_id: this.id,
        volume
      }
    });
  }
  async seek(timecode) {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "video.playback.seek_absolute",
      params: {
        room_session_id: this.roomSessionId,
        playback_id: this.id,
        position: Math.abs(timecode)
      }
    });
  }
  async forward(offset = 5e3) {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "video.playback.seek_relative",
      params: {
        room_session_id: this.roomSessionId,
        playback_id: this.id,
        position: Math.abs(offset)
      }
    });
  }
  async rewind(offset = 5e3) {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "video.playback.seek_relative",
      params: {
        room_session_id: this.roomSessionId,
        playback_id: this.id,
        position: -Math.abs(offset)
      }
    });
  }
};

// src/video/RoomSessionPlayback/decoratePlaybackPromise.ts
var getters7 = [
  "id",
  "roomId",
  "roomSessionId",
  "url",
  "state",
  "volume",
  "startedAt",
  "endedAt",
  "position",
  "seekable"
];
var methods7 = [
  "pause",
  "resume",
  "stop",
  "setVolume",
  "seek",
  "forward",
  "rewind"
];
function decoratePlaybackPromise2(innerPromise) {
  return decoratePromise.call(this, {
    promise: innerPromise,
    namespace: "playback",
    methods: methods7,
    getters: getters7
  });
}

// src/video/RoomSessionRecording/RoomSessionRecording.ts
var RoomSessionRecording = class extends ListenSubscriber {
  constructor(options) {
    super({ swClient: options.roomSession._sw });
    __publicField(this, "_payload");
    __publicField(this, "_eventMap", {
      onStarted: "recording.started",
      onUpdated: "recording.updated",
      onEnded: "recording.ended"
    });
    this._payload = options.payload;
  }
  get id() {
    return this._payload.recording.id;
  }
  get roomId() {
    return this._payload.room_id;
  }
  get roomSessionId() {
    return this._payload.room_session_id;
  }
  get state() {
    return this._payload.recording.state;
  }
  get duration() {
    return this._payload.recording.duration;
  }
  get startedAt() {
    if (!this._payload.recording.started_at)
      return void 0;
    return new Date(this._payload.recording.started_at * 1e3);
  }
  get endedAt() {
    if (!this._payload.recording.ended_at)
      return void 0;
    return new Date(this._payload.recording.ended_at * 1e3);
  }
  get hasEnded() {
    if (this.state === "completed") {
      return true;
    }
    return false;
  }
  setPayload(payload) {
    this._payload = payload;
  }
  async pause() {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "video.recording.pause",
      params: {
        room_session_id: this.roomSessionId,
        recording_id: this.id
      }
    });
  }
  async resume() {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "video.recording.resume",
      params: {
        room_session_id: this.roomSessionId,
        recording_id: this.id
      }
    });
  }
  async stop() {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "video.recording.stop",
      params: {
        room_session_id: this.roomSessionId,
        recording_id: this.id
      }
    });
  }
};

// src/video/RoomSessionRecording/decorateRecordingPromise.ts
var getters8 = [
  "id",
  "roomId",
  "roomSessionId",
  "state",
  "duration",
  "startedAt",
  "endedAt"
];
var methods8 = ["pause", "resume", "stop"];
function decorateRecordingPromise2(innerPromise) {
  return decoratePromise.call(this, {
    promise: innerPromise,
    namespace: "recording",
    methods: methods8,
    getters: getters8
  });
}

// src/video/RoomSessionStream/RoomSessionStream.ts
var RoomSessionStream = class extends ListenSubscriber {
  constructor(options) {
    super({ swClient: options.roomSession._sw });
    __publicField(this, "_payload");
    __publicField(this, "_eventMap", {
      onStarted: "stream.started",
      onEnded: "stream.ended"
    });
    this._payload = options.payload;
  }
  get id() {
    return this._payload.stream.id;
  }
  get roomId() {
    return this._payload.room_id;
  }
  get roomSessionId() {
    return this._payload.room_session_id;
  }
  get state() {
    return this._payload.stream.state;
  }
  get duration() {
    return this._payload.stream.duration;
  }
  get url() {
    return this._payload.stream.url;
  }
  get startedAt() {
    if (!this._payload.stream.started_at)
      return void 0;
    return new Date(this._payload.stream.started_at * 1e3);
  }
  get endedAt() {
    if (!this._payload.stream.ended_at)
      return void 0;
    return new Date(this._payload.stream.ended_at * 1e3);
  }
  get hasEnded() {
    if (this.state === "completed") {
      return true;
    }
    return false;
  }
  setPayload(payload) {
    this._payload = payload;
  }
  async stop() {
    if (this.hasEnded) {
      throw new Error("Action has ended");
    }
    await this._client.execute({
      method: "video.stream.stop",
      params: {
        room_session_id: this.roomSessionId,
        stream_id: this.id
      }
    });
  }
};

// src/video/RoomSessionStream/decorateStreamPromise.ts
var getters9 = [
  "id",
  "roomId",
  "roomSessionId",
  "url",
  "state",
  "duration",
  "startedAt",
  "endedAt"
];
var methods9 = ["stop"];
function decorateStreamPromise(innerPromise) {
  return decoratePromise.call(this, {
    promise: innerPromise,
    namespace: "stream",
    methods: methods9,
    getters: getters9
  });
}

// src/video/methods/methods.ts
var baseCodeTransform = () => {
};
var createRoomMethod = (method, options = {}) => ({
  value: function(params = {}) {
    return this._client.execute({
      method,
      params: __spreadValues({
        room_session_id: this.roomSessionId
      }, params)
    }, options);
  }
});
var createRoomMemberMethod = (method, options = {}) => ({
  value: function(_a = {}) {
    var _b = _a, { memberId } = _b, rest = __objRest(_b, ["memberId"]);
    return this._client.execute({
      method,
      params: __spreadValues({
        room_session_id: this.roomSessionId,
        member_id: memberId || this.memberId
      }, rest)
    }, options);
  }
});
var getLayouts = createRoomMethod("video.list_available_layouts", {
  transformResolve: (payload) => ({ layouts: payload.layouts })
});
var getMembers = createRoomMethod("video.members.get", {
  transformResolve: (payload) => ({ members: payload.members })
});
var setLayout = createRoomMethod("video.set_layout", {
  transformResolve: baseCodeTransform
});
var setPositions = createRoomMethod("video.set_position", {
  transformResolve: baseCodeTransform
});
var hideVideoMuted = createRoomMethod("video.hide_video_muted", {
  transformResolve: baseCodeTransform
});
var showVideoMuted = createRoomMethod("video.show_video_muted", {
  transformResolve: baseCodeTransform
});
var lock = createRoomMethod("video.lock", {
  transformResolve: baseCodeTransform
});
var unlock = createRoomMethod("video.unlock", {
  transformResolve: baseCodeTransform
});
var setHideVideoMuted = {
  value: function(value) {
    return this._client.execute({
      method: value ? "video.hide_video_muted" : "video.show_video_muted",
      params: {
        room_session_id: this.roomSessionId
      }
    }, {
      transformResolve: baseCodeTransform
    });
  }
};
var getRecordings = {
  value: function() {
    return new Promise(async (resolve, reject) => {
      try {
        const { recordings } = await this._client.execute({
          method: "video.recording.list",
          params: {
            room_session_id: this.roomSessionId
          }
        });
        const recordingInstances = [];
        recordings.forEach((recording) => {
          let recordingInstance = this._client.instanceMap.get(recording.id);
          if (!recordingInstance) {
            recordingInstance = new RoomSessionRecording({
              payload: {
                room_id: this.roomId,
                room_session_id: this.roomSessionId,
                recording
              },
              roomSession: this
            });
          } else {
            recordingInstance.setPayload({
              room_id: this.roomId,
              room_session_id: this.roomSessionId,
              recording
            });
          }
          recordingInstances.push(recordingInstance);
          this._client.instanceMap.set(recordingInstance.id, recordingInstance);
        });
        resolve({ recordings: recordingInstances });
      } catch (error) {
        reject(error);
      }
    });
  }
};
var startRecording = {
  value: function({ listen } = {}) {
    const promise = new Promise(async (resolve, reject) => {
      const resolveHandler = (recording) => {
        this.off("recording.ended", rejectHandler);
        resolve(recording);
      };
      const rejectHandler = (recording) => {
        this.off("recording.started", resolveHandler);
        reject(recording);
      };
      if (listen) {
        mapActionListenersToRoomListeners.call(this, {
          listeners: listen,
          action: "recording"
        });
      }
      this.once("recording.started", resolveHandler);
      this.once("recording.ended", rejectHandler);
      this._client.execute({
        method: "video.recording.start",
        params: {
          room_session_id: this.roomSessionId
        }
      }).then(() => {
      }).catch((e) => {
        this.off("recording.started", resolveHandler);
        this.off("recording.ended", rejectHandler);
        reject(e);
      });
    });
    return decorateRecordingPromise2.call(this, promise);
  }
};
var getPlaybacks = {
  value: function() {
    return new Promise(async (resolve, reject) => {
      try {
        const { playbacks } = await this._client.execute({
          method: "video.playback.list",
          params: {
            room_session_id: this.roomSessionId
          }
        });
        const playbackInstances = [];
        playbacks.forEach((playback) => {
          let playbackInstance = this._client.instanceMap.get(playback.id);
          if (!playbackInstance) {
            playbackInstance = new RoomSessionPlayback({
              payload: {
                room_id: this.roomId,
                room_session_id: this.roomSessionId,
                playback
              },
              roomSession: this
            });
          } else {
            playbackInstance.setPayload({
              room_id: this.roomId,
              room_session_id: this.roomSessionId,
              playback
            });
          }
          playbackInstances.push(playbackInstance);
          this._client.instanceMap.set(playbackInstance.id, playbackInstance);
        });
        resolve({ playbacks: playbackInstances });
      } catch (error) {
        reject(error);
      }
    });
  }
};
var play = {
  value: function(_a) {
    var _b = _a, { seekPosition, currentTimecode, listen } = _b, params = __objRest(_b, ["seekPosition", "currentTimecode", "listen"]);
    const promise = new Promise(async (resolve, reject) => {
      const seek_position = seekPosition || currentTimecode;
      const resolveHandler = (playback) => {
        this.off("playback.ended", rejectHandler);
        resolve(playback);
      };
      const rejectHandler = (playback) => {
        this.off("playback.started", resolveHandler);
        reject(playback);
      };
      if (listen) {
        mapActionListenersToRoomListeners.call(this, {
          listeners: listen,
          action: "playback"
        });
      }
      this.once("playback.started", resolveHandler);
      this.once("playback.ended", rejectHandler);
      this._client.execute({
        method: "video.playback.start",
        params: __spreadValues({
          room_session_id: this.roomSessionId,
          seek_position
        }, params)
      }).then(() => {
      }).catch((e) => {
        this.off("playback.started", resolveHandler);
        this.off("playback.ended", rejectHandler);
        reject(e);
      });
    });
    return decoratePlaybackPromise2.call(this, promise);
  }
};
var createRoomMetaMethod = (method) => {
  return createRoomMethod(method, {
    transformResolve: baseCodeTransform,
    transformParams: (params) => {
      const _a = params, { room_session_id } = _a, meta = __objRest(_a, ["room_session_id"]);
      return { room_session_id, meta };
    }
  });
};
var getMeta = createRoomMethod("video.get_meta", {
  transformResolve: ({ meta }) => ({ meta })
});
var setMeta = createRoomMetaMethod("video.set_meta");
var updateMeta = createRoomMetaMethod("video.update_meta");
var deleteMeta = {
  value: function(params) {
    return this._client.execute({
      method: "video.delete_meta",
      params: {
        room_session_id: this.roomSessionId,
        keys: params
      }
    });
  }
};
var getStreams = {
  value: function() {
    return new Promise(async (resolve, reject) => {
      try {
        const { streams } = await this._client.execute({
          method: "video.stream.list",
          params: {
            room_session_id: this.roomSessionId
          }
        });
        const streamInstances = [];
        streams.forEach((stream) => {
          let streamInstance = this._client.instanceMap.get(stream.id);
          if (!streamInstance) {
            streamInstance = new RoomSessionStream({
              payload: {
                room_id: this.roomId,
                room_session_id: this.roomSessionId,
                stream
              },
              roomSession: this
            });
          } else {
            streamInstance.setPayload({
              room_id: this.roomId,
              room_session_id: this.roomSessionId,
              stream
            });
          }
          streamInstances.push(streamInstance);
          this._client.instanceMap.set(streamInstance.id, streamInstance);
        });
        resolve({ streams: streamInstances });
      } catch (error) {
        reject(error);
      }
    });
  }
};
var startStream = {
  value: function(_a) {
    var _b = _a, { listen } = _b, params = __objRest(_b, ["listen"]);
    const promise = new Promise(async (resolve, reject) => {
      const resolveHandler = (stream) => {
        this.off("stream.ended", rejectHandler);
        resolve(stream);
      };
      const rejectHandler = (stream) => {
        this.off("stream.started", resolveHandler);
        reject(stream);
      };
      if (listen) {
        mapActionListenersToRoomListeners.call(this, {
          listeners: listen,
          action: "stream"
        });
      }
      this.once("stream.started", resolveHandler);
      this.once("stream.ended", rejectHandler);
      this._client.execute({
        method: "video.stream.start",
        params: __spreadValues({
          room_session_id: this.roomSessionId
        }, params)
      }).then(() => {
      }).catch((e) => {
        this.off("stream.started", resolveHandler);
        this.off("stream.ended", rejectHandler);
        reject(e);
      });
    });
    return decorateStreamPromise.call(this, promise);
  }
};
var setPrioritizeHandraise = {
  value: function(params) {
    return this._client.execute({
      method: "video.prioritize_handraise",
      params: {
        room_session_id: this.roomSessionId,
        enable: params
      }
    });
  }
};
var audioMuteMember = createRoomMemberMethod("video.member.audio_mute", {
  transformResolve: baseCodeTransform
});
var audioUnmuteMember = createRoomMemberMethod("video.member.audio_unmute", {
  transformResolve: baseCodeTransform
});
var videoMuteMember = createRoomMemberMethod("video.member.video_mute", {
  transformResolve: baseCodeTransform
});
var videoUnmuteMember = createRoomMemberMethod("video.member.video_unmute", {
  transformResolve: baseCodeTransform
});
var deafMember = createRoomMemberMethod("video.member.deaf", {
  transformResolve: baseCodeTransform
});
var undeafMember = createRoomMemberMethod("video.member.undeaf", {
  transformResolve: baseCodeTransform
});
var setDeaf = {
  value: function(value) {
    return this._client.execute({
      method: value ? "video.member.deaf" : "video.member.undeaf",
      params: {
        room_session_id: this.roomSessionId,
        member_id: this.memberId
      }
    }, {
      transformResolve: baseCodeTransform
    });
  }
};
var setInputVolumeMember = createRoomMemberMethod("video.member.set_input_volume", {
  transformResolve: baseCodeTransform
});
var setOutputVolumeMember = createRoomMemberMethod("video.member.set_output_volume", {
  transformResolve: baseCodeTransform
});
var setInputSensitivityMember = createRoomMemberMethod("video.member.set_input_sensitivity", {
  transformResolve: baseCodeTransform
});
var promote = {
  value: function(_a) {
    var _b = _a, {
      memberId,
      mediaAllowed,
      joinAudioMuted,
      joinVideoMuted
    } = _b, rest = __objRest(_b, [
      "memberId",
      "mediaAllowed",
      "joinAudioMuted",
      "joinVideoMuted"
    ]);
    return this._client.execute({
      method: "video.member.promote",
      params: __spreadValues({
        room_session_id: this.roomSessionId,
        member_id: memberId,
        media_allowed: mediaAllowed,
        join_audio_muted: joinAudioMuted,
        join_video_muted: joinVideoMuted
      }, rest)
    }, {
      transformResolve: baseCodeTransform
    });
  }
};
var demote = {
  value: function({ memberId, mediaAllowed }) {
    return this._client.execute({
      method: "video.member.demote",
      params: {
        room_session_id: this.roomSessionId,
        member_id: memberId,
        media_allowed: mediaAllowed
      }
    }, {
      transformResolve: baseCodeTransform
    });
  }
};
var setMemberPosition = createRoomMemberMethod("video.member.set_position", {
  transformResolve: baseCodeTransform
});
var removeMember = {
  value: function(_a) {
    var _b = _a, { memberId } = _b, rest = __objRest(_b, ["memberId"]);
    if (!memberId) {
      throw new TypeError('Invalid or missing "memberId" argument');
    }
    return this._client.execute({
      method: "video.member.remove",
      params: __spreadValues({
        room_session_id: this.roomSessionId,
        member_id: memberId
      }, rest)
    }, {
      transformResolve: baseCodeTransform
    });
  }
};
var removeAllMembers = {
  value: function() {
    return this._client.execute({
      method: "video.member.remove",
      params: {
        room_session_id: this.roomSessionId,
        member_id: "all"
      }
    }, {
      transformResolve: baseCodeTransform
    });
  }
};
var getMemberMeta = createRoomMemberMethod("video.member.get_meta", {
  transformResolve: ({ meta }) => ({ meta })
});
var setMemberMeta = createRoomMemberMethod("video.member.set_meta", {
  transformResolve: baseCodeTransform
});
var updateMemberMeta = createRoomMemberMethod("video.member.update_meta", {
  transformResolve: baseCodeTransform
});
var deleteMemberMeta = createRoomMemberMethod("video.member.delete_meta", {
  transformResolve: baseCodeTransform
});
var setRaisedHand = {
  value: function(value) {
    const { raised = true, memberId = this.memberId } = value || {};
    if (!memberId) {
      throw new TypeError('Invalid or missing "memberId" argument');
    }
    return this._client.execute({
      method: raised ? "video.member.raisehand" : "video.member.lowerhand",
      params: {
        room_session_id: this.roomSessionId,
        member_id: memberId
      }
    }, {
      transformResolve: baseCodeTransform
    });
  }
};
function mapActionListenersToRoomListeners(options) {
  const { listeners, action } = options;
  if (!["playback", "recording", "stream"].includes(action))
    return;
  const playListenMapper = {
    onStarted: "onPlaybackStarted",
    onUpdated: "onPlaybackUpdated",
    onEnded: "onPlaybackEnded"
  };
  const recordListenMapper = {
    onStarted: "onRecordingStarted",
    onUpdated: "onRecordingUpdated",
    onEnded: "onRecordingEnded"
  };
  const streamListenMapper = {
    onStarted: "onStreamStarted",
    onEnded: "onStreamEnded"
  };
  let mapper = {};
  if (action === "playback") {
    mapper = playListenMapper;
  }
  if (action === "recording") {
    mapper = recordListenMapper;
  }
  if (action === "stream") {
    mapper = streamListenMapper;
  }
  const roomListeners = Object.keys(listeners).reduce((acc, key) => {
    const mappedKey = mapper[key];
    if (mappedKey) {
      acc[mappedKey] = listeners[key];
    }
    return acc;
  }, {});
  this.listen(roomListeners);
}

// src/video/RoomSessionMember/RoomSessionMember.ts
var RoomSessionMember = class {
  constructor(options) {
    __publicField(this, "_client");
    __publicField(this, "_payload");
    this._client = options.roomSession._sw.client;
    this._payload = options.payload;
  }
  get id() {
    return this._payload.member.id;
  }
  get memberId() {
    return this._payload.member.id;
  }
  get roomSessionId() {
    return this._payload.member.room_session_id;
  }
  get roomId() {
    return this._payload.member.room_id;
  }
  get parentId() {
    return this._payload.member.parent_id;
  }
  get name() {
    return this._payload.member.name;
  }
  get type() {
    return this._payload.member.type;
  }
  get meta() {
    return this._payload.member.meta;
  }
  get requestedPosition() {
    return this._payload.member.requested_position;
  }
  get currentPosition() {
    return this._payload.member.current_position;
  }
  get visible() {
    return this._payload.member.visible;
  }
  get audioMuted() {
    return this._payload.member.audio_muted;
  }
  get videoMuted() {
    return this._payload.member.video_muted;
  }
  get deaf() {
    return this._payload.member.deaf;
  }
  get inputVolume() {
    return this._payload.member.input_volume;
  }
  get outputVolume() {
    return this._payload.member.output_volume;
  }
  get inputSensitivity() {
    return this._payload.member.input_sensitivity;
  }
  get talking() {
    return this._payload.member.talking;
  }
  get handraised() {
    return this._payload.member.handraised;
  }
  setPayload(payload) {
    const newPayload = __spreadProps(__spreadValues({}, payload), {
      member: __spreadValues(__spreadValues({}, this._payload.member), payload.member)
    });
    this._payload = newPayload;
  }
  async remove() {
    await this._client.execute({
      method: "video.member.remove",
      params: {
        room_session_id: this.roomSessionId,
        member_id: this.memberId
      }
    });
  }
};
var RoomSessionMemberAPI = extendComponent(RoomSessionMember, {
  audioMute: methods_exports.audioMuteMember,
  audioUnmute: methods_exports.audioUnmuteMember,
  videoMute: methods_exports.videoMuteMember,
  videoUnmute: methods_exports.videoUnmuteMember,
  setDeaf: methods_exports.setDeaf,
  setMicrophoneVolume: methods_exports.setInputVolumeMember,
  setInputVolume: methods_exports.setInputVolumeMember,
  setSpeakerVolume: methods_exports.setOutputVolumeMember,
  setOutputVolume: methods_exports.setOutputVolumeMember,
  setInputSensitivity: methods_exports.setInputSensitivityMember,
  setRaisedHand: methods_exports.setRaisedHand
});

// src/video/BaseVideo.ts
import {
  validateEventsToSubscribe,
  uuid as uuid6
} from "@signalwire/core";
var BaseVideo = class extends ListenSubscriber {
  constructor(options) {
    super({ swClient: options });
    __publicField(this, "subscribeMethod", "signalwire.subscribe");
    __publicField(this, "_subscribeParams", {});
    __publicField(this, "_eventChannel", "");
    __publicField(this, "_subscribedEvents", /* @__PURE__ */ new Map());
  }
  get eventChannel() {
    return this._eventChannel;
  }
  getSubscriptions() {
    return validateEventsToSubscribe(this.eventNames());
  }
  async subscribe(listeners) {
    const _uuid = uuid6();
    this._attachListeners(listeners);
    await this.addEvents();
    const unsub = () => {
      return new Promise(async (resolve, reject) => {
        try {
          this._detachListeners(listeners);
          this.removeFromListenerMap(_uuid);
          resolve();
        } catch (error) {
          reject(error);
        }
      });
    };
    this.addToListenerMap(_uuid, {
      listeners,
      unsub
    });
    return unsub;
  }
  async addEvents() {
    const subscriptions = this.getSubscriptions();
    const channelSubscribedEvents = this.getSubscribedEvents();
    const newSubscriptions = subscriptions.filter((event) => !(channelSubscribedEvents == null ? void 0 : channelSubscribedEvents.includes(event)));
    if (!newSubscriptions.length) {
      this._client.logger.debug("No new events to subscribe", subscriptions);
      return;
    }
    const executeParams = {
      method: this.subscribeMethod,
      params: {
        get_initial_state: true,
        event_channel: this.eventChannel,
        events: newSubscriptions
      }
    };
    const result = await this._client.execute(executeParams);
    this.updateSubscribedEvents(newSubscriptions);
    return result;
  }
  getSubscribedEvents() {
    if (!this.eventChannel)
      return [];
    return this._subscribedEvents.get(this.eventChannel);
  }
  updateSubscribedEvents(newSubscriptions) {
    if (!this.eventChannel)
      return;
    if (this._subscribedEvents.has(this.eventChannel)) {
      const prevEvents = this._subscribedEvents.get(this.eventChannel) || [];
      const newEvents = [...prevEvents, ...newSubscriptions];
      this._subscribedEvents.set(this.eventChannel, newEvents);
    } else {
      this._subscribedEvents.set(this.eventChannel, newSubscriptions);
    }
  }
};

// src/video/RoomSession.ts
var RoomSession = class extends BaseVideo {
  constructor(options) {
    super(options.video._sw);
    __publicField(this, "_payload");
    __publicField(this, "_eventMap", {
      onRoomSubscribed: "room.subscribed",
      onRoomStarted: "room.started",
      onRoomUpdated: "room.updated",
      onRoomEnded: "room.ended",
      onRoomAudienceCount: "room.audienceCount",
      onLayoutChanged: "layout.changed",
      onMemberJoined: "member.joined",
      onMemberUpdated: "member.updated",
      onMemberLeft: "member.left",
      onMemberListUpdated: "memberList.updated",
      onMemberTalking: "member.talking",
      onMemberTalkingStarted: "member.talking.started",
      onMemberTalkingEnded: "member.talking.ended",
      onMemberDeaf: "member.updated.deaf",
      onMemberVisible: "member.updated.visible",
      onMemberAudioMuted: "member.updated.audioMuted",
      onMemberVideoMuted: "member.updated.videoMuted",
      onMemberInputVolume: "member.updated.inputVolume",
      onMemberOutputVolume: "member.updated.outputVolume",
      onMemberInputSensitivity: "member.updated.inputSensitivity",
      onPlaybackStarted: "playback.started",
      onPlaybackUpdated: "playback.updated",
      onPlaybackEnded: "playback.ended",
      onRecordingStarted: "recording.started",
      onRecordingUpdated: "recording.updated",
      onRecordingEnded: "recording.ended",
      onStreamStarted: "stream.started",
      onStreamEnded: "stream.ended"
    });
    this._payload = options.payload;
  }
  get id() {
    return this._payload.room_session.id;
  }
  get roomSessionId() {
    return this._payload.room_session.id;
  }
  get roomId() {
    return this._payload.room_session.room_id;
  }
  get name() {
    return this._payload.room_session.name;
  }
  get displayName() {
    return this._payload.room_session.display_name;
  }
  get hideVideoMuted() {
    return this._payload.room_session.hide_video_muted;
  }
  get layoutName() {
    return this._payload.room_session.layout_name;
  }
  get meta() {
    return this._payload.room_session.meta;
  }
  get previewUrl() {
    return this._payload.room_session.preview_url;
  }
  get recording() {
    return this._payload.room_session.recording;
  }
  get streaming() {
    return this._payload.room_session.streaming;
  }
  get locked() {
    return this._payload.room_session.locked;
  }
  get eventChannel() {
    return this._payload.room_session.event_channel;
  }
  get prioritizeHandraise() {
    return this._payload.room_session.prioritize_handraise;
  }
  get updated() {
    return this._payload.room_session.updated;
  }
  getSubscriptions() {
    const eventNamesWithPrefix = this.eventNames().map((event) => `video.${String(event)}`);
    return validateEventsToSubscribe2(eventNamesWithPrefix);
  }
  setPayload(payload) {
    this._payload = payload;
  }
  getMembers() {
    return new Promise(async (resolve, reject) => {
      try {
        const { members } = await this._client.execute({
          method: "video.members.get",
          params: {
            room_session_id: this.roomSessionId
          }
        });
        const memberInstances = [];
        members.forEach((member) => {
          let memberInstance = this._client.instanceMap.get(member.id);
          if (!memberInstance) {
            memberInstance = new RoomSessionMemberAPI({
              roomSession: this,
              payload: {
                room_id: this.roomId,
                room_session_id: this.roomSessionId,
                member
              }
            });
          } else {
            memberInstance.setPayload({
              member
            });
          }
          memberInstances.push(memberInstance);
          this._client.instanceMap.set(memberInstance.id, memberInstance);
        });
        resolve({ members: memberInstances });
      } catch (error) {
        reject(error);
      }
    });
  }
};
var RoomSessionAPI = extendComponent2(RoomSession, {
  videoMute: methods_exports.videoMuteMember,
  videoUnmute: methods_exports.videoUnmuteMember,
  audioMute: methods_exports.audioMuteMember,
  audioUnmute: methods_exports.audioUnmuteMember,
  deaf: methods_exports.deafMember,
  undeaf: methods_exports.undeafMember,
  setInputVolume: methods_exports.setInputVolumeMember,
  setOutputVolume: methods_exports.setOutputVolumeMember,
  setMicrophoneVolume: methods_exports.setInputVolumeMember,
  setSpeakerVolume: methods_exports.setOutputVolumeMember,
  setInputSensitivity: methods_exports.setInputSensitivityMember,
  removeMember: methods_exports.removeMember,
  removeAllMembers: methods_exports.removeAllMembers,
  setHideVideoMuted: methods_exports.setHideVideoMuted,
  getLayouts: methods_exports.getLayouts,
  setLayout: methods_exports.setLayout,
  setPositions: methods_exports.setPositions,
  setMemberPosition: methods_exports.setMemberPosition,
  getRecordings: methods_exports.getRecordings,
  startRecording: methods_exports.startRecording,
  getPlaybacks: methods_exports.getPlaybacks,
  play: methods_exports.play,
  getMeta: methods_exports.getMeta,
  setMeta: methods_exports.setMeta,
  updateMeta: methods_exports.updateMeta,
  deleteMeta: methods_exports.deleteMeta,
  getMemberMeta: methods_exports.getMemberMeta,
  setMemberMeta: methods_exports.setMemberMeta,
  updateMemberMeta: methods_exports.updateMemberMeta,
  deleteMemberMeta: methods_exports.deleteMemberMeta,
  promote: methods_exports.promote,
  demote: methods_exports.demote,
  getStreams: methods_exports.getStreams,
  startStream: methods_exports.startStream,
  lock: methods_exports.lock,
  unlock: methods_exports.unlock,
  setRaisedHand: methods_exports.setRaisedHand,
  setPrioritizeHandraise: methods_exports.setPrioritizeHandraise
});

// src/video/workers/videoCallingWorker.ts
import {
  getLogger as getLogger24,
  sagaEffects as sagaEffects15,
  sagaHelpers
} from "@signalwire/core";

// src/video/workers/videoRoomWorker.ts
import {
  getLogger as getLogger18,
  MemberPosition,
  sagaEffects as sagaEffects14
} from "@signalwire/core";

// src/video/workers/videoMemberWorker.ts
import {
  getLogger as getLogger17,
  fromSnakeToCamelCase,
  stripNamespacePrefix
} from "@signalwire/core";
var videoMemberWorker = function* (options) {
  getLogger17().trace("videoMemberWorker started");
  const {
    action: { type, payload },
    instanceMap: { get, set, remove }
  } = options;
  const roomSessionInstance = get(payload.room_session_id);
  if (!roomSessionInstance) {
    throw new Error("Missing room session instance for member");
  }
  let memberInstance = get(payload.member.id);
  if (!memberInstance) {
    memberInstance = new RoomSessionMemberAPI({
      roomSession: roomSessionInstance,
      payload
    });
  } else {
    memberInstance.setPayload(payload);
  }
  set(payload.member.id, memberInstance);
  const event = stripNamespacePrefix(type);
  if (type.startsWith("video.member.updated.")) {
    const clientType = fromSnakeToCamelCase(event);
    roomSessionInstance.emit(clientType, memberInstance);
  }
  switch (type) {
    case "video.member.joined":
    case "video.member.updated":
      roomSessionInstance.emit(event, memberInstance);
      break;
    case "video.member.left":
      roomSessionInstance.emit(event, memberInstance);
      remove(payload.member.id);
      break;
    case "video.member.talking":
      roomSessionInstance.emit(event, memberInstance);
      if ("talking" in payload.member) {
        const suffix = payload.member.talking ? "started" : "ended";
        roomSessionInstance.emit(`${event}.${suffix}`, memberInstance);
        const deprecatedSuffix = payload.member.talking ? "start" : "stop";
        roomSessionInstance.emit(`${event}.${deprecatedSuffix}`, memberInstance);
      }
      break;
    default:
      break;
  }
  getLogger17().trace("videoMemberWorker ended");
};

// src/video/workers/videoRoomWorker.ts
var videoRoomWorker = function* (options) {
  var _b;
  getLogger18().trace("videoRoomWorker started");
  const _a = options, { video, action } = _a, memberPositionWorkerParams = __objRest(_a, ["video", "action"]);
  const { type, payload } = action;
  const { get, set, remove } = options.instanceMap;
  let roomSessionInstance = get(payload.room_session.id);
  if (!roomSessionInstance) {
    roomSessionInstance = new RoomSessionAPI({
      video,
      payload
    });
  } else {
    roomSessionInstance.setPayload(payload);
  }
  set(payload.room_session.id, roomSessionInstance);
  if ((((_b = payload.room_session.members) == null ? void 0 : _b.length) || 0) > 0) {
    ;
    (payload.room_session.members || []).forEach((member) => {
      let memberInstance = get(member.id);
      if (!memberInstance) {
        memberInstance = new RoomSessionMemberAPI({
          roomSession: roomSessionInstance,
          payload: {
            room_id: payload.room_session.room_id,
            room_session_id: payload.room_session.id,
            member
          }
        });
      } else {
        memberInstance.setPayload({
          room_id: payload.room_session.room_id,
          room_session_id: payload.room_session.id,
          member
        });
      }
      set(member.id, memberInstance);
    });
  }
  switch (type) {
    case "video.room.started": {
      video.emit("room.started", roomSessionInstance);
      roomSessionInstance.emit("room.started", roomSessionInstance);
      break;
    }
    case "video.room.updated": {
      roomSessionInstance.emit("room.updated", roomSessionInstance);
      break;
    }
    case "video.room.ended": {
      video.emit("room.ended", roomSessionInstance);
      roomSessionInstance.emit("room.ended", roomSessionInstance);
      remove(payload.room_session.id);
      break;
    }
    case "video.room.subscribed": {
      yield sagaEffects14.spawn(MemberPosition.memberPositionWorker, __spreadProps(__spreadValues({}, memberPositionWorkerParams), {
        instance: roomSessionInstance,
        initialState: payload,
        dispatcher: function* (subType, subPayload) {
          yield sagaEffects14.fork(videoMemberWorker, __spreadProps(__spreadValues({}, options), {
            action: { type: subType, payload: subPayload }
          }));
        }
      }));
      roomSessionInstance.emit("room.subscribed", roomSessionInstance);
      break;
    }
    default:
      break;
  }
  getLogger18().trace("videoRoomWorker ended");
};

// src/video/workers/videoLayoutWorker.ts
import {
  getLogger as getLogger19,
  toExternalJSON as toExternalJSON6,
  stripNamespacePrefix as stripNamespacePrefix2
} from "@signalwire/core";
var videoLayoutWorker = function* (options) {
  getLogger19().trace("videoLayoutWorker started");
  const {
    action: { type, payload },
    instanceMap: { get }
  } = options;
  const roomSessionInstance = get(payload.room_session_id);
  if (!roomSessionInstance) {
    throw new Error("Missing room session instance for playback");
  }
  const event = stripNamespacePrefix2(type);
  switch (type) {
    case "video.layout.changed":
      roomSessionInstance.emit(event, toExternalJSON6(payload));
      break;
    default:
      break;
  }
  getLogger19().trace("videoLayoutWorker ended");
};

// src/video/workers/videoRoomAudienceWorker.ts
import {
  getLogger as getLogger20,
  toExternalJSON as toExternalJSON7
} from "@signalwire/core";
var videoRoomAudienceWorker = function* (options) {
  getLogger20().trace("videoRoomAudienceWorker started");
  const {
    action: { type, payload },
    instanceMap: { get }
  } = options;
  const roomSessionInstance = get(payload.room_session_id);
  if (!roomSessionInstance) {
    throw new Error("Missing room session instance for playback");
  }
  switch (type) {
    case "video.room.audience_count":
      roomSessionInstance.emit("room.audienceCount", toExternalJSON7(payload));
      break;
    default:
      break;
  }
  getLogger20().trace("videoRoomAudienceWorker ended");
};

// src/video/workers/videoRecordingWorker.ts
import {
  getLogger as getLogger21,
  stripNamespacePrefix as stripNamespacePrefix3
} from "@signalwire/core";
var videoRecordingWorker = function* (options) {
  getLogger21().trace("videoRecordingWorker started");
  const {
    action: { type, payload },
    instanceMap: { get, set, remove }
  } = options;
  const roomSessionInstance = get(payload.room_session_id);
  if (!roomSessionInstance) {
    throw new Error("Missing room session instance for playback");
  }
  let recordingInstance = get(payload.recording.id);
  if (!recordingInstance) {
    recordingInstance = new RoomSessionRecording({
      roomSession: roomSessionInstance,
      payload
    });
  } else {
    recordingInstance.setPayload(payload);
  }
  set(payload.recording.id, recordingInstance);
  const event = stripNamespacePrefix3(type);
  switch (type) {
    case "video.recording.started":
    case "video.recording.updated":
      roomSessionInstance.emit(event, recordingInstance);
      recordingInstance.emit(event, recordingInstance);
      break;
    case "video.recording.ended":
      roomSessionInstance.emit(event, recordingInstance);
      recordingInstance.emit(event, recordingInstance);
      remove(payload.recording.id);
      break;
    default:
      break;
  }
  getLogger21().trace("videoRecordingWorker ended");
};

// src/video/workers/videoPlaybackWorker.ts
import {
  getLogger as getLogger22,
  stripNamespacePrefix as stripNamespacePrefix4
} from "@signalwire/core";
var videoPlaybackWorker = function* (options) {
  getLogger22().trace("videoPlaybackWorker started");
  const {
    action: { type, payload },
    instanceMap: { get, set, remove }
  } = options;
  const roomSessionInstance = get(payload.room_session_id);
  if (!roomSessionInstance) {
    throw new Error("Missing room session instance for playback");
  }
  let playbackInstance = get(payload.playback.id);
  if (!playbackInstance) {
    playbackInstance = new RoomSessionPlayback({
      roomSession: roomSessionInstance,
      payload
    });
  } else {
    playbackInstance.setPayload(payload);
  }
  set(payload.playback.id, playbackInstance);
  const event = stripNamespacePrefix4(type);
  switch (type) {
    case "video.playback.started":
    case "video.playback.updated":
      roomSessionInstance.emit(event, playbackInstance);
      playbackInstance.emit(event, playbackInstance);
      break;
    case "video.playback.ended":
      roomSessionInstance.emit(event, playbackInstance);
      playbackInstance.emit(event, playbackInstance);
      remove(payload.playback.id);
      break;
    default:
      break;
  }
  getLogger22().trace("videoPlaybackWorker ended");
};

// src/video/workers/videoStreamWorker.ts
import {
  getLogger as getLogger23,
  stripNamespacePrefix as stripNamespacePrefix5
} from "@signalwire/core";
var videoStreamWorker = function* (options) {
  getLogger23().trace("videoStreamWorker started");
  const {
    action: { type, payload },
    instanceMap: { get, set, remove }
  } = options;
  const roomSessionInstance = get(payload.room_session_id);
  if (!roomSessionInstance) {
    throw new Error("Missing room session instance for stream");
  }
  let streamInstance = get(payload.stream.id);
  if (!streamInstance) {
    streamInstance = new RoomSessionStream({
      roomSession: roomSessionInstance,
      payload
    });
  } else {
    streamInstance.setPayload(payload);
  }
  set(payload.stream.id, streamInstance);
  const event = stripNamespacePrefix5(type);
  switch (type) {
    case "video.stream.started":
      roomSessionInstance.emit(event, streamInstance);
      streamInstance.emit(event, streamInstance);
      break;
    case "video.stream.ended":
      roomSessionInstance.emit(event, streamInstance);
      streamInstance.emit(event, streamInstance);
      remove(payload.stream.id);
      break;
    default:
      break;
  }
  getLogger23().trace("videoStreamWorker ended");
};

// src/video/workers/videoCallingWorker.ts
var videoCallingWorker = function* (options) {
  getLogger24().trace("videoCallingWorker started");
  const {
    channels: { swEventChannel },
    initialState
  } = options;
  const { video } = initialState;
  function* worker(action) {
    const { type } = action;
    switch (type) {
      case "video.room.started":
      case "video.room.updated":
      case "video.room.ended":
      case "video.room.subscribed":
        yield sagaEffects15.fork(videoRoomWorker, __spreadValues({
          action,
          video
        }, options));
        break;
      case "video.member.joined":
      case "video.member.left":
      case "video.member.updated":
      case "video.member.talking":
        yield sagaEffects15.fork(videoMemberWorker, __spreadValues({
          action,
          video
        }, options));
        break;
      case "video.layout.changed":
        yield sagaEffects15.fork(videoLayoutWorker, __spreadValues({
          action,
          video
        }, options));
        break;
      case "video.room.audience_count":
        yield sagaEffects15.fork(videoRoomAudienceWorker, __spreadValues({
          action,
          video
        }, options));
        break;
      case "video.playback.started":
      case "video.playback.updated":
      case "video.playback.ended":
        yield sagaEffects15.fork(videoPlaybackWorker, __spreadValues({
          action,
          video
        }, options));
        break;
      case "video.recording.started":
      case "video.recording.updated":
      case "video.recording.ended":
        yield sagaEffects15.fork(videoRecordingWorker, __spreadValues({
          action,
          video
        }, options));
        break;
      case "video.stream.started":
      case "video.stream.ended":
        yield sagaEffects15.fork(videoStreamWorker, __spreadValues({
          action,
          video
        }, options));
        break;
      default:
        getLogger24().warn(`Unknown video event: "${type}"`);
        break;
    }
  }
  const workerCatchable = sagaHelpers.createCatchableSaga(worker, (error) => {
    getLogger24().error("Voice calling event error", error);
  });
  const isVideoEvent = (action) => action.type.startsWith("video.");
  while (true) {
    const action = yield sagaEffects15.take(swEventChannel, isVideoEvent);
    yield sagaEffects15.fork(workerCatchable, action);
  }
  getLogger24().trace("videoCallingWorker ended");
};

// src/video/Video.ts
var Video = class extends BaseVideo {
  constructor(options) {
    super(options);
    __publicField(this, "_eventChannel", "video.rooms");
    __publicField(this, "_eventMap", {
      onRoomStarted: "room.started",
      onRoomEnded: "room.ended"
    });
    this._client.runWorker("videoCallingWorker", {
      worker: videoCallingWorker,
      initialState: {
        video: this
      }
    });
  }
  getSubscriptions() {
    const eventNamesWithPrefix = this.eventNames().map((event) => `video.${String(event)}`);
    return validateEventsToSubscribe3(eventNamesWithPrefix);
  }
  async getRoomSessions() {
    return new Promise(async (resolve, reject) => {
      try {
        const { rooms = [] } = await this._client.execute({
          method: "video.rooms.get",
          params: {}
        });
        const roomInstances = [];
        rooms.forEach((room) => {
          let roomInstance = this._client.instanceMap.get(room.id);
          if (!roomInstance) {
            roomInstance = new RoomSessionAPI({
              video: this,
              payload: { room_session: room }
            });
          } else {
            roomInstance.setPayload({
              room_session: room
            });
          }
          roomInstances.push(roomInstance);
          this._client.instanceMap.set(roomInstance.id, roomInstance);
        });
        resolve({ roomSessions: roomInstances });
      } catch (error) {
        console.error("Error listing room sessions", error);
        reject(error);
      }
    });
  }
  async getRoomSessionById(id) {
    return new Promise(async (resolve, reject) => {
      try {
        const { room } = await this._client.execute({
          method: "video.room.get",
          params: {
            room_session_id: id
          }
        });
        let roomInstance = this._client.instanceMap.get(room.id);
        if (!roomInstance) {
          roomInstance = new RoomSessionAPI({
            video: this,
            payload: { room_session: room }
          });
        } else {
          roomInstance.setPayload({
            room_session: room
          });
        }
        this._client.instanceMap.set(roomInstance.id, roomInstance);
        resolve({ roomSession: roomInstance });
      } catch (error) {
        console.error("Error retrieving the room session", error);
        reject(error);
      }
    });
  }
};

// src/client/createClient.ts
import { connect } from "@signalwire/core";

// src/client/Client.ts
import {
  BaseClient as CoreBaseClient
} from "@signalwire/core";
var Client = class extends CoreBaseClient {
};

// src/client/createClient.ts
var createClient = (userOptions) => {
  var _a;
  const { emitter, store } = setupInternals(userOptions);
  const client = connect({
    store: (_a = userOptions.store) != null ? _a : store,
    Component: Client
  })(__spreadProps(__spreadValues({}, userOptions), { store, emitter }));
  return client;
};

// src/client/clientConnect.ts
var clientConnect = (client) => {
  return client.connect().catch(() => {
  });
};

// src/SWClient.ts
var SWClient = class {
  constructor(options) {
    __publicField(this, "_task");
    __publicField(this, "_messaging");
    __publicField(this, "_pubSub");
    __publicField(this, "_chat");
    __publicField(this, "_voice");
    __publicField(this, "_video");
    __publicField(this, "userOptions");
    __publicField(this, "client");
    this.userOptions = options;
    this.client = createClient(options);
  }
  async connect() {
    await clientConnect(this.client);
  }
  disconnect() {
    return new Promise((resolve) => {
      const { sessionEmitter } = this.client;
      sessionEmitter.on("session.disconnected", () => {
        resolve();
      });
      this.client.disconnect();
    });
  }
  get task() {
    if (!this._task) {
      this._task = new Task(this);
    }
    return this._task;
  }
  get messaging() {
    if (!this._messaging) {
      this._messaging = new Messaging(this);
    }
    return this._messaging;
  }
  get pubSub() {
    if (!this._pubSub) {
      this._pubSub = new PubSub(this);
    }
    return this._pubSub;
  }
  get chat() {
    if (!this._chat) {
      this._chat = new Chat(this);
    }
    return this._chat;
  }
  get voice() {
    if (!this._voice) {
      this._voice = new Voice(this);
    }
    return this._voice;
  }
  get video() {
    if (!this._video) {
      this._video = new Video(this);
    }
    return this._video;
  }
};

// src/SignalWire.ts
var SignalWire = (options) => {
  return new Promise(async (resolve, reject) => {
    const swClient = new SWClient(options);
    try {
      await swClient.connect();
      resolve(swClient);
    } catch (error) {
      reject(error);
    }
  });
};
export {
  Chat_exports as Chat,
  Messaging_exports as Messaging,
  PubSub_exports as PubSub,
  SignalWire,
  Task_exports as Task,
  Video_exports as Video,
  Voice_exports as Voice,
  config,
  getConfig
};
//# sourceMappingURL=index.node.mjs.map
