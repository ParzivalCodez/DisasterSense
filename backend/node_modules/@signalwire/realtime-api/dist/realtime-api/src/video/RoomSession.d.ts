import { BaseComponentOptionsWithPayload, VideoRoomSessionContract, ConsumerContract, EntityUpdated, BaseConsumer, EventEmitter, VideoRoomEventParams, Optional } from '@signalwire/core';
import { RealTimeRoomApiEvents } from '../types';
import { RoomSessionMember } from './RoomSessionMember';
export interface RoomSession extends VideoRoomSessionContract, ConsumerContract<RealTimeRoomApiEvents, RoomSessionFullState> {
    setPayload(payload: Optional<VideoRoomEventParams, 'room'>): void;
    /**
     * Returns a list of members currently in the room.
     *
     * @example
     * ```typescript
     * await room.getMembers()
     * ```
     */
    getMembers(): Promise<{
        members: RoomSessionMember[];
    }>;
}
export declare type RoomSessionUpdated = EntityUpdated<RoomSession>;
export interface RoomSessionFullState extends Omit<RoomSession, 'members'> {
    /** List of members that are part of this room session */
    members?: RoomSessionMember[];
}
declare type RoomSessionPayload = Optional<VideoRoomEventParams, 'room'>;
export interface RoomSessionConsumerOptions extends BaseComponentOptionsWithPayload<RoomSessionPayload> {
}
export declare class RoomSessionConsumer extends BaseConsumer<RealTimeRoomApiEvents> {
    private _payload;
    /** @internal */
    protected subscribeParams: {
        get_initial_state: boolean;
    };
    /** @internal */
    private debouncedSubscribe;
    constructor(options: RoomSessionConsumerOptions);
    get id(): string;
    get roomSessionId(): string;
    get roomId(): string;
    get name(): string;
    get displayName(): string;
    get hideVideoMuted(): boolean;
    get layoutName(): string;
    get meta(): Record<string, unknown> | undefined;
    get previewUrl(): string | undefined;
    get recording(): boolean;
    get locked(): boolean;
    get eventChannel(): string;
    get prioritizeHandraise(): Boolean;
    /** @internal */
    protected getSubscriptions(): ("room.started" | "room.ended" | "room.subscribed" | "room.updated" | "member.joined" | "member.left" | "member.updated" | "layout.changed" | import("@signalwire/core").VideoRecordingEventNames | import("@signalwire/core").VideoPlaybackEventNames | import("@signalwire/core").VideoStreamEventNames | "member.updated.deaf" | "member.updated.visible" | "member.updated.audioMuted" | "member.updated.videoMuted" | "member.updated.inputVolume" | "member.updated.outputVolume" | "member.updated.inputSensitivity" | import("@signalwire/core").MemberTalkingEventNames | "memberList.updated" | "room.audienceCount")[];
    /** @internal */
    protected _internal_on(event: keyof RealTimeRoomApiEvents, fn: EventEmitter.EventListener<RealTimeRoomApiEvents, any>): EventEmitter<RealTimeRoomApiEvents, any>;
    on<T extends keyof RealTimeRoomApiEvents>(event: T, fn: EventEmitter.EventListener<RealTimeRoomApiEvents, T>): EventEmitter<RealTimeRoomApiEvents, any>;
    once<T extends keyof RealTimeRoomApiEvents>(event: T, fn: EventEmitter.EventListener<RealTimeRoomApiEvents, T>): EventEmitter<RealTimeRoomApiEvents, any>;
    off<T extends keyof RealTimeRoomApiEvents>(event: T, fn: EventEmitter.EventListener<RealTimeRoomApiEvents, T>): EventEmitter<RealTimeRoomApiEvents, any>;
    /**
     * @privateRemarks
     *
     * Override BaseConsumer `subscribe` to resolve the promise when the 'room.subscribed'
     * event comes. This way we can return to the user the room full state.
     * Note: the payload will go through an EventTrasform - see the `type: roomSessionSubscribed`
     * below.
     */
    subscribe(): Promise<unknown>;
    /** @internal */
    protected setPayload(payload: Optional<VideoRoomEventParams, 'room'>): void;
    getMembers(): Promise<unknown>;
}
export declare const RoomSessionAPI: import("@signalwire/core").ConstructableType<RoomSessionConsumer>;
export declare const createRoomSessionObject: (params: RoomSessionConsumerOptions) => RoomSession;
export {};
//# sourceMappingURL=RoomSession.d.ts.map