{
  "version": 3,
  "sources": ["../../../node_modules/@redux-saga/symbols/dist/redux-saga-symbols.cjs.js", "../../../node_modules/@babel/runtime/helpers/extends.js", "../../../node_modules/@redux-saga/is/dist/redux-saga-is.cjs.js", "../../../node_modules/@redux-saga/delay-p/dist/redux-saga-delay-p.cjs.js", "../../../node_modules/@redux-saga/core/dist/io-d39dbb58.js", "../../../node_modules/@redux-saga/core/dist/redux-saga-effects.prod.cjs.js", "../../../node_modules/@redux-saga/core/dist/io-a03c6210.js", "../../../node_modules/@redux-saga/core/dist/redux-saga-effects.dev.cjs.js", "../../../node_modules/@redux-saga/core/dist/redux-saga-effects.cjs.js", "../src/index.ts", "../src/video/Video.ts", "../src/AutoSubscribeConsumer.ts", "../src/video/RoomSession.ts", "../src/video/RoomSessionMember.ts", "../src/video/workers/videoCallingWorker.ts", "../src/video/workers/videoRoomWorker.ts", "../src/video/workers/videoMemberWorker.ts", "../src/video/workers/videoPlaybackWorker.ts", "../src/video/workers/videoRecordingWorker.ts", "../src/video/workers/videoStreamWorker.ts", "../src/video/workers/videoLayoutWorker.ts", "../src/video/workers/videoRoomAudienceWorker.ts", "../src/client/Client.ts", "../src/client/clientConnect.ts", "../src/client/setupClient.ts", "../src/utils/internals.ts", "../src/configure/index.ts", "../src/Session.ts", "../src/client/clientProxyFactory.ts", "../src/client/getClient.ts", "../src/video/VideoClient.ts", "../src/createClient.ts", "../src/Client.ts", "../src/chat/Chat.ts", "../src/chat/ChatClient.ts", "../src/pubSub/PubSub.ts", "../src/pubSub/PubSubClient.ts", "../src/task/Task.ts", "../src/task/workers.ts", "../src/common/clientContext.ts", "../src/task/TaskClient.ts", "../src/task/send.ts", "../src/messaging/Messaging.ts", "../src/messaging/workers/messagingWorker.ts", "../src/messaging/MessagingClient.ts", "../src/messaging/Message.ts", "../src/voice/Voice.ts", "../src/voice/workers/voiceCallStateWorker.ts", "../src/voice/Call.ts", "../src/voice/utils.ts", "../src/voice/Playlist.ts", "../src/voice/CallPrompt.ts", "../src/voice/CallDetect.ts", "../src/voice/CallCollect.ts", "../src/voice/DeviceBuilder.ts", "../src/voice/workers/voiceCallReceiveWorker.ts", "../src/voice/workers/voiceCallPlayWorker.ts", "../src/voice/CallPlayback.ts", "../src/voice/workers/voiceCallRecordWorker.ts", "../src/voice/CallRecording.ts", "../src/voice/workers/voiceCallCollectWorker.ts", "../src/voice/workers/voiceCallTapWorker.ts", "../src/voice/CallTap.ts", "../src/voice/workers/voiceCallConnectWorker.ts", "../src/voice/workers/voiceCallDialWorker.ts", "../src/voice/workers/VoiceCallSendDigitWorker.ts", "../src/voice/workers/voiceCallDetectWorker.ts", "../src/voice/workers/voiceCallingWorker.ts", "../src/voice/VoiceClient.ts"],
  "sourcesContent": ["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar createSymbol = function createSymbol(name) {\n  return \"@@redux-saga/\" + name;\n};\n\nvar CANCEL =\n/*#__PURE__*/\ncreateSymbol('CANCEL_PROMISE');\nvar CHANNEL_END_TYPE =\n/*#__PURE__*/\ncreateSymbol('CHANNEL_END');\nvar IO =\n/*#__PURE__*/\ncreateSymbol('IO');\nvar MATCH =\n/*#__PURE__*/\ncreateSymbol('MATCH');\nvar MULTICAST =\n/*#__PURE__*/\ncreateSymbol('MULTICAST');\nvar SAGA_ACTION =\n/*#__PURE__*/\ncreateSymbol('SAGA_ACTION');\nvar SELF_CANCELLATION =\n/*#__PURE__*/\ncreateSymbol('SELF_CANCELLATION');\nvar TASK =\n/*#__PURE__*/\ncreateSymbol('TASK');\nvar TASK_CANCEL =\n/*#__PURE__*/\ncreateSymbol('TASK_CANCEL');\nvar TERMINATE =\n/*#__PURE__*/\ncreateSymbol('TERMINATE');\nvar SAGA_LOCATION =\n/*#__PURE__*/\ncreateSymbol('LOCATION');\n\nexports.CANCEL = CANCEL;\nexports.CHANNEL_END_TYPE = CHANNEL_END_TYPE;\nexports.IO = IO;\nexports.MATCH = MATCH;\nexports.MULTICAST = MULTICAST;\nexports.SAGA_ACTION = SAGA_ACTION;\nexports.SAGA_LOCATION = SAGA_LOCATION;\nexports.SELF_CANCELLATION = SELF_CANCELLATION;\nexports.TASK = TASK;\nexports.TASK_CANCEL = TASK_CANCEL;\nexports.TERMINATE = TERMINATE;\n", "function _extends() {\n  module.exports = _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _extends.apply(this, arguments);\n}\nmodule.exports = _extends, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar symbols = require('@redux-saga/symbols');\n\nvar undef = function undef(v) {\n  return v === null || v === undefined;\n};\nvar notUndef = function notUndef(v) {\n  return v !== null && v !== undefined;\n};\nvar func = function func(f) {\n  return typeof f === 'function';\n};\nvar number = function number(n) {\n  return typeof n === 'number';\n};\nvar string = function string(s) {\n  return typeof s === 'string';\n};\nvar array = Array.isArray;\nvar object = function object(obj) {\n  return obj && !array(obj) && typeof obj === 'object';\n};\nvar promise = function promise(p) {\n  return p && func(p.then);\n};\nvar iterator = function iterator(it) {\n  return it && func(it.next) && func(it.throw);\n};\nvar iterable = function iterable(it) {\n  return it && func(Symbol) ? func(it[Symbol.iterator]) : array(it);\n};\nvar task = function task(t) {\n  return t && t[symbols.TASK];\n};\nvar sagaAction = function sagaAction(a) {\n  return Boolean(a && a[symbols.SAGA_ACTION]);\n};\nvar observable = function observable(ob) {\n  return ob && func(ob.subscribe);\n};\nvar buffer = function buffer(buf) {\n  return buf && func(buf.isEmpty) && func(buf.take) && func(buf.put);\n};\nvar pattern = function pattern(pat) {\n  return pat && (string(pat) || symbol(pat) || func(pat) || array(pat) && pat.every(pattern));\n};\nvar channel = function channel(ch) {\n  return ch && func(ch.take) && func(ch.close);\n};\nvar stringableFunc = function stringableFunc(f) {\n  return func(f) && f.hasOwnProperty('toString');\n};\nvar symbol = function symbol(sym) {\n  return Boolean(sym) && typeof Symbol === 'function' && sym.constructor === Symbol && sym !== Symbol.prototype;\n};\nvar multicast = function multicast(ch) {\n  return channel(ch) && ch[symbols.MULTICAST];\n};\nvar effect = function effect(eff) {\n  return eff && eff[symbols.IO];\n};\n\nexports.array = array;\nexports.buffer = buffer;\nexports.channel = channel;\nexports.effect = effect;\nexports.func = func;\nexports.iterable = iterable;\nexports.iterator = iterator;\nexports.multicast = multicast;\nexports.notUndef = notUndef;\nexports.number = number;\nexports.object = object;\nexports.observable = observable;\nexports.pattern = pattern;\nexports.promise = promise;\nexports.sagaAction = sagaAction;\nexports.string = string;\nexports.stringableFunc = stringableFunc;\nexports.symbol = symbol;\nexports.task = task;\nexports.undef = undef;\n", "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar symbols = require('@redux-saga/symbols');\n\nvar MAX_SIGNED_INT = 2147483647;\nfunction delayP(ms, val) {\n  if (val === void 0) {\n    val = true;\n  }\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#maximum_delay_value\n  if (process.env.NODE_ENV !== 'production' && ms > MAX_SIGNED_INT) {\n    throw new Error('delay only supports a maximum value of ' + MAX_SIGNED_INT + 'ms');\n  }\n\n  var timeoutId;\n  var promise = new Promise(function (resolve) {\n    timeoutId = setTimeout(resolve, Math.min(MAX_SIGNED_INT, ms), val);\n  });\n\n  promise[symbols.CANCEL] = function () {\n    clearTimeout(timeoutId);\n  };\n\n  return promise;\n}\n\nexports.default = delayP;\n", "'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar symbols = require('@redux-saga/symbols');\nvar _extends = _interopDefault(require('@babel/runtime/helpers/extends'));\nvar is = require('@redux-saga/is');\nvar delayP = _interopDefault(require('@redux-saga/delay-p'));\n\nvar konst = function konst(v) {\n  return function () {\n    return v;\n  };\n};\nvar kTrue =\n/*#__PURE__*/\nkonst(true);\n\nexports.noop = function noop() {};\nvar identity = function identity(v) {\n  return v;\n};\nvar assignWithSymbols = function assignWithSymbols(target, source) {\n  _extends(target, source);\n\n  if (Object.getOwnPropertySymbols) {\n    Object.getOwnPropertySymbols(source).forEach(function (s) {\n      target[s] = source[s];\n    });\n  }\n};\nvar flatMap = function flatMap(mapper, arr) {\n  var _ref;\n\n  return (_ref = []).concat.apply(_ref, arr.map(mapper));\n};\nfunction remove(array, item) {\n  var index = array.indexOf(item);\n\n  if (index >= 0) {\n    array.splice(index, 1);\n  }\n}\nfunction once(fn) {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n    }\n\n    called = true;\n    fn();\n  };\n}\n\nvar kThrow = function kThrow(err) {\n  throw err;\n};\n\nvar kReturn = function kReturn(value) {\n  return {\n    value: value,\n    done: true\n  };\n};\n\nfunction makeIterator(next, thro, name) {\n  if (thro === void 0) {\n    thro = kThrow;\n  }\n\n  if (name === void 0) {\n    name = 'iterator';\n  }\n\n  var iterator = {\n    meta: {\n      name: name\n    },\n    next: next,\n    throw: thro,\n    return: kReturn,\n    isSagaIterator: true\n  };\n\n  if (typeof Symbol !== 'undefined') {\n    iterator[Symbol.iterator] = function () {\n      return iterator;\n    };\n  }\n\n  return iterator;\n}\nfunction logError(error, _ref2) {\n  var sagaStack = _ref2.sagaStack;\n\n  /*eslint-disable no-console*/\n  console.error(error);\n  console.error(sagaStack);\n}\n\nvar createEmptyArray = function createEmptyArray(n) {\n  return Array.apply(null, new Array(n));\n};\nvar wrapSagaDispatch = function wrapSagaDispatch(dispatch) {\n  return function (action) {\n\n    return dispatch(Object.defineProperty(action, symbols.SAGA_ACTION, {\n      value: true\n    }));\n  };\n};\nvar shouldTerminate = function shouldTerminate(res) {\n  return res === symbols.TERMINATE;\n};\nvar shouldCancel = function shouldCancel(res) {\n  return res === symbols.TASK_CANCEL;\n};\nvar shouldComplete = function shouldComplete(res) {\n  return shouldTerminate(res) || shouldCancel(res);\n};\nfunction createAllStyleChildCallbacks(shape, parentCallback) {\n  var keys = Object.keys(shape);\n  var totalCount = keys.length;\n\n  var completedCount = 0;\n  var completed;\n  var results = is.array(shape) ? createEmptyArray(totalCount) : {};\n  var childCallbacks = {};\n\n  function checkEnd() {\n    if (completedCount === totalCount) {\n      completed = true;\n      parentCallback(results);\n    }\n  }\n\n  keys.forEach(function (key) {\n    var chCbAtKey = function chCbAtKey(res, isErr) {\n      if (completed) {\n        return;\n      }\n\n      if (isErr || shouldComplete(res)) {\n        parentCallback.cancel();\n        parentCallback(res, isErr);\n      } else {\n        results[key] = res;\n        completedCount++;\n        checkEnd();\n      }\n    };\n\n    chCbAtKey.cancel = exports.noop;\n    childCallbacks[key] = chCbAtKey;\n  });\n\n  parentCallback.cancel = function () {\n    if (!completed) {\n      completed = true;\n      keys.forEach(function (key) {\n        return childCallbacks[key].cancel();\n      });\n    }\n  };\n\n  return childCallbacks;\n}\nfunction getMetaInfo(fn) {\n  return {\n    name: fn.name || 'anonymous',\n    location: getLocation(fn)\n  };\n}\nfunction getLocation(instrumented) {\n  return instrumented[symbols.SAGA_LOCATION];\n}\n\nvar BUFFER_OVERFLOW = \"Channel's Buffer overflow!\";\nvar ON_OVERFLOW_THROW = 1;\nvar ON_OVERFLOW_DROP = 2;\nvar ON_OVERFLOW_SLIDE = 3;\nvar ON_OVERFLOW_EXPAND = 4;\nvar zeroBuffer = {\n  isEmpty: kTrue,\n  put: exports.noop,\n  take: exports.noop\n};\n\nfunction ringBuffer(limit, overflowAction) {\n  if (limit === void 0) {\n    limit = 10;\n  }\n\n  var arr = new Array(limit);\n  var length = 0;\n  var pushIndex = 0;\n  var popIndex = 0;\n\n  var push = function push(it) {\n    arr[pushIndex] = it;\n    pushIndex = (pushIndex + 1) % limit;\n    length++;\n  };\n\n  var take = function take() {\n    if (length != 0) {\n      var it = arr[popIndex];\n      arr[popIndex] = null;\n      length--;\n      popIndex = (popIndex + 1) % limit;\n      return it;\n    }\n  };\n\n  var flush = function flush() {\n    var items = [];\n\n    while (length) {\n      items.push(take());\n    }\n\n    return items;\n  };\n\n  return {\n    isEmpty: function isEmpty() {\n      return length == 0;\n    },\n    put: function put(it) {\n      if (length < limit) {\n        push(it);\n      } else {\n        var doubledLimit;\n\n        switch (overflowAction) {\n          case ON_OVERFLOW_THROW:\n            throw new Error(BUFFER_OVERFLOW);\n\n          case ON_OVERFLOW_SLIDE:\n            arr[pushIndex] = it;\n            pushIndex = (pushIndex + 1) % limit;\n            popIndex = pushIndex;\n            break;\n\n          case ON_OVERFLOW_EXPAND:\n            doubledLimit = 2 * limit;\n            arr = flush();\n            length = arr.length;\n            pushIndex = arr.length;\n            popIndex = 0;\n            arr.length = doubledLimit;\n            limit = doubledLimit;\n            push(it);\n            break;\n\n          default: // DROP\n\n        }\n      }\n    },\n    take: take,\n    flush: flush\n  };\n}\n\nvar none = function none() {\n  return zeroBuffer;\n};\nvar fixed = function fixed(limit) {\n  return ringBuffer(limit, ON_OVERFLOW_THROW);\n};\nvar dropping = function dropping(limit) {\n  return ringBuffer(limit, ON_OVERFLOW_DROP);\n};\nvar sliding = function sliding(limit) {\n  return ringBuffer(limit, ON_OVERFLOW_SLIDE);\n};\nvar expanding = function expanding(initialSize) {\n  return ringBuffer(initialSize, ON_OVERFLOW_EXPAND);\n};\n\nvar buffers = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  none: none,\n  fixed: fixed,\n  dropping: dropping,\n  sliding: sliding,\n  expanding: expanding\n});\n\nvar TAKE = 'TAKE';\nvar PUT = 'PUT';\nvar ALL = 'ALL';\nvar RACE = 'RACE';\nvar CALL = 'CALL';\nvar CPS = 'CPS';\nvar FORK = 'FORK';\nvar JOIN = 'JOIN';\nvar CANCEL = 'CANCEL';\nvar SELECT = 'SELECT';\nvar ACTION_CHANNEL = 'ACTION_CHANNEL';\nvar CANCELLED = 'CANCELLED';\nvar FLUSH = 'FLUSH';\nvar GET_CONTEXT = 'GET_CONTEXT';\nvar SET_CONTEXT = 'SET_CONTEXT';\n\nvar effectTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  TAKE: TAKE,\n  PUT: PUT,\n  ALL: ALL,\n  RACE: RACE,\n  CALL: CALL,\n  CPS: CPS,\n  FORK: FORK,\n  JOIN: JOIN,\n  CANCEL: CANCEL,\n  SELECT: SELECT,\n  ACTION_CHANNEL: ACTION_CHANNEL,\n  CANCELLED: CANCELLED,\n  FLUSH: FLUSH,\n  GET_CONTEXT: GET_CONTEXT,\n  SET_CONTEXT: SET_CONTEXT\n});\n\nvar makeEffect = function makeEffect(type, payload) {\n  var _ref;\n\n  return _ref = {}, _ref[symbols.IO] = true, _ref.combinator = false, _ref.type = type, _ref.payload = payload, _ref;\n};\n\nvar detach = function detach(eff) {\n\n  return makeEffect(FORK, _extends({}, eff.payload, {\n    detached: true\n  }));\n};\nfunction take(patternOrChannel, multicastPattern) {\n  if (patternOrChannel === void 0) {\n    patternOrChannel = '*';\n  }\n\n  if (is.pattern(patternOrChannel)) {\n    if (is.notUndef(multicastPattern)) {\n      /* eslint-disable no-console */\n      console.warn(\"take(pattern) takes one argument but two were provided. Consider passing an array for listening to several action types\");\n    }\n\n    return makeEffect(TAKE, {\n      pattern: patternOrChannel\n    });\n  }\n\n  if (is.multicast(patternOrChannel) && is.notUndef(multicastPattern) && is.pattern(multicastPattern)) {\n    return makeEffect(TAKE, {\n      channel: patternOrChannel,\n      pattern: multicastPattern\n    });\n  }\n\n  if (is.channel(patternOrChannel)) {\n    if (is.notUndef(multicastPattern)) {\n      /* eslint-disable no-console */\n      console.warn(\"take(channel) takes one argument but two were provided. Second argument is ignored.\");\n    }\n\n    return makeEffect(TAKE, {\n      channel: patternOrChannel\n    });\n  }\n}\nvar takeMaybe = function takeMaybe() {\n  var eff = take.apply(void 0, arguments);\n  eff.payload.maybe = true;\n  return eff;\n};\nfunction put(channel, action) {\n\n  if (is.undef(action)) {\n    action = channel; // `undefined` instead of `null` to make default parameter work\n\n    channel = undefined;\n  }\n\n  return makeEffect(PUT, {\n    channel: channel,\n    action: action\n  });\n}\nvar putResolve = function putResolve() {\n  var eff = put.apply(void 0, arguments);\n  eff.payload.resolve = true;\n  return eff;\n};\nfunction all(effects) {\n  var eff = makeEffect(ALL, effects);\n  eff.combinator = true;\n  return eff;\n}\nfunction race(effects) {\n  var eff = makeEffect(RACE, effects);\n  eff.combinator = true;\n  return eff;\n} // this match getFnCallDescriptor logic\n\nfunction getFnCallDescriptor(fnDescriptor, args) {\n  var context = null;\n  var fn;\n\n  if (is.func(fnDescriptor)) {\n    fn = fnDescriptor;\n  } else {\n    if (is.array(fnDescriptor)) {\n      context = fnDescriptor[0];\n      fn = fnDescriptor[1];\n    } else {\n      context = fnDescriptor.context;\n      fn = fnDescriptor.fn;\n    }\n\n    if (context && is.string(fn) && is.func(context[fn])) {\n      fn = context[fn];\n    }\n  }\n\n  return {\n    context: context,\n    fn: fn,\n    args: args\n  };\n}\n\nfunction call(fnDescriptor) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return makeEffect(CALL, getFnCallDescriptor(fnDescriptor, args));\n}\nfunction apply(context, fn, args) {\n  if (args === void 0) {\n    args = [];\n  }\n\n  return makeEffect(CALL, getFnCallDescriptor([context, fn], args));\n}\nfunction cps(fnDescriptor) {\n\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  return makeEffect(CPS, getFnCallDescriptor(fnDescriptor, args));\n}\nfunction fork(fnDescriptor) {\n\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n\n  return makeEffect(FORK, getFnCallDescriptor(fnDescriptor, args));\n}\nfunction spawn(fnDescriptor) {\n\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n\n  return detach(fork.apply(void 0, [fnDescriptor].concat(args)));\n}\nfunction join(taskOrTasks) {\n\n  return makeEffect(JOIN, taskOrTasks);\n}\nfunction cancel(taskOrTasks) {\n  if (taskOrTasks === void 0) {\n    taskOrTasks = symbols.SELF_CANCELLATION;\n  }\n\n  return makeEffect(CANCEL, taskOrTasks);\n}\nfunction select(selector) {\n  if (selector === void 0) {\n    selector = identity;\n  }\n\n  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    args[_key5 - 1] = arguments[_key5];\n  }\n\n  return makeEffect(SELECT, {\n    selector: selector,\n    args: args\n  });\n}\n/**\n  channel(pattern, [buffer])    => creates a proxy channel for store actions\n**/\n\nfunction actionChannel(pattern, buffer) {\n\n  return makeEffect(ACTION_CHANNEL, {\n    pattern: pattern,\n    buffer: buffer\n  });\n}\nfunction cancelled() {\n  return makeEffect(CANCELLED, {});\n}\nfunction flush(channel) {\n\n  return makeEffect(FLUSH, channel);\n}\nfunction getContext(prop) {\n\n  return makeEffect(GET_CONTEXT, prop);\n}\nfunction setContext(props) {\n\n  return makeEffect(SET_CONTEXT, props);\n}\nvar delay =\n/*#__PURE__*/\ncall.bind(null, delayP);\n\nexports.ACTION_CHANNEL = ACTION_CHANNEL;\nexports.ALL = ALL;\nexports.CALL = CALL;\nexports.CANCEL = CANCEL;\nexports.CANCELLED = CANCELLED;\nexports.CPS = CPS;\nexports.FLUSH = FLUSH;\nexports.FORK = FORK;\nexports.GET_CONTEXT = GET_CONTEXT;\nexports.JOIN = JOIN;\nexports.PUT = PUT;\nexports.RACE = RACE;\nexports.SELECT = SELECT;\nexports.SET_CONTEXT = SET_CONTEXT;\nexports.TAKE = TAKE;\nexports.actionChannel = actionChannel;\nexports.all = all;\nexports.apply = apply;\nexports.assignWithSymbols = assignWithSymbols;\nexports.buffers = buffers;\nexports.call = call;\nexports.cancel = cancel;\nexports.cancelled = cancelled;\nexports.cps = cps;\nexports.createAllStyleChildCallbacks = createAllStyleChildCallbacks;\nexports.createEmptyArray = createEmptyArray;\nexports.delay = delay;\nexports.detach = detach;\nexports.effectTypes = effectTypes;\nexports.expanding = expanding;\nexports.flatMap = flatMap;\nexports.flush = flush;\nexports.fork = fork;\nexports.getContext = getContext;\nexports.getLocation = getLocation;\nexports.getMetaInfo = getMetaInfo;\nexports.identity = identity;\nexports.join = join;\nexports.kTrue = kTrue;\nexports.logError = logError;\nexports.makeIterator = makeIterator;\nexports.none = none;\nexports.once = once;\nexports.put = put;\nexports.putResolve = putResolve;\nexports.race = race;\nexports.remove = remove;\nexports.select = select;\nexports.setContext = setContext;\nexports.shouldCancel = shouldCancel;\nexports.shouldComplete = shouldComplete;\nexports.shouldTerminate = shouldTerminate;\nexports.sliding = sliding;\nexports.spawn = spawn;\nexports.take = take;\nexports.takeMaybe = takeMaybe;\nexports.wrapSagaDispatch = wrapSagaDispatch;\n", "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nrequire('@redux-saga/symbols');\nrequire('@babel/runtime/helpers/extends');\nvar is = require('@redux-saga/is');\nvar io = require('./io-d39dbb58.js');\nrequire('@redux-saga/delay-p');\n\nvar done = function done(value) {\n  return {\n    done: true,\n    value: value\n  };\n};\n\nvar qEnd = {};\nfunction safeName(patternOrChannel) {\n  if (is.channel(patternOrChannel)) {\n    return 'channel';\n  }\n\n  if (is.stringableFunc(patternOrChannel)) {\n    return String(patternOrChannel);\n  }\n\n  if (is.func(patternOrChannel)) {\n    return patternOrChannel.name;\n  }\n\n  return String(patternOrChannel);\n}\nfunction fsmIterator(fsm, startState, name) {\n  var stateUpdater,\n      errorState,\n      effect,\n      nextState = startState;\n\n  function next(arg, error) {\n    if (nextState === qEnd) {\n      return done(arg);\n    }\n\n    if (error && !errorState) {\n      nextState = qEnd;\n      throw error;\n    } else {\n      stateUpdater && stateUpdater(arg);\n      var currentState = error ? fsm[errorState](error) : fsm[nextState]();\n      nextState = currentState.nextState;\n      effect = currentState.effect;\n      stateUpdater = currentState.stateUpdater;\n      errorState = currentState.errorState;\n      return nextState === qEnd ? done(arg) : effect;\n    }\n  }\n\n  return io.makeIterator(next, function (error) {\n    return next(null, error);\n  }, name);\n}\n\nfunction takeEvery(patternOrChannel, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  var yTake = {\n    done: false,\n    value: io.take(patternOrChannel)\n  };\n\n  var yFork = function yFork(ac) {\n    return {\n      done: false,\n      value: io.fork.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var action,\n      setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yTake,\n        stateUpdater: setAction\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: 'q1',\n        effect: yFork(action)\n      };\n    }\n  }, 'q1', \"takeEvery(\" + safeName(patternOrChannel) + \", \" + worker.name + \")\");\n}\n\nfunction takeLatest(patternOrChannel, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  var yTake = {\n    done: false,\n    value: io.take(patternOrChannel)\n  };\n\n  var yFork = function yFork(ac) {\n    return {\n      done: false,\n      value: io.fork.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var yCancel = function yCancel(task) {\n    return {\n      done: false,\n      value: io.cancel(task)\n    };\n  };\n\n  var task, action;\n\n  var setTask = function setTask(t) {\n    return task = t;\n  };\n\n  var setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yTake,\n        stateUpdater: setAction\n      };\n    },\n    q2: function q2() {\n      return task ? {\n        nextState: 'q3',\n        effect: yCancel(task)\n      } : {\n        nextState: 'q1',\n        effect: yFork(action),\n        stateUpdater: setTask\n      };\n    },\n    q3: function q3() {\n      return {\n        nextState: 'q1',\n        effect: yFork(action),\n        stateUpdater: setTask\n      };\n    }\n  }, 'q1', \"takeLatest(\" + safeName(patternOrChannel) + \", \" + worker.name + \")\");\n}\n\nfunction takeLeading(patternOrChannel, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  var yTake = {\n    done: false,\n    value: io.take(patternOrChannel)\n  };\n\n  var yCall = function yCall(ac) {\n    return {\n      done: false,\n      value: io.call.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var action;\n\n  var setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yTake,\n        stateUpdater: setAction\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: 'q1',\n        effect: yCall(action)\n      };\n    }\n  }, 'q1', \"takeLeading(\" + safeName(patternOrChannel) + \", \" + worker.name + \")\");\n}\n\nfunction throttle(delayLength, patternOrChannel, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  var action, channel;\n\n  var yTake = function yTake() {\n    return {\n      done: false,\n      value: io.take(channel)\n    };\n  };\n\n  var yFork = function yFork(ac) {\n    return {\n      done: false,\n      value: io.fork.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var yDelay = {\n    done: false,\n    value: io.delay(delayLength)\n  };\n\n  var setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  var setChannel = function setChannel(ch) {\n    return channel = ch;\n  };\n\n  var needsChannel = !is.channel(patternOrChannel);\n\n  if (!needsChannel) {\n    setChannel(patternOrChannel);\n  }\n\n  return fsmIterator({\n    q1: function q1() {\n      var yActionChannel = {\n        done: false,\n        value: io.actionChannel(patternOrChannel, io.sliding(1))\n      };\n      return {\n        nextState: 'q2',\n        effect: yActionChannel,\n        stateUpdater: setChannel\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: 'q3',\n        effect: yTake(),\n        stateUpdater: setAction\n      };\n    },\n    q3: function q3() {\n      return {\n        nextState: 'q4',\n        effect: yFork(action)\n      };\n    },\n    q4: function q4() {\n      return {\n        nextState: 'q2',\n        effect: yDelay\n      };\n    }\n  }, needsChannel ? 'q1' : 'q2', \"throttle(\" + safeName(patternOrChannel) + \", \" + worker.name + \")\");\n}\n\nfunction retry(maxTries, delayLength, fn) {\n  var counter = maxTries;\n\n  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  var yCall = {\n    done: false,\n    value: io.call.apply(void 0, [fn].concat(args))\n  };\n  var yDelay = {\n    done: false,\n    value: io.delay(delayLength)\n  };\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yCall,\n        errorState: 'q10'\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: qEnd\n      };\n    },\n    q10: function q10(error) {\n      counter -= 1;\n\n      if (counter <= 0) {\n        throw error;\n      }\n\n      return {\n        nextState: 'q1',\n        effect: yDelay\n      };\n    }\n  }, 'q1', \"retry(\" + fn.name + \")\");\n}\n\nfunction debounceHelper(delayLength, patternOrChannel, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  var action, raceOutput;\n  var yTake = {\n    done: false,\n    value: io.take(patternOrChannel)\n  };\n  var yRace = {\n    done: false,\n    value: io.race({\n      action: io.take(patternOrChannel),\n      debounce: io.delay(delayLength)\n    })\n  };\n\n  var yFork = function yFork(ac) {\n    return {\n      done: false,\n      value: io.fork.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var yNoop = function yNoop(value) {\n    return {\n      done: false,\n      value: value\n    };\n  };\n\n  var setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  var setRaceOutput = function setRaceOutput(ro) {\n    return raceOutput = ro;\n  };\n\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yTake,\n        stateUpdater: setAction\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: 'q3',\n        effect: yRace,\n        stateUpdater: setRaceOutput\n      };\n    },\n    q3: function q3() {\n      return raceOutput.debounce ? {\n        nextState: 'q1',\n        effect: yFork(action)\n      } : {\n        nextState: 'q2',\n        effect: yNoop(raceOutput.action),\n        stateUpdater: setAction\n      };\n    }\n  }, 'q1', \"debounce(\" + safeName(patternOrChannel) + \", \" + worker.name + \")\");\n}\n\nfunction takeEvery$1(patternOrChannel, worker) {\n\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  return io.fork.apply(void 0, [takeEvery, patternOrChannel, worker].concat(args));\n}\nfunction takeLatest$1(patternOrChannel, worker) {\n\n  for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    args[_key2 - 2] = arguments[_key2];\n  }\n\n  return io.fork.apply(void 0, [takeLatest, patternOrChannel, worker].concat(args));\n}\nfunction takeLeading$1(patternOrChannel, worker) {\n\n  for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n    args[_key3 - 2] = arguments[_key3];\n  }\n\n  return io.fork.apply(void 0, [takeLeading, patternOrChannel, worker].concat(args));\n}\nfunction throttle$1(ms, patternOrChannel, worker) {\n\n  for (var _len4 = arguments.length, args = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {\n    args[_key4 - 3] = arguments[_key4];\n  }\n\n  return io.fork.apply(void 0, [throttle, ms, patternOrChannel, worker].concat(args));\n}\nfunction retry$1(maxTries, delayLength, worker) {\n  for (var _len5 = arguments.length, args = new Array(_len5 > 3 ? _len5 - 3 : 0), _key5 = 3; _key5 < _len5; _key5++) {\n    args[_key5 - 3] = arguments[_key5];\n  }\n\n  return io.call.apply(void 0, [retry, maxTries, delayLength, worker].concat(args));\n}\nfunction debounce(delayLength, pattern, worker) {\n  for (var _len6 = arguments.length, args = new Array(_len6 > 3 ? _len6 - 3 : 0), _key6 = 3; _key6 < _len6; _key6++) {\n    args[_key6 - 3] = arguments[_key6];\n  }\n\n  return io.fork.apply(void 0, [debounceHelper, delayLength, pattern, worker].concat(args));\n}\n\nexports.actionChannel = io.actionChannel;\nexports.all = io.all;\nexports.apply = io.apply;\nexports.call = io.call;\nexports.cancel = io.cancel;\nexports.cancelled = io.cancelled;\nexports.cps = io.cps;\nexports.delay = io.delay;\nexports.effectTypes = io.effectTypes;\nexports.flush = io.flush;\nexports.fork = io.fork;\nexports.getContext = io.getContext;\nexports.join = io.join;\nexports.put = io.put;\nexports.putResolve = io.putResolve;\nexports.race = io.race;\nexports.select = io.select;\nexports.setContext = io.setContext;\nexports.spawn = io.spawn;\nexports.take = io.take;\nexports.takeMaybe = io.takeMaybe;\nexports.debounce = debounce;\nexports.retry = retry$1;\nexports.takeEvery = takeEvery$1;\nexports.takeLatest = takeLatest$1;\nexports.takeLeading = takeLeading$1;\nexports.throttle = throttle$1;\n", "'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar symbols = require('@redux-saga/symbols');\nvar _extends = _interopDefault(require('@babel/runtime/helpers/extends'));\nvar is = require('@redux-saga/is');\nvar delayP = _interopDefault(require('@redux-saga/delay-p'));\n\nvar konst = function konst(v) {\n  return function () {\n    return v;\n  };\n};\nvar kTrue =\n/*#__PURE__*/\nkonst(true);\n\nexports.noop = function noop() {};\n\nif ( typeof Proxy !== 'undefined') {\n  exports.noop =\n  /*#__PURE__*/\n  new Proxy(exports.noop, {\n    set: function set() {\n      throw internalErr('There was an attempt to assign a property to internal `noop` function.');\n    }\n  });\n}\nvar identity = function identity(v) {\n  return v;\n};\nvar hasSymbol = typeof Symbol === 'function';\nvar asyncIteratorSymbol = hasSymbol && Symbol.asyncIterator ? Symbol.asyncIterator : '@@asyncIterator';\nfunction check(value, predicate, error) {\n  if (!predicate(value)) {\n    throw new Error(error);\n  }\n}\nvar assignWithSymbols = function assignWithSymbols(target, source) {\n  _extends(target, source);\n\n  if (Object.getOwnPropertySymbols) {\n    Object.getOwnPropertySymbols(source).forEach(function (s) {\n      target[s] = source[s];\n    });\n  }\n};\nvar flatMap = function flatMap(mapper, arr) {\n  var _ref;\n\n  return (_ref = []).concat.apply(_ref, arr.map(mapper));\n};\nfunction remove(array, item) {\n  var index = array.indexOf(item);\n\n  if (index >= 0) {\n    array.splice(index, 1);\n  }\n}\nfunction once(fn) {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n    }\n\n    called = true;\n    fn();\n  };\n}\n\nvar kThrow = function kThrow(err) {\n  throw err;\n};\n\nvar kReturn = function kReturn(value) {\n  return {\n    value: value,\n    done: true\n  };\n};\n\nfunction makeIterator(next, thro, name) {\n  if (thro === void 0) {\n    thro = kThrow;\n  }\n\n  if (name === void 0) {\n    name = 'iterator';\n  }\n\n  var iterator = {\n    meta: {\n      name: name\n    },\n    next: next,\n    throw: thro,\n    return: kReturn,\n    isSagaIterator: true\n  };\n\n  if (typeof Symbol !== 'undefined') {\n    iterator[Symbol.iterator] = function () {\n      return iterator;\n    };\n  }\n\n  return iterator;\n}\nfunction logError(error, _ref2) {\n  var sagaStack = _ref2.sagaStack;\n\n  /*eslint-disable no-console*/\n  console.error(error);\n  console.error(sagaStack);\n}\nvar internalErr = function internalErr(err) {\n  return new Error(\"\\n  redux-saga: Error checking hooks detected an inconsistent state. This is likely a bug\\n  in redux-saga code and not yours. Thanks for reporting this in the project's github repo.\\n  Error: \" + err + \"\\n\");\n};\nvar createSetContextWarning = function createSetContextWarning(ctx, props) {\n  return (ctx ? ctx + '.' : '') + \"setContext(props): argument \" + props + \" is not a plain object\";\n};\nvar FROZEN_ACTION_ERROR = \"You can't put (a.k.a. dispatch from saga) frozen actions.\\nWe have to define a special non-enumerable property on those actions for scheduling purposes.\\nOtherwise you wouldn't be able to communicate properly between sagas & other subscribers (action ordering would become far less predictable).\\nIf you are using redux and you care about this behaviour (frozen actions),\\nthen you might want to switch to freezing actions in a middleware rather than in action creator.\\nExample implementation:\\n\\nconst freezeActions = store => next => action => next(Object.freeze(action))\\n\"; // creates empty, but not-holey array\n\nvar createEmptyArray = function createEmptyArray(n) {\n  return Array.apply(null, new Array(n));\n};\nvar wrapSagaDispatch = function wrapSagaDispatch(dispatch) {\n  return function (action) {\n    {\n      check(action, function (ac) {\n        return !Object.isFrozen(ac);\n      }, FROZEN_ACTION_ERROR);\n    }\n\n    return dispatch(Object.defineProperty(action, symbols.SAGA_ACTION, {\n      value: true\n    }));\n  };\n};\nvar shouldTerminate = function shouldTerminate(res) {\n  return res === symbols.TERMINATE;\n};\nvar shouldCancel = function shouldCancel(res) {\n  return res === symbols.TASK_CANCEL;\n};\nvar shouldComplete = function shouldComplete(res) {\n  return shouldTerminate(res) || shouldCancel(res);\n};\nfunction createAllStyleChildCallbacks(shape, parentCallback) {\n  var keys = Object.keys(shape);\n  var totalCount = keys.length;\n\n  {\n    check(totalCount, function (c) {\n      return c > 0;\n    }, 'createAllStyleChildCallbacks: get an empty array or object');\n  }\n\n  var completedCount = 0;\n  var completed;\n  var results = is.array(shape) ? createEmptyArray(totalCount) : {};\n  var childCallbacks = {};\n\n  function checkEnd() {\n    if (completedCount === totalCount) {\n      completed = true;\n      parentCallback(results);\n    }\n  }\n\n  keys.forEach(function (key) {\n    var chCbAtKey = function chCbAtKey(res, isErr) {\n      if (completed) {\n        return;\n      }\n\n      if (isErr || shouldComplete(res)) {\n        parentCallback.cancel();\n        parentCallback(res, isErr);\n      } else {\n        results[key] = res;\n        completedCount++;\n        checkEnd();\n      }\n    };\n\n    chCbAtKey.cancel = exports.noop;\n    childCallbacks[key] = chCbAtKey;\n  });\n\n  parentCallback.cancel = function () {\n    if (!completed) {\n      completed = true;\n      keys.forEach(function (key) {\n        return childCallbacks[key].cancel();\n      });\n    }\n  };\n\n  return childCallbacks;\n}\nfunction getMetaInfo(fn) {\n  return {\n    name: fn.name || 'anonymous',\n    location: getLocation(fn)\n  };\n}\nfunction getLocation(instrumented) {\n  return instrumented[symbols.SAGA_LOCATION];\n}\n\nvar BUFFER_OVERFLOW = \"Channel's Buffer overflow!\";\nvar ON_OVERFLOW_THROW = 1;\nvar ON_OVERFLOW_DROP = 2;\nvar ON_OVERFLOW_SLIDE = 3;\nvar ON_OVERFLOW_EXPAND = 4;\nvar zeroBuffer = {\n  isEmpty: kTrue,\n  put: exports.noop,\n  take: exports.noop\n};\n\nfunction ringBuffer(limit, overflowAction) {\n  if (limit === void 0) {\n    limit = 10;\n  }\n\n  var arr = new Array(limit);\n  var length = 0;\n  var pushIndex = 0;\n  var popIndex = 0;\n\n  var push = function push(it) {\n    arr[pushIndex] = it;\n    pushIndex = (pushIndex + 1) % limit;\n    length++;\n  };\n\n  var take = function take() {\n    if (length != 0) {\n      var it = arr[popIndex];\n      arr[popIndex] = null;\n      length--;\n      popIndex = (popIndex + 1) % limit;\n      return it;\n    }\n  };\n\n  var flush = function flush() {\n    var items = [];\n\n    while (length) {\n      items.push(take());\n    }\n\n    return items;\n  };\n\n  return {\n    isEmpty: function isEmpty() {\n      return length == 0;\n    },\n    put: function put(it) {\n      if (length < limit) {\n        push(it);\n      } else {\n        var doubledLimit;\n\n        switch (overflowAction) {\n          case ON_OVERFLOW_THROW:\n            throw new Error(BUFFER_OVERFLOW);\n\n          case ON_OVERFLOW_SLIDE:\n            arr[pushIndex] = it;\n            pushIndex = (pushIndex + 1) % limit;\n            popIndex = pushIndex;\n            break;\n\n          case ON_OVERFLOW_EXPAND:\n            doubledLimit = 2 * limit;\n            arr = flush();\n            length = arr.length;\n            pushIndex = arr.length;\n            popIndex = 0;\n            arr.length = doubledLimit;\n            limit = doubledLimit;\n            push(it);\n            break;\n\n          default: // DROP\n\n        }\n      }\n    },\n    take: take,\n    flush: flush\n  };\n}\n\nvar none = function none() {\n  return zeroBuffer;\n};\nvar fixed = function fixed(limit) {\n  return ringBuffer(limit, ON_OVERFLOW_THROW);\n};\nvar dropping = function dropping(limit) {\n  return ringBuffer(limit, ON_OVERFLOW_DROP);\n};\nvar sliding = function sliding(limit) {\n  return ringBuffer(limit, ON_OVERFLOW_SLIDE);\n};\nvar expanding = function expanding(initialSize) {\n  return ringBuffer(initialSize, ON_OVERFLOW_EXPAND);\n};\n\nvar buffers = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  none: none,\n  fixed: fixed,\n  dropping: dropping,\n  sliding: sliding,\n  expanding: expanding\n});\n\nvar TAKE = 'TAKE';\nvar PUT = 'PUT';\nvar ALL = 'ALL';\nvar RACE = 'RACE';\nvar CALL = 'CALL';\nvar CPS = 'CPS';\nvar FORK = 'FORK';\nvar JOIN = 'JOIN';\nvar CANCEL = 'CANCEL';\nvar SELECT = 'SELECT';\nvar ACTION_CHANNEL = 'ACTION_CHANNEL';\nvar CANCELLED = 'CANCELLED';\nvar FLUSH = 'FLUSH';\nvar GET_CONTEXT = 'GET_CONTEXT';\nvar SET_CONTEXT = 'SET_CONTEXT';\n\nvar effectTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  TAKE: TAKE,\n  PUT: PUT,\n  ALL: ALL,\n  RACE: RACE,\n  CALL: CALL,\n  CPS: CPS,\n  FORK: FORK,\n  JOIN: JOIN,\n  CANCEL: CANCEL,\n  SELECT: SELECT,\n  ACTION_CHANNEL: ACTION_CHANNEL,\n  CANCELLED: CANCELLED,\n  FLUSH: FLUSH,\n  GET_CONTEXT: GET_CONTEXT,\n  SET_CONTEXT: SET_CONTEXT\n});\n\nvar TEST_HINT = '\\n(HINT: if you are getting these errors in tests, consider using createMockTask from @redux-saga/testing-utils)';\n\nvar makeEffect = function makeEffect(type, payload) {\n  var _ref;\n\n  return _ref = {}, _ref[symbols.IO] = true, _ref.combinator = false, _ref.type = type, _ref.payload = payload, _ref;\n};\n\nvar isForkEffect = function isForkEffect(eff) {\n  return is.effect(eff) && eff.type === FORK;\n};\n\nvar detach = function detach(eff) {\n  {\n    check(eff, isForkEffect, 'detach(eff): argument must be a fork effect');\n  }\n\n  return makeEffect(FORK, _extends({}, eff.payload, {\n    detached: true\n  }));\n};\nfunction take(patternOrChannel, multicastPattern) {\n  if (patternOrChannel === void 0) {\n    patternOrChannel = '*';\n  }\n\n  if ( arguments.length) {\n    check(arguments[0], is.notUndef, 'take(patternOrChannel): patternOrChannel is undefined');\n  }\n\n  if (is.pattern(patternOrChannel)) {\n    if (is.notUndef(multicastPattern)) {\n      /* eslint-disable no-console */\n      console.warn(\"take(pattern) takes one argument but two were provided. Consider passing an array for listening to several action types\");\n    }\n\n    return makeEffect(TAKE, {\n      pattern: patternOrChannel\n    });\n  }\n\n  if (is.multicast(patternOrChannel) && is.notUndef(multicastPattern) && is.pattern(multicastPattern)) {\n    return makeEffect(TAKE, {\n      channel: patternOrChannel,\n      pattern: multicastPattern\n    });\n  }\n\n  if (is.channel(patternOrChannel)) {\n    if (is.notUndef(multicastPattern)) {\n      /* eslint-disable no-console */\n      console.warn(\"take(channel) takes one argument but two were provided. Second argument is ignored.\");\n    }\n\n    return makeEffect(TAKE, {\n      channel: patternOrChannel\n    });\n  }\n\n  {\n    throw new Error(\"take(patternOrChannel): argument \" + patternOrChannel + \" is not valid channel or a valid pattern\");\n  }\n}\nvar takeMaybe = function takeMaybe() {\n  var eff = take.apply(void 0, arguments);\n  eff.payload.maybe = true;\n  return eff;\n};\nfunction put(channel, action) {\n  {\n    if (arguments.length > 1) {\n      check(channel, is.notUndef, 'put(channel, action): argument channel is undefined');\n      check(channel, is.channel, \"put(channel, action): argument \" + channel + \" is not a valid channel\");\n      check(action, is.notUndef, 'put(channel, action): argument action is undefined');\n    } else {\n      check(channel, is.notUndef, 'put(action): argument action is undefined');\n    }\n  }\n\n  if (is.undef(action)) {\n    action = channel; // `undefined` instead of `null` to make default parameter work\n\n    channel = undefined;\n  }\n\n  return makeEffect(PUT, {\n    channel: channel,\n    action: action\n  });\n}\nvar putResolve = function putResolve() {\n  var eff = put.apply(void 0, arguments);\n  eff.payload.resolve = true;\n  return eff;\n};\nfunction all(effects) {\n  var eff = makeEffect(ALL, effects);\n  eff.combinator = true;\n  return eff;\n}\nfunction race(effects) {\n  var eff = makeEffect(RACE, effects);\n  eff.combinator = true;\n  return eff;\n} // this match getFnCallDescriptor logic\n\nvar validateFnDescriptor = function validateFnDescriptor(effectName, fnDescriptor) {\n  check(fnDescriptor, is.notUndef, effectName + \": argument fn is undefined or null\");\n\n  if (is.func(fnDescriptor)) {\n    return;\n  }\n\n  var context = null;\n  var fn;\n\n  if (is.array(fnDescriptor)) {\n    context = fnDescriptor[0];\n    fn = fnDescriptor[1];\n    check(fn, is.notUndef, effectName + \": argument of type [context, fn] has undefined or null `fn`\");\n  } else if (is.object(fnDescriptor)) {\n    context = fnDescriptor.context;\n    fn = fnDescriptor.fn;\n    check(fn, is.notUndef, effectName + \": argument of type {context, fn} has undefined or null `fn`\");\n  } else {\n    check(fnDescriptor, is.func, effectName + \": argument fn is not function\");\n    return;\n  }\n\n  if (context && is.string(fn)) {\n    check(context[fn], is.func, effectName + \": context arguments has no such method - \\\"\" + fn + \"\\\"\");\n    return;\n  }\n\n  check(fn, is.func, effectName + \": unpacked fn argument (from [context, fn] or {context, fn}) is not a function\");\n};\n\nfunction getFnCallDescriptor(fnDescriptor, args) {\n  var context = null;\n  var fn;\n\n  if (is.func(fnDescriptor)) {\n    fn = fnDescriptor;\n  } else {\n    if (is.array(fnDescriptor)) {\n      context = fnDescriptor[0];\n      fn = fnDescriptor[1];\n    } else {\n      context = fnDescriptor.context;\n      fn = fnDescriptor.fn;\n    }\n\n    if (context && is.string(fn) && is.func(context[fn])) {\n      fn = context[fn];\n    }\n  }\n\n  return {\n    context: context,\n    fn: fn,\n    args: args\n  };\n}\n\nvar isNotDelayEffect = function isNotDelayEffect(fn) {\n  return fn !== delay;\n};\n\nfunction call(fnDescriptor) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  {\n    var arg0 = typeof args[0] === 'number' ? args[0] : 'ms';\n    check(fnDescriptor, isNotDelayEffect, \"instead of writing `yield call(delay, \" + arg0 + \")` where delay is an effect from `redux-saga/effects` you should write `yield delay(\" + arg0 + \")`\");\n    validateFnDescriptor('call', fnDescriptor);\n  }\n\n  return makeEffect(CALL, getFnCallDescriptor(fnDescriptor, args));\n}\nfunction apply(context, fn, args) {\n  if (args === void 0) {\n    args = [];\n  }\n\n  var fnDescriptor = [context, fn];\n\n  {\n    validateFnDescriptor('apply', fnDescriptor);\n  }\n\n  return makeEffect(CALL, getFnCallDescriptor([context, fn], args));\n}\nfunction cps(fnDescriptor) {\n  {\n    validateFnDescriptor('cps', fnDescriptor);\n  }\n\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  return makeEffect(CPS, getFnCallDescriptor(fnDescriptor, args));\n}\nfunction fork(fnDescriptor) {\n  {\n    validateFnDescriptor('fork', fnDescriptor);\n    check(fnDescriptor, function (arg) {\n      return !is.effect(arg);\n    }, 'fork: argument must not be an effect');\n  }\n\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n\n  return makeEffect(FORK, getFnCallDescriptor(fnDescriptor, args));\n}\nfunction spawn(fnDescriptor) {\n  {\n    validateFnDescriptor('spawn', fnDescriptor);\n  }\n\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n\n  return detach(fork.apply(void 0, [fnDescriptor].concat(args)));\n}\nfunction join(taskOrTasks) {\n  {\n    if (arguments.length > 1) {\n      throw new Error('join(...tasks) is not supported any more. Please use join([...tasks]) to join multiple tasks.');\n    }\n\n    if (is.array(taskOrTasks)) {\n      taskOrTasks.forEach(function (t) {\n        check(t, is.task, \"join([...tasks]): argument \" + t + \" is not a valid Task object \" + TEST_HINT);\n      });\n    } else {\n      check(taskOrTasks, is.task, \"join(task): argument \" + taskOrTasks + \" is not a valid Task object \" + TEST_HINT);\n    }\n  }\n\n  return makeEffect(JOIN, taskOrTasks);\n}\nfunction cancel(taskOrTasks) {\n  if (taskOrTasks === void 0) {\n    taskOrTasks = symbols.SELF_CANCELLATION;\n  }\n\n  {\n    if (arguments.length > 1) {\n      throw new Error('cancel(...tasks) is not supported any more. Please use cancel([...tasks]) to cancel multiple tasks.');\n    }\n\n    if (is.array(taskOrTasks)) {\n      taskOrTasks.forEach(function (t) {\n        check(t, is.task, \"cancel([...tasks]): argument \" + t + \" is not a valid Task object \" + TEST_HINT);\n      });\n    } else if (taskOrTasks !== symbols.SELF_CANCELLATION && is.notUndef(taskOrTasks)) {\n      check(taskOrTasks, is.task, \"cancel(task): argument \" + taskOrTasks + \" is not a valid Task object \" + TEST_HINT);\n    }\n  }\n\n  return makeEffect(CANCEL, taskOrTasks);\n}\nfunction select(selector) {\n  if (selector === void 0) {\n    selector = identity;\n  }\n\n  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    args[_key5 - 1] = arguments[_key5];\n  }\n\n  if ( arguments.length) {\n    check(arguments[0], is.notUndef, 'select(selector, [...]): argument selector is undefined');\n    check(selector, is.func, \"select(selector, [...]): argument \" + selector + \" is not a function\");\n  }\n\n  return makeEffect(SELECT, {\n    selector: selector,\n    args: args\n  });\n}\n/**\n  channel(pattern, [buffer])    => creates a proxy channel for store actions\n**/\n\nfunction actionChannel(pattern, buffer) {\n  {\n    check(pattern, is.pattern, 'actionChannel(pattern,...): argument pattern is not valid');\n\n    if (arguments.length > 1) {\n      check(buffer, is.notUndef, 'actionChannel(pattern, buffer): argument buffer is undefined');\n      check(buffer, is.buffer, \"actionChannel(pattern, buffer): argument \" + buffer + \" is not a valid buffer\");\n    }\n  }\n\n  return makeEffect(ACTION_CHANNEL, {\n    pattern: pattern,\n    buffer: buffer\n  });\n}\nfunction cancelled() {\n  return makeEffect(CANCELLED, {});\n}\nfunction flush(channel) {\n  {\n    check(channel, is.channel, \"flush(channel): argument \" + channel + \" is not valid channel\");\n  }\n\n  return makeEffect(FLUSH, channel);\n}\nfunction getContext(prop) {\n  {\n    check(prop, is.string, \"getContext(prop): argument \" + prop + \" is not a string\");\n  }\n\n  return makeEffect(GET_CONTEXT, prop);\n}\nfunction setContext(props) {\n  {\n    check(props, is.object, createSetContextWarning(null, props));\n  }\n\n  return makeEffect(SET_CONTEXT, props);\n}\nvar delay =\n/*#__PURE__*/\ncall.bind(null, delayP);\n\nexports.ACTION_CHANNEL = ACTION_CHANNEL;\nexports.ALL = ALL;\nexports.CALL = CALL;\nexports.CANCEL = CANCEL;\nexports.CANCELLED = CANCELLED;\nexports.CPS = CPS;\nexports.FLUSH = FLUSH;\nexports.FORK = FORK;\nexports.GET_CONTEXT = GET_CONTEXT;\nexports.JOIN = JOIN;\nexports.PUT = PUT;\nexports.RACE = RACE;\nexports.SELECT = SELECT;\nexports.SET_CONTEXT = SET_CONTEXT;\nexports.TAKE = TAKE;\nexports.actionChannel = actionChannel;\nexports.all = all;\nexports.apply = apply;\nexports.assignWithSymbols = assignWithSymbols;\nexports.asyncIteratorSymbol = asyncIteratorSymbol;\nexports.buffers = buffers;\nexports.call = call;\nexports.cancel = cancel;\nexports.cancelled = cancelled;\nexports.check = check;\nexports.cps = cps;\nexports.createAllStyleChildCallbacks = createAllStyleChildCallbacks;\nexports.createEmptyArray = createEmptyArray;\nexports.createSetContextWarning = createSetContextWarning;\nexports.delay = delay;\nexports.detach = detach;\nexports.effectTypes = effectTypes;\nexports.expanding = expanding;\nexports.flatMap = flatMap;\nexports.flush = flush;\nexports.fork = fork;\nexports.getContext = getContext;\nexports.getLocation = getLocation;\nexports.getMetaInfo = getMetaInfo;\nexports.identity = identity;\nexports.internalErr = internalErr;\nexports.join = join;\nexports.kTrue = kTrue;\nexports.logError = logError;\nexports.makeIterator = makeIterator;\nexports.none = none;\nexports.once = once;\nexports.put = put;\nexports.putResolve = putResolve;\nexports.race = race;\nexports.remove = remove;\nexports.select = select;\nexports.setContext = setContext;\nexports.shouldCancel = shouldCancel;\nexports.shouldComplete = shouldComplete;\nexports.shouldTerminate = shouldTerminate;\nexports.sliding = sliding;\nexports.spawn = spawn;\nexports.take = take;\nexports.takeMaybe = takeMaybe;\nexports.wrapSagaDispatch = wrapSagaDispatch;\n", "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nrequire('@redux-saga/symbols');\nrequire('@babel/runtime/helpers/extends');\nvar is = require('@redux-saga/is');\nvar io = require('./io-a03c6210.js');\nrequire('@redux-saga/delay-p');\n\nvar done = function done(value) {\n  return {\n    done: true,\n    value: value\n  };\n};\n\nvar qEnd = {};\nfunction safeName(patternOrChannel) {\n  if (is.channel(patternOrChannel)) {\n    return 'channel';\n  }\n\n  if (is.stringableFunc(patternOrChannel)) {\n    return String(patternOrChannel);\n  }\n\n  if (is.func(patternOrChannel)) {\n    return patternOrChannel.name;\n  }\n\n  return String(patternOrChannel);\n}\nfunction fsmIterator(fsm, startState, name) {\n  var stateUpdater,\n      errorState,\n      effect,\n      nextState = startState;\n\n  function next(arg, error) {\n    if (nextState === qEnd) {\n      return done(arg);\n    }\n\n    if (error && !errorState) {\n      nextState = qEnd;\n      throw error;\n    } else {\n      stateUpdater && stateUpdater(arg);\n      var currentState = error ? fsm[errorState](error) : fsm[nextState]();\n      nextState = currentState.nextState;\n      effect = currentState.effect;\n      stateUpdater = currentState.stateUpdater;\n      errorState = currentState.errorState;\n      return nextState === qEnd ? done(arg) : effect;\n    }\n  }\n\n  return io.makeIterator(next, function (error) {\n    return next(null, error);\n  }, name);\n}\n\nfunction takeEvery(patternOrChannel, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  var yTake = {\n    done: false,\n    value: io.take(patternOrChannel)\n  };\n\n  var yFork = function yFork(ac) {\n    return {\n      done: false,\n      value: io.fork.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var action,\n      setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yTake,\n        stateUpdater: setAction\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: 'q1',\n        effect: yFork(action)\n      };\n    }\n  }, 'q1', \"takeEvery(\" + safeName(patternOrChannel) + \", \" + worker.name + \")\");\n}\n\nfunction takeLatest(patternOrChannel, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  var yTake = {\n    done: false,\n    value: io.take(patternOrChannel)\n  };\n\n  var yFork = function yFork(ac) {\n    return {\n      done: false,\n      value: io.fork.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var yCancel = function yCancel(task) {\n    return {\n      done: false,\n      value: io.cancel(task)\n    };\n  };\n\n  var task, action;\n\n  var setTask = function setTask(t) {\n    return task = t;\n  };\n\n  var setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yTake,\n        stateUpdater: setAction\n      };\n    },\n    q2: function q2() {\n      return task ? {\n        nextState: 'q3',\n        effect: yCancel(task)\n      } : {\n        nextState: 'q1',\n        effect: yFork(action),\n        stateUpdater: setTask\n      };\n    },\n    q3: function q3() {\n      return {\n        nextState: 'q1',\n        effect: yFork(action),\n        stateUpdater: setTask\n      };\n    }\n  }, 'q1', \"takeLatest(\" + safeName(patternOrChannel) + \", \" + worker.name + \")\");\n}\n\nfunction takeLeading(patternOrChannel, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  var yTake = {\n    done: false,\n    value: io.take(patternOrChannel)\n  };\n\n  var yCall = function yCall(ac) {\n    return {\n      done: false,\n      value: io.call.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var action;\n\n  var setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yTake,\n        stateUpdater: setAction\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: 'q1',\n        effect: yCall(action)\n      };\n    }\n  }, 'q1', \"takeLeading(\" + safeName(patternOrChannel) + \", \" + worker.name + \")\");\n}\n\nfunction throttle(delayLength, patternOrChannel, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  var action, channel;\n\n  var yTake = function yTake() {\n    return {\n      done: false,\n      value: io.take(channel)\n    };\n  };\n\n  var yFork = function yFork(ac) {\n    return {\n      done: false,\n      value: io.fork.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var yDelay = {\n    done: false,\n    value: io.delay(delayLength)\n  };\n\n  var setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  var setChannel = function setChannel(ch) {\n    return channel = ch;\n  };\n\n  var needsChannel = !is.channel(patternOrChannel);\n\n  if (!needsChannel) {\n    setChannel(patternOrChannel);\n  }\n\n  return fsmIterator({\n    q1: function q1() {\n      var yActionChannel = {\n        done: false,\n        value: io.actionChannel(patternOrChannel, io.sliding(1))\n      };\n      return {\n        nextState: 'q2',\n        effect: yActionChannel,\n        stateUpdater: setChannel\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: 'q3',\n        effect: yTake(),\n        stateUpdater: setAction\n      };\n    },\n    q3: function q3() {\n      return {\n        nextState: 'q4',\n        effect: yFork(action)\n      };\n    },\n    q4: function q4() {\n      return {\n        nextState: 'q2',\n        effect: yDelay\n      };\n    }\n  }, needsChannel ? 'q1' : 'q2', \"throttle(\" + safeName(patternOrChannel) + \", \" + worker.name + \")\");\n}\n\nfunction retry(maxTries, delayLength, fn) {\n  var counter = maxTries;\n\n  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  var yCall = {\n    done: false,\n    value: io.call.apply(void 0, [fn].concat(args))\n  };\n  var yDelay = {\n    done: false,\n    value: io.delay(delayLength)\n  };\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yCall,\n        errorState: 'q10'\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: qEnd\n      };\n    },\n    q10: function q10(error) {\n      counter -= 1;\n\n      if (counter <= 0) {\n        throw error;\n      }\n\n      return {\n        nextState: 'q1',\n        effect: yDelay\n      };\n    }\n  }, 'q1', \"retry(\" + fn.name + \")\");\n}\n\nfunction debounceHelper(delayLength, patternOrChannel, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  var action, raceOutput;\n  var yTake = {\n    done: false,\n    value: io.take(patternOrChannel)\n  };\n  var yRace = {\n    done: false,\n    value: io.race({\n      action: io.take(patternOrChannel),\n      debounce: io.delay(delayLength)\n    })\n  };\n\n  var yFork = function yFork(ac) {\n    return {\n      done: false,\n      value: io.fork.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var yNoop = function yNoop(value) {\n    return {\n      done: false,\n      value: value\n    };\n  };\n\n  var setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  var setRaceOutput = function setRaceOutput(ro) {\n    return raceOutput = ro;\n  };\n\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yTake,\n        stateUpdater: setAction\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: 'q3',\n        effect: yRace,\n        stateUpdater: setRaceOutput\n      };\n    },\n    q3: function q3() {\n      return raceOutput.debounce ? {\n        nextState: 'q1',\n        effect: yFork(action)\n      } : {\n        nextState: 'q2',\n        effect: yNoop(raceOutput.action),\n        stateUpdater: setAction\n      };\n    }\n  }, 'q1', \"debounce(\" + safeName(patternOrChannel) + \", \" + worker.name + \")\");\n}\n\nvar validateTakeEffect = function validateTakeEffect(fn, patternOrChannel, worker) {\n  io.check(patternOrChannel, is.notUndef, fn.name + \" requires a pattern or channel\");\n  io.check(worker, is.notUndef, fn.name + \" requires a saga parameter\");\n};\n\nfunction takeEvery$1(patternOrChannel, worker) {\n  {\n    validateTakeEffect(takeEvery$1, patternOrChannel, worker);\n  }\n\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  return io.fork.apply(void 0, [takeEvery, patternOrChannel, worker].concat(args));\n}\nfunction takeLatest$1(patternOrChannel, worker) {\n  {\n    validateTakeEffect(takeLatest$1, patternOrChannel, worker);\n  }\n\n  for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    args[_key2 - 2] = arguments[_key2];\n  }\n\n  return io.fork.apply(void 0, [takeLatest, patternOrChannel, worker].concat(args));\n}\nfunction takeLeading$1(patternOrChannel, worker) {\n  {\n    validateTakeEffect(takeLeading$1, patternOrChannel, worker);\n  }\n\n  for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n    args[_key3 - 2] = arguments[_key3];\n  }\n\n  return io.fork.apply(void 0, [takeLeading, patternOrChannel, worker].concat(args));\n}\nfunction throttle$1(ms, patternOrChannel, worker) {\n  {\n    io.check(patternOrChannel, is.notUndef, \"throttle requires a pattern or channel\");\n    io.check(worker, is.notUndef, 'throttle requires a saga parameter');\n  }\n\n  for (var _len4 = arguments.length, args = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {\n    args[_key4 - 3] = arguments[_key4];\n  }\n\n  return io.fork.apply(void 0, [throttle, ms, patternOrChannel, worker].concat(args));\n}\nfunction retry$1(maxTries, delayLength, worker) {\n  for (var _len5 = arguments.length, args = new Array(_len5 > 3 ? _len5 - 3 : 0), _key5 = 3; _key5 < _len5; _key5++) {\n    args[_key5 - 3] = arguments[_key5];\n  }\n\n  return io.call.apply(void 0, [retry, maxTries, delayLength, worker].concat(args));\n}\nfunction debounce(delayLength, pattern, worker) {\n  for (var _len6 = arguments.length, args = new Array(_len6 > 3 ? _len6 - 3 : 0), _key6 = 3; _key6 < _len6; _key6++) {\n    args[_key6 - 3] = arguments[_key6];\n  }\n\n  return io.fork.apply(void 0, [debounceHelper, delayLength, pattern, worker].concat(args));\n}\n\nexports.actionChannel = io.actionChannel;\nexports.all = io.all;\nexports.apply = io.apply;\nexports.call = io.call;\nexports.cancel = io.cancel;\nexports.cancelled = io.cancelled;\nexports.cps = io.cps;\nexports.delay = io.delay;\nexports.effectTypes = io.effectTypes;\nexports.flush = io.flush;\nexports.fork = io.fork;\nexports.getContext = io.getContext;\nexports.join = io.join;\nexports.put = io.put;\nexports.putResolve = io.putResolve;\nexports.race = io.race;\nexports.select = io.select;\nexports.setContext = io.setContext;\nexports.spawn = io.spawn;\nexports.take = io.take;\nexports.takeMaybe = io.takeMaybe;\nexports.debounce = debounce;\nexports.retry = retry$1;\nexports.takeEvery = takeEvery$1;\nexports.takeLatest = takeLatest$1;\nexports.takeLeading = takeLeading$1;\nexports.throttle = throttle$1;\n", "\"use strict\";\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./redux-saga-effects.prod.cjs.js')\n} else {\n  module.exports = require('./redux-saga-effects.dev.cjs.js')\n}\n", "/**\n * You can use the realtime SDK to listen for and react to events from\n * SignalWire's RealTime APIs.\n *\n * To get started, create a realtime client, for example with\n * {@link Video.Client} and listen for events. For example:\n *\n * ```javascript\n * import { Video } from '@signalwire/realtime-api'\n *\n * const video = new Video.Client({\n *   project: '<project-id>',\n *   token: '<project-token>'\n * })\n *\n * video.on('room.started', async (roomSession) => {\n *   console.log(\"Room started\")\n *\n *   roomSession.on('member.joined', async (member) => {\n *     console.log(member)\n *   })\n * });\n * ```\n *\n * @module\n */\n\n/**\n * Access the Video API Consumer. You can instantiate a {@link Video.Client} to\n * subscribe to Video events. Please check {@link Video.VideoClientApiEvents}\n * for the full list of events that a {@link Video.Client} can subscribe to.\n *\n * @example\n *\n * The following example logs whenever a room session is started or a user joins\n * it:\n *\n * ```javascript\n * const video = new Video.Client({ project, token })\n *\n * // Listen for events:\n * video.on('room.started', async (roomSession) => {\n *   console.log('Room has started:', roomSession.name)\n *\n *   roomSession.on('member.joined', async (member) => {\n *     console.log('Member joined:', member.name)\n *   })\n * })\n * ```\n */\nexport * as Video from './video/Video'\n\nexport * from './createClient'\n\n/**\n * Access the Chat API Consumer. You can instantiate a {@link Chat.Client} to\n * subscribe to Chat events. Please check {@link Chat.ChatClientApiEvents}\n * for the full list of events that a {@link Chat.Client} can subscribe to.\n *\n * @example\n *\n * The following example logs the messages sent to the \"welcome\" channel.\n *\n * ```javascript\n * const chatClient = new Chat.Client({\n *   project: '<project-id>',\n *   token: '<api-token>'\n * })\n *\n * chatClient.on('message', m => console.log(m))\n *\n * await chatClient.subscribe(\"welcome\")\n * ```\n */\nexport * as Chat from './chat/Chat'\n\n/**\n * Access the PubSub API Consumer. You can instantiate a {@link PubSub.Client} to\n * subscribe to PubSub events. Please check {@link PubSub.PubSubClientApiEvents}\n * for the full list of events that a {@link PubSub.Client} can subscribe to.\n *\n * @example\n *\n * The following example logs the messages sent to the \"welcome\" channel.\n *\n * ```javascript\n * const pubSubClient = new PubSub.Client({\n *   project: '<project-id>',\n *   token: '<api-token>'\n * })\n *\n * pubSubClient.on('message', m => console.log(m))\n *\n * await pubSubClient.subscribe(\"welcome\")\n * ```\n */\nexport * as PubSub from './pubSub/PubSub'\n\n/** @ignore */\nexport * from './configure'\n\n/**\n * Access the Task API. You can instantiate a {@link Task.Client} to\n * receive tasks from a different application. Please check\n * {@link Task.TaskClientApiEvents} for the full list of events that\n * a {@link Task.Client} can subscribe to.\n *\n * @example\n *\n * The following example listens for incoming tasks.\n *\n * ```javascript\n * const client = new Task.Client({\n *   project: \"<project-id>\",\n *   token: \"<api-token>\",\n *   contexts: ['office']\n * })\n *\n * client.on('task.received', (payload) => {\n *   console.log('Task Received', payload)\n *   // Do something with the payload...\n * })\n * ```\n *\n * From a different process, even on a different machine, you can then send tasks:\n *\n * ```js\n * await Task.send({\n *   project: \"<project-id>\",\n *   token: \"<api-token>\",\n *   context: 'office',\n *   message: { hello: ['world', true] },\n * })\n * ```\n */\nexport * as Task from './task/Task'\n\n/**\n * Access the Messaging API. You can instantiate a {@link Messaging.Client} to\n * send or receive SMS and MMS. Please check\n * {@link Messaging.MessagingClientApiEvents} for the full list of events that\n * a {@link Messaging.Client} can subscribe to.\n *\n * @example\n *\n * The following example listens for incoming SMSs over an \"office\" context,\n * and also sends an SMS.\n *\n * ```javascript\n * const client = new Messaging.Client({\n *   project: \"<project-id>\",\n *   token: \"<api-token>\",\n *   contexts: ['office']\n * })\n *\n * client.on('message.received', (message) => {\n *   console.log('message.received', message)\n * })\n *\n * await client.send({\n *   from: '+1xxx',\n *   to: '+1yyy',\n *   body: 'Hello World!'\n * })\n * ```\n */\nexport * as Messaging from './messaging/Messaging'\n\n/**\n * Access the Voice API. You can instantiate a {@link Voice.Client} to\n * make or receive calls. Please check\n * {@link Voice.VoiceClientApiEvents} for the full list of events that\n * a {@link Voice.Client} can subscribe to.\n *\n * @example\n *\n * The following example answers any call in the \"office\" context,\n * and immediately plays some speech.\n *\n * ```javascript\n * const client = new Voice.Client({\n *   project: \"<project-id>\",\n *   token: \"<api-token>\",\n *   contexts: ['office']\n * })\n *\n * client.on('call.received', async (call) => {\n *   console.log('Got call', call.from, call.to)\n *\n *   try {\n *     await call.answer()\n *     console.log('Inbound call answered')\n *\n *     await call.playTTS({ text: \"Hello! This is a test call.\"})\n *   } catch (error) {\n *     console.error('Error answering inbound call', error)\n *   }\n * })\n * ```\n */\nexport * as Voice from './voice/Voice'\n", "import {\n  BaseComponentOptions,\n  connect,\n  ConsumerContract,\n  RoomSessionRecording,\n  RoomSessionPlayback,\n} from '@signalwire/core'\nimport { AutoSubscribeConsumer } from '../AutoSubscribeConsumer'\nimport type { RealtimeClient } from '../client/Client'\nimport {\n  RealTimeRoomApiEvents,\n  RealTimeVideoApiEvents,\n  RealTimeVideoApiEventsHandlerMapping,\n  RealTimeRoomApiEventsHandlerMapping,\n} from '../types/video'\nimport {\n  RoomSession,\n  RoomSessionFullState,\n  RoomSessionUpdated,\n  createRoomSessionObject,\n} from './RoomSession'\nimport type {\n  RoomSessionMember,\n  RoomSessionMemberUpdated,\n} from './RoomSessionMember'\nimport { videoCallingWorker } from './workers'\n\nexport interface Video extends ConsumerContract<RealTimeVideoApiEvents> {\n  /** @internal */\n  subscribe(): Promise<void>\n  /** @internal */\n  _session: RealtimeClient\n  /**\n   * Disconnects this client. The client will stop receiving events and you will\n   * need to create a new instance if you want to use it again.\n   *\n   * @example\n   *\n   * ```js\n   * client.disconnect()\n   * ```\n   */\n  disconnect(): void\n\n  getRoomSessions(): Promise<{ roomSessions: RoomSession[] }>\n  getRoomSessionById(id: string): Promise<{ roomSession: RoomSession }>\n}\nexport type {\n  RealTimeRoomApiEvents,\n  RealTimeRoomApiEventsHandlerMapping,\n  RealTimeVideoApiEvents,\n  RealTimeVideoApiEventsHandlerMapping,\n  RoomSession,\n  RoomSessionFullState,\n  RoomSessionMember,\n  RoomSessionMemberUpdated,\n  RoomSessionPlayback,\n  RoomSessionRecording,\n  RoomSessionUpdated,\n}\n\nexport type {\n  ClientEvents,\n  EmitterContract,\n  EntityUpdated,\n  GlobalVideoEvents,\n  InternalVideoMemberEntity,\n  LayoutChanged,\n  MEMBER_UPDATED_EVENTS,\n  MemberCommandParams,\n  MemberCommandWithValueParams,\n  MemberCommandWithVolumeParams,\n  MemberJoined,\n  MemberLeft,\n  MemberListUpdated,\n  MemberTalking,\n  MemberTalkingEnded,\n  MemberTalkingEventNames,\n  MemberTalkingStart,\n  MemberTalkingStarted,\n  MemberTalkingStop,\n  MemberUpdated,\n  MemberUpdatedEventNames,\n  PlaybackEnded,\n  PlaybackStarted,\n  PlaybackUpdated,\n  RecordingEnded,\n  RecordingStarted,\n  RecordingUpdated,\n  RoomEnded,\n  RoomStarted,\n  RoomSubscribed,\n  RoomUpdated,\n  SipCodec,\n  VideoLayoutEventNames,\n  VideoMemberContract,\n  VideoMemberEntity,\n  VideoMemberEventNames,\n  VideoMemberType,\n  VideoPlaybackEventNames,\n  VideoPosition,\n  VideoRecordingEventNames,\n} from '@signalwire/core'\n\nclass VideoAPI extends AutoSubscribeConsumer<RealTimeVideoApiEvents> {\n  constructor(options: BaseComponentOptions) {\n    super(options)\n\n    this.runWorker('videoCallWorker', { worker: videoCallingWorker })\n  }\n\n  /** @internal */\n  protected subscribeParams = {\n    get_initial_state: true,\n  }\n\n  async getRoomSessions() {\n    return new Promise<{ roomSessions: RoomSession[] }>(\n      async (resolve, reject) => {\n        try {\n          const { rooms = [] }: any = await this.execute({\n            method: 'video.rooms.get',\n            params: {},\n          })\n\n          const roomInstances: RoomSession[] = []\n          rooms.forEach((room: any) => {\n            let roomInstance = this.instanceMap.get<RoomSession>(room.id)\n            if (!roomInstance) {\n              roomInstance = createRoomSessionObject({\n                store: this.store,\n                payload: { room_session: room },\n              })\n            } else {\n              roomInstance.setPayload({\n                room_session: room,\n              })\n            }\n            roomInstances.push(roomInstance)\n            this.instanceMap.set<RoomSession>(roomInstance.id, roomInstance)\n          })\n\n          resolve({ roomSessions: roomInstances })\n        } catch (error) {\n          console.error('Error listing room sessions', error)\n          reject(error)\n        }\n      }\n    )\n  }\n\n  async getRoomSessionById(id: string) {\n    return new Promise<{ roomSession: RoomSession }>(\n      async (resolve, reject) => {\n        try {\n          const { room }: any = await this.execute({\n            method: 'video.room.get',\n            params: {\n              room_session_id: id,\n            },\n          })\n\n          let roomInstance = this.instanceMap.get<RoomSession>(room.id)\n          if (!roomInstance) {\n            roomInstance = createRoomSessionObject({\n              store: this.store,\n              payload: { room_session: room },\n            })\n          } else {\n            roomInstance.setPayload({\n              room_session: room,\n            })\n          }\n          this.instanceMap.set<RoomSession>(roomInstance.id, roomInstance)\n\n          resolve({ roomSession: roomInstance })\n        } catch (error) {\n          console.error('Error retrieving the room session', error)\n          reject(error)\n        }\n      }\n    )\n  }\n}\n\n/** @internal */\nexport const createVideoObject = (params: BaseComponentOptions): Video => {\n  const video = connect<RealTimeVideoApiEvents, VideoAPI, Video>({\n    store: params.store,\n    Component: VideoAPI,\n  })(params)\n\n  const proxy = new Proxy<Video>(video, {\n    get(target: any, prop: any, receiver: any) {\n      if (prop === '_eventsNamespace') {\n        /**\n         * Events at this level will always be global so\n         * there's no need for a namespace.\n         */\n        return ''\n      } else if (prop === 'eventChannel') {\n        return 'video.rooms'\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n\n  return proxy\n}\n\nexport * from './VideoClient'\n", "import {\n  BaseComponentOptions,\n  BaseConsumer,\n  EventEmitter,\n  debounce,\n  validateEventsToSubscribe,\n} from '@signalwire/core'\n\nexport class AutoSubscribeConsumer<\n  EventTypes extends EventEmitter.ValidEventTypes\n> extends BaseConsumer<EventTypes> {\n  /** @internal */\n  private debouncedSubscribe: ReturnType<typeof debounce>\n\n  constructor(options: BaseComponentOptions) {\n    super(options)\n\n    this.debouncedSubscribe = debounce(this.subscribe, 100)\n  }\n\n  /** @internal */\n  protected override getSubscriptions() {\n    const eventNamesWithPrefix = this.eventNames().map(\n      (event) => `video.${String(event)}`\n    ) as EventEmitter.EventNames<EventTypes>[]\n    return validateEventsToSubscribe(eventNamesWithPrefix)\n  }\n\n  override on<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T,\n    fn: EventEmitter.EventListener<EventTypes, T>\n  ) {\n    const instance = super.on(event, fn)\n    this.debouncedSubscribe()\n    return instance\n  }\n\n  override once<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T,\n    fn: EventEmitter.EventListener<EventTypes, T>\n  ) {\n    const instance = super.once(event, fn)\n    this.debouncedSubscribe()\n    return instance\n  }\n\n  override off<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T,\n    fn: EventEmitter.EventListener<EventTypes, T>\n  ) {\n    const instance = super.off(event, fn)\n    return instance\n  }\n}\n", "import {\n  BaseComponentOptionsWithPayload,\n  connect,\n  extendComponent,\n  Rooms,\n  VideoRoomSessionContract,\n  VideoRoomSessionMethods,\n  ConsumerContract,\n  EntityUpdated,\n  BaseConsumer,\n  EventEmitter,\n  debounce,\n  VideoRoomEventParams,\n  Optional,\n  validateEventsToSubscribe,\n} from '@signalwire/core'\nimport { RealTimeRoomApiEvents } from '../types'\nimport {\n  RoomSessionMember,\n  RoomSessionMemberEventParams,\n  createRoomSessionMemberObject,\n} from './RoomSessionMember'\n\nexport interface RoomSession\n  extends VideoRoomSessionContract,\n    ConsumerContract<RealTimeRoomApiEvents, RoomSessionFullState> {\n  setPayload(payload: Optional<VideoRoomEventParams, 'room'>): void\n  /**\n   * Returns a list of members currently in the room.\n   *\n   * @example\n   * ```typescript\n   * await room.getMembers()\n   * ```\n   */\n  getMembers(): Promise<{ members: RoomSessionMember[] }>\n}\n\nexport type RoomSessionUpdated = EntityUpdated<RoomSession>\nexport interface RoomSessionFullState extends Omit<RoomSession, 'members'> {\n  /** List of members that are part of this room session */\n  members?: RoomSessionMember[]\n}\n\ntype RoomSessionPayload = Optional<VideoRoomEventParams, 'room'>\nexport interface RoomSessionConsumerOptions\n  extends BaseComponentOptionsWithPayload<RoomSessionPayload> {}\n\nexport class RoomSessionConsumer extends BaseConsumer<RealTimeRoomApiEvents> {\n  private _payload: RoomSessionPayload\n\n  /** @internal */\n  protected subscribeParams = {\n    get_initial_state: true,\n  }\n\n  /** @internal */\n  private debouncedSubscribe: ReturnType<typeof debounce>\n\n  constructor(options: RoomSessionConsumerOptions) {\n    super(options)\n\n    this._payload = options.payload\n\n    this.debouncedSubscribe = debounce(this.subscribe, 100)\n  }\n\n  get id() {\n    return this._payload.room_session.id\n  }\n\n  get roomSessionId() {\n    return this._payload.room_session.id\n  }\n\n  get roomId() {\n    return this._payload.room_session.room_id\n  }\n\n  get name() {\n    return this._payload.room_session.name\n  }\n\n  get displayName() {\n    return this._payload.room_session.display_name\n  }\n\n  get hideVideoMuted() {\n    return this._payload.room_session.hide_video_muted\n  }\n\n  get layoutName() {\n    return this._payload.room_session.layout_name\n  }\n\n  get meta() {\n    return this._payload.room_session.meta\n  }\n\n  get previewUrl() {\n    return this._payload.room_session.preview_url\n  }\n\n  get recording() {\n    return this._payload.room_session.recording\n  }\n\n  get locked() {\n    return this._payload.room_session.locked\n  }\n\n  get eventChannel() {\n    return this._payload.room_session.event_channel\n  }\n\n  get prioritizeHandraise() {\n    return this._payload.room_session.prioritize_handraise\n  }\n\n  /** @internal */\n  protected override getSubscriptions() {\n    const eventNamesWithPrefix = this.eventNames().map(\n      (event) => `video.${String(event)}`\n    ) as EventEmitter.EventNames<RealTimeRoomApiEvents>[]\n    return validateEventsToSubscribe(eventNamesWithPrefix)\n  }\n\n  /** @internal */\n  protected _internal_on(\n    event: keyof RealTimeRoomApiEvents,\n    fn: EventEmitter.EventListener<RealTimeRoomApiEvents, any>\n  ) {\n    return super.on(event, fn)\n  }\n\n  on<T extends keyof RealTimeRoomApiEvents>(\n    event: T,\n    fn: EventEmitter.EventListener<RealTimeRoomApiEvents, T>\n  ) {\n    const instance = super.on(event, fn)\n    this.debouncedSubscribe()\n    return instance\n  }\n\n  once<T extends keyof RealTimeRoomApiEvents>(\n    event: T,\n    fn: EventEmitter.EventListener<RealTimeRoomApiEvents, T>\n  ) {\n    const instance = super.once(event, fn)\n    this.debouncedSubscribe()\n    return instance\n  }\n\n  off<T extends keyof RealTimeRoomApiEvents>(\n    event: T,\n    fn: EventEmitter.EventListener<RealTimeRoomApiEvents, T>\n  ) {\n    const instance = super.off(event, fn)\n    return instance\n  }\n\n  /**\n   * @privateRemarks\n   *\n   * Override BaseConsumer `subscribe` to resolve the promise when the 'room.subscribed'\n   * event comes. This way we can return to the user the room full state.\n   * Note: the payload will go through an EventTrasform - see the `type: roomSessionSubscribed`\n   * below.\n   */\n  subscribe() {\n    return new Promise(async (resolve, reject) => {\n      const handler = (payload: RoomSessionFullState) => {\n        resolve(payload)\n      }\n      const subscriptions = this.getSubscriptions()\n      if (subscriptions.length === 0) {\n        this.logger.debug(\n          '`subscribe()` was called without any listeners attached.'\n        )\n        return\n      }\n\n      try {\n        super.once('room.subscribed', handler)\n        await super.subscribe()\n      } catch (error) {\n        super.off('room.subscribed', handler)\n        return reject(error)\n      }\n    })\n  }\n\n  /** @internal */\n  protected setPayload(payload: Optional<VideoRoomEventParams, 'room'>) {\n    this._payload = payload\n  }\n\n  getMembers() {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const { members } = await this.execute<\n          void,\n          { members: RoomSessionMemberEventParams['member'][] }\n        >({\n          method: 'video.members.get',\n          params: {\n            room_session_id: this.roomSessionId,\n          },\n        })\n\n        const memberInstances: RoomSessionMember[] = []\n        members.forEach((member) => {\n          let memberInstance = this.instanceMap.get<RoomSessionMember>(\n            member.id\n          )\n          if (!memberInstance) {\n            memberInstance = createRoomSessionMemberObject({\n              store: this.store,\n              payload: {\n                room_id: this.roomId,\n                room_session_id: this.roomSessionId,\n                member,\n              },\n            })\n          } else {\n            memberInstance.setPayload({\n              member,\n            } as RoomSessionMemberEventParams)\n          }\n          memberInstances.push(memberInstance)\n          this.instanceMap.set<RoomSessionMember>(\n            memberInstance.id,\n            memberInstance\n          )\n        })\n\n        resolve({ members: memberInstances })\n      } catch (error) {\n        reject(error)\n      }\n    })\n  }\n}\n\nexport const RoomSessionAPI = extendComponent<\n  RoomSessionConsumer,\n  Omit<VideoRoomSessionMethods, 'getMembers'>\n>(RoomSessionConsumer, {\n  videoMute: Rooms.videoMuteMember,\n  videoUnmute: Rooms.videoUnmuteMember,\n  audioMute: Rooms.audioMuteMember,\n  audioUnmute: Rooms.audioUnmuteMember,\n  deaf: Rooms.deafMember,\n  undeaf: Rooms.undeafMember,\n  setInputVolume: Rooms.setInputVolumeMember,\n  setOutputVolume: Rooms.setOutputVolumeMember,\n  setMicrophoneVolume: Rooms.setInputVolumeMember,\n  setSpeakerVolume: Rooms.setOutputVolumeMember,\n  setInputSensitivity: Rooms.setInputSensitivityMember,\n  removeMember: Rooms.removeMember,\n  removeAllMembers: Rooms.removeAllMembers,\n  setHideVideoMuted: Rooms.setHideVideoMuted,\n  getLayouts: Rooms.getLayouts,\n  setLayout: Rooms.setLayout,\n  setPositions: Rooms.setPositions,\n  setMemberPosition: Rooms.setMemberPosition,\n  getRecordings: Rooms.getRecordings,\n  startRecording: Rooms.startRecording,\n  getPlaybacks: Rooms.getPlaybacks,\n  play: Rooms.play,\n  getMeta: Rooms.getMeta,\n  setMeta: Rooms.setMeta,\n  updateMeta: Rooms.updateMeta,\n  deleteMeta: Rooms.deleteMeta,\n  getMemberMeta: Rooms.getMemberMeta,\n  setMemberMeta: Rooms.setMemberMeta,\n  updateMemberMeta: Rooms.updateMemberMeta,\n  deleteMemberMeta: Rooms.deleteMemberMeta,\n  promote: Rooms.promote,\n  demote: Rooms.demote,\n  getStreams: Rooms.getStreams,\n  startStream: Rooms.startStream,\n  lock: Rooms.lock,\n  unlock: Rooms.unlock,\n  setRaisedHand: Rooms.setRaisedHand,\n  setPrioritizeHandraise: Rooms.setPrioritizeHandraise,\n})\n\nexport const createRoomSessionObject = (\n  params: RoomSessionConsumerOptions\n): RoomSession => {\n  const roomSession = connect<\n    RealTimeRoomApiEvents,\n    RoomSessionConsumer,\n    RoomSession\n  >({\n    store: params.store,\n    Component: RoomSessionAPI,\n  })(params)\n\n  return roomSession\n}\n", "import {\n  connect,\n  BaseComponent,\n  BaseComponentOptionsWithPayload,\n  extendComponent,\n  Rooms,\n  VideoMemberContract,\n  VideoMemberMethods,\n  EntityUpdated,\n  VideoMemberJoinedEventParams,\n  VideoMemberLeftEventParams,\n  VideoMemberUpdatedEventParams,\n  VideoMemberTalkingEventParams,\n} from '@signalwire/core'\n\n/**\n * Represents a member of a room session. You receive instances of this type by\n * listening to room events, for example on a {@link RoomSession} object.\n *\n * > \u2139\uFE0F State of RoomSessionMember objects\n * >\n * > The state of RoomSessionMember objects, for example `member.visible`, is\n * > immutable. When you receive instances of RoomSessionMember from event\n * > listeners, the state of the member always refers to that specific point in\n * > time and remains fixed for the whole lifetime of the object.\n */\nexport interface RoomSessionMember extends VideoMemberContract {\n  setPayload(payload: RoomSessionMemberEventParams): void\n}\nexport type RoomSessionMemberUpdated = EntityUpdated<RoomSessionMember>\n\nexport type RoomSessionMemberEventParams =\n  | (\n      | VideoMemberJoinedEventParams\n      | VideoMemberLeftEventParams\n      | VideoMemberUpdatedEventParams\n    ) &\n      VideoMemberTalkingEventParams\n\nexport interface RoomSessionMemberOptions\n  extends BaseComponentOptionsWithPayload<RoomSessionMemberEventParams> {}\n\n// TODO: Extend from a variant of `BaseComponent` that\n// doesn't expose EventEmitter methods\nclass RoomSessionMemberComponent extends BaseComponent<{}> {\n  private _payload: RoomSessionMemberEventParams\n\n  constructor(options: RoomSessionMemberOptions) {\n    super(options)\n\n    this._payload = options.payload\n  }\n\n  get id() {\n    return this._payload.member.id\n  }\n\n  get memberId() {\n    return this._payload.member.id\n  }\n\n  get roomSessionId() {\n    return this._payload.member.room_session_id\n  }\n\n  get roomId() {\n    return this._payload.member.room_id\n  }\n\n  get parentId() {\n    return this._payload.member.parent_id\n  }\n\n  get name() {\n    return this._payload.member.name\n  }\n\n  get type() {\n    return this._payload.member.type\n  }\n\n  get meta() {\n    return this._payload.member.meta\n  }\n\n  get requestedPosition() {\n    return this._payload.member.requested_position\n  }\n\n  get visible() {\n    return this._payload.member.visible\n  }\n\n  get audioMuted() {\n    return this._payload.member.audio_muted\n  }\n\n  get videoMuted() {\n    return this._payload.member.video_muted\n  }\n\n  get deaf() {\n    return this._payload.member.deaf\n  }\n\n  get inputVolume() {\n    return this._payload.member.input_volume\n  }\n\n  get outputVolume() {\n    return this._payload.member.output_volume\n  }\n\n  get inputSensitivity() {\n    return this._payload.member.input_sensitivity\n  }\n\n  get talking() {\n    return this._payload.member.talking\n  }\n\n  get handraised() {\n    return this._payload.member.handraised\n  }\n\n  /** @internal */\n  protected setPayload(payload: RoomSessionMemberEventParams) {\n    // Reshape the payload since the `video.member.talking` event does not return all the parameters of a member\n    const newPayload = {\n      ...payload,\n      member: {\n        ...this._payload.member,\n        ...payload.member,\n      },\n    }\n    this._payload = newPayload\n  }\n\n  async remove() {\n    await this.execute({\n      method: 'video.member.remove',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        member_id: this.getStateProperty('memberId'),\n      },\n    })\n  }\n}\n\nconst RoomSessionMemberAPI = extendComponent<\n  RoomSessionMemberComponent,\n  // `remove` is defined by `RoomSessionMemberComponent`\n  Omit<VideoMemberMethods, 'remove'>\n>(RoomSessionMemberComponent, {\n  audioMute: Rooms.audioMuteMember,\n  audioUnmute: Rooms.audioUnmuteMember,\n  videoMute: Rooms.videoMuteMember,\n  videoUnmute: Rooms.videoUnmuteMember,\n  setDeaf: Rooms.setDeaf,\n  setMicrophoneVolume: Rooms.setInputVolumeMember,\n  setInputVolume: Rooms.setInputVolumeMember,\n  setSpeakerVolume: Rooms.setOutputVolumeMember,\n  setOutputVolume: Rooms.setOutputVolumeMember,\n  setInputSensitivity: Rooms.setInputSensitivityMember,\n  setRaisedHand: Rooms.setRaisedHand,\n})\n\nexport const createRoomSessionMemberObject = (\n  params: RoomSessionMemberOptions\n): RoomSessionMember => {\n  const member = connect<{}, RoomSessionMemberComponent, RoomSessionMember>({\n    store: params.store,\n    Component: RoomSessionMemberAPI,\n  })(params)\n\n  return member\n}\n", "import {\n  MapToPubSubShape,\n  SDKActions,\n  SDKWorker,\n  SagaIterator,\n  VideoAPIEventParams,\n  getLogger,\n  sagaEffects,\n  SDKWorkerParams,\n} from '@signalwire/core'\nimport { fork } from '@redux-saga/core/effects'\nimport { Client } from '../VideoClient'\nimport { videoRoomWorker } from './videoRoomWorker'\nimport { videoMemberWorker } from './videoMemberWorker'\nimport { videoPlaybackWorker } from './videoPlaybackWorker'\nimport { videoRecordingWorker } from './videoRecordingWorker'\nimport { videoStreamWorker } from './videoStreamWorker'\nimport { videoLayoutWorker } from './videoLayoutWorker'\nimport { videoRoomAudienceWorker } from './videoRoomAudienceWorker'\n\nexport type VideoCallWorkerParams<T> = SDKWorkerParams<Client> & {\n  action: T\n}\n\nexport const videoCallingWorker: SDKWorker<Client> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('videoCallingWorker started')\n  const { channels } = options\n  const { swEventChannel } = channels\n\n  function* worker(action: MapToPubSubShape<VideoAPIEventParams>) {\n    const { type } = action\n\n    switch (type) {\n      case 'video.room.started':\n      case 'video.room.updated':\n      case 'video.room.ended':\n      case 'video.room.subscribed':\n        yield fork(videoRoomWorker, {\n          action,\n          ...options,\n        })\n        break\n      case 'video.member.joined':\n      case 'video.member.left':\n      case 'video.member.updated':\n      case 'video.member.talking':\n        yield fork(videoMemberWorker, {\n          action,\n          ...options,\n        })\n        break\n      case 'video.playback.started':\n      case 'video.playback.updated':\n      case 'video.playback.ended':\n        yield fork(videoPlaybackWorker, {\n          action,\n          ...options,\n        })\n        break\n      case 'video.recording.started':\n      case 'video.recording.updated':\n      case 'video.recording.ended':\n        yield fork(videoRecordingWorker, {\n          action,\n          ...options,\n        })\n        break\n      case 'video.stream.started':\n      case 'video.stream.ended':\n        yield fork(videoStreamWorker, {\n          action,\n          ...options,\n        })\n        break\n      case 'video.layout.changed':\n        yield fork(videoLayoutWorker, {\n          action,\n          ...options,\n        })\n        break\n      case 'video.room.audience_count':\n        yield fork(videoRoomAudienceWorker, {\n          action,\n          ...options,\n        })\n        break\n      default:\n        getLogger().warn(`Unknown video event: \"${type}\"`)\n        break\n    }\n  }\n\n  const isVideoEvent = (action: SDKActions) => action.type.startsWith('video.')\n\n  while (true) {\n    const action: MapToPubSubShape<VideoAPIEventParams> =\n      yield sagaEffects.take(swEventChannel, isVideoEvent)\n\n    yield fork(worker, action)\n  }\n\n  getLogger().trace('videoCallingWorker ended')\n}\n", "import {\n  getLogger,\n  InternalVideoMemberEntity,\n  SagaIterator,\n  MemberPosition,\n  MapToPubSubShape,\n  InternalMemberUpdatedEventNames,\n  VideoRoomEvent,\n  stripNamespacePrefix,\n  RoomStarted,\n  RoomUpdated,\n  RoomEnded,\n  RoomSubscribed,\n} from '@signalwire/core'\nimport { spawn, fork } from '@redux-saga/core/effects'\nimport { createRoomSessionObject, RoomSession } from '../RoomSession'\nimport { videoMemberWorker } from './videoMemberWorker'\nimport {\n  createRoomSessionMemberObject,\n  RoomSessionMember,\n} from '../RoomSessionMember'\nimport { VideoCallWorkerParams } from './videoCallingWorker'\n\nexport const videoRoomWorker = function* (\n  options: VideoCallWorkerParams<MapToPubSubShape<VideoRoomEvent>>\n): SagaIterator {\n  getLogger().trace('videoRoomWorker started')\n  const { instance: client, action, ...memberPositionWorkerParams } = options\n  const { type, payload } = action\n  const { get, set, remove } = options.instanceMap\n\n  let roomSessionInstance = get<RoomSession>(payload.room_session.id)\n  if (!roomSessionInstance) {\n    roomSessionInstance = createRoomSessionObject({\n      // @ts-expect-error\n      store: client.store,\n      payload,\n    })\n  } else {\n    roomSessionInstance.setPayload(payload)\n  }\n  set<RoomSession>(payload.room_session.id, roomSessionInstance)\n\n  // Create and set member instance if exists\n  if ((payload.room_session.members?.length || 0) > 0) {\n    ;(payload.room_session.members || []).forEach((member) => {\n      let memberInstance = get<RoomSessionMember>(member.id)\n      if (!memberInstance) {\n        memberInstance = createRoomSessionMemberObject({\n          // @ts-expect-error\n          store: client.store,\n          payload: {\n            room_id: payload.room_session.room_id,\n            room_session_id: payload.room_session.id,\n            // @ts-expect-error\n            member,\n          },\n        })\n      } else {\n        memberInstance.setPayload({\n          room_id: payload.room_session.room_id,\n          room_session_id: payload.room_session.id,\n          member: member as InternalVideoMemberEntity & { talking: boolean },\n        })\n      }\n      set<RoomSessionMember>(member.id, memberInstance)\n    })\n  }\n\n  const event = stripNamespacePrefix(type) as\n    | RoomStarted\n    | RoomUpdated\n    | RoomEnded\n    | RoomSubscribed\n\n  switch (type) {\n    case 'video.room.started':\n    case 'video.room.updated': {\n      // The `room.updated` event is not documented in @RealTimeVideoApiEvents. For now, ignoring TS issue.\n      // @ts-expect-error\n      client.emit(event, roomSessionInstance)\n      roomSessionInstance.emit(event, roomSessionInstance)\n      break\n    }\n    case 'video.room.ended': {\n      client.emit(event as RoomEnded, roomSessionInstance)\n      roomSessionInstance.emit(event, roomSessionInstance)\n      remove<RoomSession>(payload.room_session.id)\n      break\n    }\n    case 'video.room.subscribed': {\n      yield spawn(MemberPosition.memberPositionWorker, {\n        ...memberPositionWorkerParams,\n        instance: roomSessionInstance,\n        initialState: payload,\n        dispatcher: function* (\n          subType: InternalMemberUpdatedEventNames,\n          subPayload\n        ) {\n          yield fork(videoMemberWorker, {\n            ...options,\n            action: { type: subType, payload: subPayload },\n          })\n        },\n      })\n      roomSessionInstance.emit(event, roomSessionInstance)\n      break\n    }\n    default:\n      break\n  }\n\n  getLogger().trace('videoRoomWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  MapToPubSubShape,\n  VideoMemberJoinedEvent,\n  VideoMemberLeftEvent,\n  VideoMemberUpdatedEvent,\n  VideoMemberTalkingEvent,\n  InternalVideoMemberUpdatedEvent,\n  fromSnakeToCamelCase,\n  stripNamespacePrefix,\n  VideoMemberEventNames,\n  MemberTalkingEventNames,\n} from '@signalwire/core'\nimport { RoomSession } from '../RoomSession'\nimport {\n  createRoomSessionMemberObject,\n  RoomSessionMember,\n  RoomSessionMemberEventParams,\n} from '../RoomSessionMember'\nimport { VideoCallWorkerParams } from './videoCallingWorker'\n\ntype VideoMemberEvents = MapToPubSubShape<\n  | VideoMemberJoinedEvent\n  | VideoMemberLeftEvent\n  | VideoMemberUpdatedEvent\n  | VideoMemberTalkingEvent\n  | InternalVideoMemberUpdatedEvent\n>\n\nexport const videoMemberWorker = function* (\n  options: VideoCallWorkerParams<VideoMemberEvents>\n): SagaIterator {\n  getLogger().trace('videoMemberWorker started')\n  const {\n    instance,\n    action: { type, payload },\n    instanceMap: { get, set, remove },\n  } = options\n\n  const roomSessionInstance = get<RoomSession>(payload.room_session_id)\n  if (!roomSessionInstance) {\n    throw new Error('Missing room session instance for member')\n  }\n\n  let memberInstance = get<RoomSessionMember>(payload.member.id)\n  if (!memberInstance) {\n    memberInstance = createRoomSessionMemberObject({\n      // @ts-expect-error\n      store: instance.store,\n      payload: payload as RoomSessionMemberEventParams,\n    })\n  } else {\n    memberInstance.setPayload(payload as RoomSessionMemberEventParams)\n  }\n  set<RoomSessionMember>(payload.member.id, memberInstance)\n\n  const event = stripNamespacePrefix(type) as VideoMemberEventNames\n\n  if (type.startsWith('video.member.updated.')) {\n    const clientType = fromSnakeToCamelCase(event)\n    // @ts-expect-error\n    roomSessionInstance.emit(clientType, memberInstance)\n  }\n\n  switch (type) {\n    case 'video.member.joined':\n    case 'video.member.updated':\n      roomSessionInstance.emit(event, memberInstance)\n      break\n    case 'video.member.left':\n      roomSessionInstance.emit(event, memberInstance)\n      remove<RoomSessionMember>(payload.member.id)\n      break\n    case 'video.member.talking':\n      roomSessionInstance.emit(event, memberInstance)\n      if ('talking' in payload.member) {\n        const suffix = payload.member.talking ? 'started' : 'ended'\n        roomSessionInstance.emit(\n          `${event}.${suffix}` as MemberTalkingEventNames,\n          memberInstance\n        )\n\n        // Keep for backwards compatibility\n        const deprecatedSuffix = payload.member.talking ? 'start' : 'stop'\n        roomSessionInstance.emit(\n          `${event}.${deprecatedSuffix}` as MemberTalkingEventNames,\n          memberInstance\n        )\n      }\n      break\n    default:\n      break\n  }\n\n  getLogger().trace('videoMemberWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  MapToPubSubShape,\n  VideoPlaybackEvent,\n  RoomSessionPlayback,\n  Rooms,\n  stripNamespacePrefix,\n  VideoPlaybackEventNames,\n} from '@signalwire/core'\nimport { RoomSession } from '../RoomSession'\nimport { VideoCallWorkerParams } from './videoCallingWorker'\n\nexport const videoPlaybackWorker = function* (\n  options: VideoCallWorkerParams<MapToPubSubShape<VideoPlaybackEvent>>\n): SagaIterator {\n  getLogger().trace('videoPlaybackWorker started')\n  const {\n    instance: client,\n    action: { type, payload },\n    instanceMap: { get, set, remove },\n  } = options\n\n  const roomSessionInstance = get<RoomSession>(payload.room_session_id)\n  if (!roomSessionInstance) {\n    throw new Error('Missing room session instance for playback')\n  }\n\n  let playbackInstance = get<RoomSessionPlayback>(payload.playback.id)\n  if (!playbackInstance) {\n    playbackInstance = Rooms.createRoomSessionPlaybackObject({\n      // @ts-expect-error\n      store: client.store,\n      payload,\n    })\n  } else {\n    playbackInstance.setPayload(payload)\n  }\n  set<RoomSessionPlayback>(payload.playback.id, playbackInstance)\n\n  const event = stripNamespacePrefix(type) as VideoPlaybackEventNames\n\n  switch (type) {\n    case 'video.playback.started':\n    case 'video.playback.updated':\n      roomSessionInstance.emit(event, playbackInstance)\n      break\n    case 'video.playback.ended':\n      roomSessionInstance.emit(event, playbackInstance)\n      remove<RoomSessionPlayback>(payload.playback.id)\n      break\n    default:\n      break\n  }\n\n  getLogger().trace('videoPlaybackWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  MapToPubSubShape,\n  VideoRecordingEvent,\n  RoomSessionRecording,\n  Rooms,\n  VideoRecordingEventNames,\n  stripNamespacePrefix,\n} from '@signalwire/core'\nimport { RoomSession } from '../RoomSession'\nimport { VideoCallWorkerParams } from './videoCallingWorker'\n\nexport const videoRecordingWorker = function* (\n  options: VideoCallWorkerParams<MapToPubSubShape<VideoRecordingEvent>>\n): SagaIterator {\n  getLogger().trace('videoRecordingWorker started')\n  const {\n    instance: client,\n    action: { type, payload },\n    instanceMap: { get, set, remove },\n  } = options\n\n  const roomSessionInstance = get<RoomSession>(payload.room_session_id)\n  if (!roomSessionInstance) {\n    throw new Error('Missing room session instance for playback')\n  }\n\n  let recordingInstance = get<RoomSessionRecording>(payload.recording.id)\n  if (!recordingInstance) {\n    recordingInstance = Rooms.createRoomSessionRecordingObject({\n      // @ts-expect-error\n      store: client.store,\n      payload,\n    })\n  } else {\n    recordingInstance.setPayload(payload)\n  }\n  set<RoomSessionRecording>(payload.recording.id, recordingInstance)\n\n  const event = stripNamespacePrefix(type) as VideoRecordingEventNames\n\n  switch (type) {\n    case 'video.recording.started':\n    case 'video.recording.updated':\n      roomSessionInstance.emit(event, recordingInstance)\n      break\n    case 'video.recording.ended':\n      roomSessionInstance.emit(event, recordingInstance)\n      remove<RoomSessionRecording>(payload.recording.id)\n      break\n    default:\n      break\n  }\n\n  getLogger().trace('videoRecordingWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  MapToPubSubShape,\n  Rooms,\n  RoomSessionStream,\n  VideoStreamEvent,\n  stripNamespacePrefix,\n  VideoStreamEventNames,\n} from '@signalwire/core'\nimport { RoomSession } from '../RoomSession'\nimport { VideoCallWorkerParams } from './videoCallingWorker'\n\nexport const videoStreamWorker = function* (\n  options: VideoCallWorkerParams<MapToPubSubShape<VideoStreamEvent>>\n): SagaIterator {\n  getLogger().trace('videoStreamWorker started')\n  const {\n    instance: client,\n    action: { type, payload },\n    instanceMap: { get, set, remove },\n  } = options\n\n  const roomSessionInstance = get<RoomSession>(payload.room_session_id)\n  if (!roomSessionInstance) {\n    throw new Error('Missing room session instance for stream')\n  }\n\n  let streamInstance = get<RoomSessionStream>(payload.stream.id)\n  if (!streamInstance) {\n    streamInstance = Rooms.createRoomSessionStreamObject({\n      // @ts-expect-error\n      store: client.store,\n      payload,\n    })\n  } else {\n    streamInstance.setPayload(payload)\n  }\n  set<RoomSessionStream>(payload.stream.id, streamInstance)\n\n  const event = stripNamespacePrefix(type) as VideoStreamEventNames\n\n  switch (type) {\n    case 'video.stream.started':\n      roomSessionInstance.emit(event, streamInstance)\n      break\n    case 'video.stream.ended':\n      roomSessionInstance.emit(event, streamInstance)\n      remove<RoomSessionStream>(payload.stream.id)\n      break\n    default:\n      break\n  }\n\n  getLogger().trace('videoStreamWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  MapToPubSubShape,\n  VideoLayoutChangedEvent,\n  toExternalJSON,\n  stripNamespacePrefix,\n  VideoLayoutEventNames,\n} from '@signalwire/core'\nimport { RoomSession } from '../RoomSession'\nimport { VideoCallWorkerParams } from './videoCallingWorker'\n\nexport const videoLayoutWorker = function* (\n  options: VideoCallWorkerParams<MapToPubSubShape<VideoLayoutChangedEvent>>\n): SagaIterator {\n  getLogger().trace('videoLayoutWorker started')\n  const {\n    action: { type, payload },\n    instanceMap: { get },\n  } = options\n\n  const roomSessionInstance = get<RoomSession>(payload.room_session_id)\n  if (!roomSessionInstance) {\n    throw new Error('Missing room session instance for playback')\n  }\n\n  // TODO: Implement a Layout object when we have a proper payload from the backend\n  // Create a layout instance and emit that instance\n\n  const event = stripNamespacePrefix(type) as VideoLayoutEventNames\n\n  switch (type) {\n    case 'video.layout.changed':\n      roomSessionInstance.emit(event, toExternalJSON(payload))\n      break\n    default:\n      break\n  }\n\n  getLogger().trace('videoLayoutWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  MapToPubSubShape,\n  toExternalJSON,\n  VideoRoomAudienceCountEvent,\n} from '@signalwire/core'\nimport { RoomSession } from '../RoomSession'\nimport { VideoCallWorkerParams } from './videoCallingWorker'\n\nexport const videoRoomAudienceWorker = function* (\n  options: VideoCallWorkerParams<MapToPubSubShape<VideoRoomAudienceCountEvent>>\n): SagaIterator {\n  getLogger().trace('videoRoomAudienceWorker started')\n  const {\n    action: { type, payload },\n    instanceMap: { get },\n  } = options\n\n  const roomSessionInstance = get<RoomSession>(payload.room_session_id)\n  if (!roomSessionInstance) {\n    throw new Error('Missing room session instance for playback')\n  }\n\n  switch (type) {\n    case 'video.room.audience_count':\n      roomSessionInstance.emit('room.audienceCount', toExternalJSON(payload))\n      break\n    default:\n      break\n  }\n\n  getLogger().trace('videoRoomAudienceWorker ended')\n}\n", "/**\n * Note: This file will eventually replace\n * packages/realtime-api/src/Client.ts\n */\n\nimport {\n  BaseClient as CoreBaseClient,\n  ClientContract,\n  ClientEvents,\n} from '@signalwire/core'\n\nexport interface RealtimeClient\n  extends ClientContract<RealtimeClient, ClientEvents> {\n  /**\n   * Connects this client to the SignalWire network.\n   *\n   * As a general best practice, it is suggested to connect the event listeners\n   * *before* connecting the client, so that no events are lost.\n   *\n   * @returns Upon connection, asynchronously returns an instance of this same\n   * object.\n   *\n   * @example\n   * ```typescript\n   * const client = await createClient({project, token})\n   * client.video.on('room.started', async (roomSession) => { })  // connect events\n   * await client.connect()\n   * ```\n   */\n  connect(): Promise<RealtimeClient>\n\n  /**\n   * Disconnects this client from the SignalWire network.\n   */\n  disconnect(): void\n}\n\nexport class Client extends CoreBaseClient<ClientEvents> {}\n", "import { RealtimeClient } from './Client'\n\nexport const clientConnect = (client: RealtimeClient) => {\n  /**\n   * We swallow the (possible) error here to avoid polluting\n   * the stdout. The error itself won't be swallowed from\n   * the user (it will be handled by our `rootSaga`) and we\n   * can extend that behavior by adding the following\n   * listener:\n   * client.on('session.auth_error', () => { ... })\n   */\n  return client.connect().catch(() => {})\n}\n", "import { getLogger, UserOptions } from '@signalwire/core'\nimport { getCredentials } from '../utils/internals'\nimport { clientProxyFactory } from './clientProxyFactory'\nimport { getClient, ClientConfig, ClientCache } from './getClient'\n\ninterface SetupClientOptions {\n  project?: string\n  token?: string\n  logLevel?: UserOptions['logLevel']\n  cache?: ClientCache\n}\n\nexport const setupClient = (userOptions?: SetupClientOptions): ClientConfig => {\n  const credentials = getCredentials({\n    token: userOptions?.token,\n    project: userOptions?.project,\n  })\n  const { client, store, emitter } = getClient({\n    ...userOptions,\n    ...credentials,\n  })\n\n  // @ts-expect-error\n  client.session.on('session.auth_error', () => {\n    getLogger().error(\"Wrong credentials: couldn't connect the client.\")\n\n    // TODO: we can execute the future `onConnectError` from here.\n  })\n\n  const proxiedClient = clientProxyFactory(client)\n\n  return {\n    client: proxiedClient,\n    store,\n    emitter,\n  }\n}\n", "import { configureStore, getEventEmitter, UserOptions } from '@signalwire/core'\nimport { getConfig } from '../configure'\nimport { Session } from '../Session'\n\nexport const setupInternals = (userOptions: {\n  project: string\n  token: string\n  logLevel?: UserOptions['logLevel']\n}) => {\n  /**\n   * The emitter will be used across the entire stack so no\n   * need to type it here. Typings will be provided by each\n   * constructor.\n   */\n  const emitter = getEventEmitter<any>()\n\n  const baseOptions = {\n    ...userOptions,\n    emitter,\n  }\n\n  const store = configureStore({\n    userOptions: baseOptions,\n    SessionConstructor: Session,\n  })\n\n  return { store, emitter }\n}\n\nconst getToken = (userToken?: string) => {\n  const globalConfig = getConfig()\n  const token = userToken || globalConfig.token || process.env.SW_TOKEN\n\n  if (!token) {\n    // TODO: Add error message\n    throw new Error('Missing `token`')\n  }\n\n  return token\n}\n\nconst getProject = (userProject?: string) => {\n  const globalConfig = getConfig()\n  const project = userProject || globalConfig.project || process.env.SW_PROJECT\n\n  if (!project) {\n    // TODO: Add error message\n    throw new Error('Missing `project`')\n  }\n\n  return project\n}\n\ninterface GetCredentialsOptions {\n  token?: string\n  project?: string\n}\n\nexport const getCredentials = (options?: GetCredentialsOptions) => {\n  const project = getProject(options?.project)\n  const token = getToken(options?.token)\n\n  return { project, token }\n}\n", "export interface GlobalConfig {\n  token?: string\n  project?: string\n}\n\nlet GLOBAL_CONFIG: GlobalConfig = {}\n\nexport const getConfig = (): GlobalConfig => {\n  return GLOBAL_CONFIG\n}\n\n/** @ignore */\nexport interface ConfigOptions extends GlobalConfig {\n  /** @internal */\n  cache?: GlobalConfig\n}\n\n/** @internal */\nexport const config = ({\n  cache = GLOBAL_CONFIG,\n  ...options\n}: ConfigOptions) => {\n  if (cache) {\n    GLOBAL_CONFIG = cache\n  }\n\n  Object.entries(options).forEach(([key, value]) => {\n    // TODO: filter out properties\n    // @ts-expect-error\n    GLOBAL_CONFIG[key] = value\n  })\n}\n", "import { BaseSession, SWCloseEvent } from '@signalwire/core'\nimport WebSocket from 'ws'\n\nexport class Session extends BaseSession {\n  public WebSocketConstructor = WebSocket\n  public CloseEventConstructor = SWCloseEvent\n  public agent = process.env.SDK_PKG_AGENT!\n}\n", "import { RealtimeClient } from './Client'\nimport { clientConnect as baseClientConnect } from './clientConnect'\n\ninterface ClientInterceptors {\n  connect?: (client: RealtimeClient) => Promise<void | RealtimeClient>\n}\n\nconst defaultInterceptors: ClientInterceptors = {\n  connect: baseClientConnect,\n}\n\nexport const clientProxyFactory = (\n  client: RealtimeClient,\n  interceptors: ClientInterceptors = defaultInterceptors\n) => {\n  const clientConnect = interceptors.connect || baseClientConnect\n\n  // Client interceptors\n  const clientOn: RealtimeClient['on'] = (...args) => {\n    clientConnect(client)\n\n    return client.on(...args)\n  }\n  const clientOnce: RealtimeClient['once'] = (...args) => {\n    clientConnect(client)\n\n    return client.once(...args)\n  }\n\n  return new Proxy<RealtimeClient>(client, {\n    get(target: RealtimeClient, prop: keyof RealtimeClient, receiver: any) {\n      if (prop === 'on') {\n        return clientOn\n      } else if (prop === 'once') {\n        return clientOnce\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n}\n", "import {\n  ClientEvents,\n  configureStore,\n  connect,\n  EventEmitter,\n  UserOptions,\n} from '@signalwire/core'\nimport { setupInternals } from '../utils/internals'\nimport { Client, RealtimeClient } from './Client'\n\nexport interface ClientConfig {\n  client: RealtimeClient\n  store: ReturnType<typeof configureStore>\n  emitter: EventEmitter<any>\n}\n\nexport type ClientCache = Map<string, ClientConfig>\n\nconst CLIENTS_MAP: ClientCache = new Map()\n\n// const getClientKey = ({\n//   project,\n//   token,\n// }: {\n//   project: string\n//   token: string\n// }) => {\n//   return `${project}:${token}`\n// }\n\nconst createClient = (userOptions: {\n  project: string\n  token: string\n  logLevel?: UserOptions['logLevel']\n  store: ReturnType<typeof configureStore>\n  emitter: EventEmitter\n}) => {\n  const client = connect<ClientEvents, Client, RealtimeClient>({\n    store: userOptions.store,\n    Component: Client,\n  })(userOptions)\n\n  return client\n}\n\nexport const getClient = ({\n  cache = CLIENTS_MAP,\n  ...userOptions\n}: {\n  project: string\n  token: string\n  logLevel?: UserOptions['logLevel']\n  cache?: ClientCache\n}): ClientConfig => {\n  // const clientKey = getClientKey({\n  //   project: userOptions.project,\n  //   token: userOptions.token,\n  // })\n\n  // if (cache.has(clientKey)) {\n  //   // @ts-expect-error\n  //   return cache.get(clientKey)\n  // } else {\n  const { emitter, store } = setupInternals(userOptions)\n  const client = createClient({\n    ...userOptions,\n    store,\n    emitter,\n  })\n  const config: ClientConfig = {\n    client,\n    store,\n    emitter,\n  }\n  // cache.set(clientKey, config)\n  return config\n  // }\n}\n", "import type { UserOptions } from '@signalwire/core'\nimport type { RealTimeVideoApiEvents } from '../types'\nimport { setupClient, clientConnect } from '../client/index'\nimport { createVideoObject, Video } from './Video'\n\n/**\n * List of events for {@link Video.Client}.\n */\nexport interface VideoClientApiEvents extends RealTimeVideoApiEvents {}\n\nexport interface VideoApiFullState extends VideoClient {}\n\ninterface VideoClient extends Video {\n  new (opts: VideoClientOptions): this\n}\n\nexport interface VideoClientOptions\n  extends Omit<UserOptions, 'host' | '_onRefreshToken' | 'token'> {\n  token?: string\n}\n\n/**\n * You can use instances of this class to subscribe to video events. Please see\n * {@link VideoClientApiEvents} for the full list of events you can subscribe\n * to.\n *\n * @param options - {@link VideoClientOptions}\n *\n * @example\n *\n * ```javascript\n * const video = new Video.Client({\n *   project: '<project-id>',\n *   token: '<project-token>'\n * })\n *\n * video.on('room.started', async (roomSession) => {\n *   console.log(\"Room started\")\n * });\n *\n * video.on('room.ended', async (roomSession) => {\n *   console.log(\"Room ended\")\n * });\n * ```\n */\nconst VideoClient = function (options?: VideoClientOptions) {\n  const { client, store } = setupClient(options)\n\n  const video = createVideoObject({\n    store,\n  })\n\n  const videoSubscribe: Video['subscribe'] = async () => {\n    await clientConnect(client)\n\n    return video.subscribe()\n  }\n\n  const interceptors = {\n    // keep subscribe in here to await clientConnect\n    subscribe: videoSubscribe,\n    _session: client,\n    disconnect: () => client.disconnect(),\n  } as const\n\n  return new Proxy<Omit<VideoClient, 'new'>>(video, {\n    get(target: VideoClient, prop: keyof VideoClient, receiver: any) {\n      if (prop in interceptors) {\n        // @ts-expect-error\n        return interceptors[prop]\n      }\n\n      // Always connect the underlying client if the user call a function on the Proxy\n      if (typeof target[prop] === 'function') {\n        clientConnect(client)\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n  // For consistency with other constructors we'll make TS force the use of `new`\n} as unknown as { new (options?: VideoClientOptions): VideoClient }\n\nexport { VideoClient as Client }\n", "import {\n  ClientEvents,\n  configureStore,\n  connect,\n  getEventEmitter,\n  UserOptions,\n  InternalUserOptions,\n} from '@signalwire/core'\nimport { Client, RealtimeClient } from './Client'\nimport { Session } from './Session'\n\n/** @internal */\nexport interface CreateClientOptions extends UserOptions {}\nexport type { RealtimeClient, ClientEvents }\n\n/**\n * Creates a real-time Client.\n * @param userOptions\n * @param userOptions.project SignalWire project id, e.g. `a10d8a9f-2166-4e82-56ff-118bc3a4840f`\n * @param userOptions.token SignalWire project token, e.g. `PT9e5660c101cd140a1c93a0197640a369cf5f16975a0079c9`\n * @param userOptions.logLevel logging level\n * @returns an instance of a real-time Client.\n *\n * @example\n * ```typescript\n * const client = await createClient({\n *   project: '<project-id>',\n *   token: '<project-token>'\n * })\n * ```\n *\n * @deprecated You no longer need to create the client\n * manually. You can use the product constructors, like\n * {@link Video.Client}, to access the same functionality.\n */\nexport const createClient: (userOptions: {\n  project?: string\n  token: string\n  logLevel?: 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'silent'\n}) => Promise<RealtimeClient> =\n  // Note: types are inlined for clarity of documentation\n  async (userOptions) => {\n    const baseUserOptions: InternalUserOptions = {\n      ...userOptions,\n      emitter: getEventEmitter<ClientEvents>(),\n    }\n    const store = configureStore({\n      userOptions: baseUserOptions,\n      SessionConstructor: Session,\n    })\n\n    const client = connect<ClientEvents, Client, RealtimeClient>({\n      store,\n      Component: Client,\n      sessionListeners: {\n        authStatus: 'onAuth',\n      },\n    })(baseUserOptions)\n\n    return client\n  }\n", "import {\n  BaseClient,\n  EventsPrefix,\n  SessionState,\n  ClientContract,\n  ClientEvents,\n} from '@signalwire/core'\nimport { createVideoObject, Video } from './video/Video'\n\n/**\n * A real-time Client.\n *\n * To construct an instance of this class, please use {@link createClient}.\n *\n * Example usage:\n * ```typescript\n * import {createClient} from '@signalwire/realtime-api'\n *\n * // Obtain a client:\n * const client = await createClient({ project, token })\n *\n * // Listen on events:\n * client.video.on('room.started', async (room) => { })\n *\n * // Connect:\n * await client.connect()\n * ```\n * @deprecated It's no longer needed to create the client\n * manually. You can use the product constructors, like\n * Video.Client, to access the same functionality.\n */\nexport interface RealtimeClient\n  extends ClientContract<RealtimeClient, ClientEvents> {\n  /**\n   * Connects this client to the SignalWire network.\n   *\n   * As a general best practice, it is suggested to connect the event listeners\n   * *before* connecting the client, so that no events are lost.\n   *\n   * @returns Upon connection, asynchronously returns an instance of this same\n   * object.\n   *\n   * @example\n   * ```typescript\n   * const client = await createClient({project, token})\n   * client.video.on('room.started', async (roomSession) => { })  // connect events\n   * await client.connect()\n   * ```\n   */\n  connect(): Promise<RealtimeClient>\n\n  /**\n   * Disconnects this client from the SignalWire network.\n   */\n  disconnect(): void\n\n  /**\n   * Access the Video API Consumer\n   */\n  video: Video\n}\n\ntype ClientNamespaces = Video\n\nexport class Client extends BaseClient<ClientEvents> {\n  private _consumers: Map<EventsPrefix, ClientNamespaces> = new Map()\n\n  async onAuth(session: SessionState) {\n    try {\n      if (session.authStatus === 'authorized') {\n        this._consumers.forEach((consumer) => {\n          consumer.subscribe()\n        })\n      }\n    } catch (error) {\n      this.logger.error('Client subscription failed.')\n      this.disconnect()\n\n      /**\n       * TODO: This error is not being catched by us so it's\n       * gonna appear as `UnhandledPromiseRejectionWarning`.\n       * The reason we are re-throwing here is because if\n       * this happens something serious happened and the app\n       * won't work anymore since subscribes aren't working.\n       */\n      throw error\n    }\n  }\n\n  get video(): Video {\n    if (this._consumers.has('video')) {\n      return this._consumers.get('video')!\n    }\n    const video = createVideoObject({\n      store: this.store,\n    })\n    this._consumers.set('video', video)\n    return video\n  }\n}\n", "export { ChatMember, ChatMessage } from '@signalwire/core'\nexport type {\n  ChatAction,\n  ChatChannel,\n  ChatChannelMessageEvent,\n  ChatChannelMessageEventParams,\n  ChatChannelState,\n  ChatEvent,\n  ChatGetMembersParams,\n  ChatGetMemberStateParams,\n  ChatGetMessagesParams,\n  ChatMemberContract,\n  ChatMemberEntity,\n  ChatMemberJoinedEvent,\n  ChatMemberJoinedEventParams,\n  ChatMemberLeftEvent,\n  ChatMemberLeftEventParams,\n  ChatMemberUpdatedEvent,\n  ChatMemberUpdatedEventParams,\n  ChatMessageContract,\n  ChatMessageEntity,\n  ChatSetMemberStateParams,\n  InternalChatMemberEntity,\n  InternalChatMessageEntity,\n  InternalPubSubMessageEntity,\n  MapToPubSubShape,\n  MessagingAction,\n  PaginationCursor,\n  PubSubAction,\n  PubSubChannel,\n  PubSubChannelMessageEvent,\n  PubSubChannelMessageEventParams,\n  PubSubEvent,\n  PubSubEventAction,\n  PubSubPublishParams,\n} from '@signalwire/core'\nexport { ChatClientApiEvents, Client } from './ChatClient'\nexport type { ChatClientOptions } from './ChatClient'\n", "import {\n  ChatContract,\n  ConsumerContract,\n  UserOptions,\n  Chat as ChatNamespace,\n} from '@signalwire/core'\nimport { clientConnect, setupClient, RealtimeClient } from '../client/index'\nimport type { RealTimeChatApiEventsHandlerMapping } from '../types/chat'\n\nexport interface ChatClientApiEvents\n  extends ChatNamespace.BaseChatApiEvents<RealTimeChatApiEventsHandlerMapping> {}\n\nexport interface ClientFullState extends ChatClient {}\ninterface ChatClient\n  extends Omit<ChatContract, 'getAllowedChannels' | 'updateToken'>,\n    Omit<ConsumerContract<ChatClientApiEvents, ClientFullState>, 'subscribe'> {\n  new (opts: ChatClientOptions): this\n\n  /** @internal */\n  _session: RealtimeClient\n}\nexport interface ChatClientOptions\n  extends Omit<UserOptions, 'host' | '_onRefreshToken' | 'token'> {\n  token?: string\n}\n\ntype ClientMethods = Exclude<keyof ChatClient, '_session'>\nconst INTERCEPTED_METHODS: ClientMethods[] = [\n  'subscribe',\n  'publish',\n  'getMessages',\n  'getMembers',\n  'getMemberState',\n  'setMemberState',\n]\nconst UNSUPPORTED_METHODS = ['getAllowedChannels', 'updateToken']\n\n/**\n * You can use instances of this class to control the chat and subscribe to its\n * events. Please see {@link ChatClientApiEvents} for the full list of events\n * you can subscribe to.\n *\n * @param options - {@link ChatClientOptions}\n *\n * @returns - {@link ChatClient}\n *\n * @example\n *\n * ```javascript\n * const chatClient = new Chat.Client({\n *   project: '<project-id>',\n *   token: '<api-token>'\n * })\n *\n * await chatClient.subscribe([ 'mychannel1', 'mychannel2' ])\n *\n * chatClient.on('message', (message) => {\n *   console.log(\"Received\", message.content,\n *               \"on\", message.channel,\n *               \"at\", message.publishedAt)\n * })\n *\n * await chatClient.publish({\n *   channel: 'mychannel1',\n *   content: 'hello world'\n * })\n * ```\n */\nconst ChatClient = function (options?: ChatClientOptions) {\n  const { client, store } = setupClient(options)\n  const chat = ChatNamespace.createBaseChatObject<ChatClient>({\n    store,\n  })\n\n  const createInterceptor = <K extends ClientMethods>(prop: K) => {\n    return async (...params: Parameters<ChatClient[K]>) => {\n      await clientConnect(client)\n\n      // @ts-expect-error\n      return chat[prop](...params)\n    }\n  }\n\n  const interceptors = {\n    _session: client,\n    disconnect: () => client.disconnect(),\n  } as const\n\n  return new Proxy<ChatClient>(chat, {\n    get(target: ChatClient, prop: keyof ChatClient, receiver: any) {\n      if (prop in interceptors) {\n        // @ts-expect-error\n        return interceptors[prop]\n      }\n\n      // FIXME: types and _session check\n      if (prop !== '_session' && INTERCEPTED_METHODS.includes(prop)) {\n        return createInterceptor(prop)\n      } else if (UNSUPPORTED_METHODS.includes(prop)) {\n        return undefined\n      }\n\n      // Always connect the underlying client if the user call a function on the Proxy\n      if (typeof target[prop] === 'function') {\n        clientConnect(client)\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n  // For consistency with other constructors we'll make TS force the use of `new`\n} as unknown as { new (options?: ChatClientOptions): ChatClient }\n\nexport { ChatClient as Client }\n", "export { PubSubMessage } from '@signalwire/core'\nexport { Client } from './PubSubClient'\nexport type { PubSubMessageContract } from '@signalwire/core'\nexport type { PubSubClientApiEvents } from './PubSubClient'\n", "import {\n  ConsumerContract,\n  UserOptions,\n  PubSub as PubSubNamespace,\n  PubSubContract,\n} from '@signalwire/core'\nimport { clientConnect, setupClient, RealtimeClient } from '../client/index'\nimport type { RealTimePubSubApiEventsHandlerMapping } from '../types/pubSub'\n\nexport interface PubSubClientApiEvents\n  extends PubSubNamespace.BasePubSubApiEvents<RealTimePubSubApiEventsHandlerMapping> {}\n\nexport interface ClientFullState extends PubSubClient {}\ninterface PubSubClient\n  extends Omit<PubSubContract, 'getAllowedChannels' | 'updateToken'>,\n    Omit<\n      ConsumerContract<PubSubClientApiEvents, ClientFullState>,\n      'subscribe'\n    > {\n  new (opts: PubSubClientOptions): this\n\n  /** @internal */\n  _session: RealtimeClient\n}\n\ninterface PubSubClientOptions\n  extends Omit<UserOptions, 'host' | '_onRefreshToken' | 'token'> {\n  token?: string\n}\n\ntype ClientMethods = Exclude<keyof PubSubClient, '_session'>\nconst INTERCEPTED_METHODS: ClientMethods[] = ['subscribe', 'publish']\nconst UNSUPPORTED_METHODS = ['getAllowedChannels', 'updateToken']\n\n/**\n * Creates a new PubSub client.\n *\n * @param options - {@link PubSubClientOptions}\n *\n * @example\n *\n * ```js\n * import { PubSub } from '@signalwire/realtime-api'\n *\n * const pubSubClient = new PubSub.Client({\n *   project: '<project-id>',\n *   token: '<api-token>'\n * })\n * ```\n */\nconst PubSubClient = function (options?: PubSubClientOptions) {\n  const { client, store } = setupClient(options)\n  const pubSub = PubSubNamespace.createBasePubSubObject<PubSubClient>({\n    store,\n  })\n\n  const createInterceptor = <K extends ClientMethods>(prop: K) => {\n    return async (...params: Parameters<PubSubClient[K]>) => {\n      await clientConnect(client)\n\n      // @ts-expect-error\n      return pubSub[prop](...params)\n    }\n  }\n\n  const interceptors = {\n    _session: client,\n    disconnect: () => client.disconnect(),\n  } as const\n\n  return new Proxy<PubSubClient>(pubSub, {\n    get(target: PubSubClient, prop: keyof PubSubClient, receiver: any) {\n      if (prop in interceptors) {\n        // @ts-expect-error\n        return interceptors[prop]\n      }\n\n      // FIXME: types and _session check\n      if (prop !== '_session' && INTERCEPTED_METHODS.includes(prop)) {\n        return createInterceptor(prop)\n      } else if (UNSUPPORTED_METHODS.includes(prop)) {\n        return undefined\n      }\n\n      // Always connect the underlying client if the user call a function on the Proxy\n      if (typeof target[prop] === 'function') {\n        clientConnect(client)\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n  // For consistency with other constructors we'll make TS force the use of `new`\n} as unknown as { new (options?: PubSubClientOptions): PubSubClient }\n\nexport { PubSubClient as Client }\n", "import {\n  DisconnectableClientContract,\n  BaseComponentOptions,\n  BaseComponent,\n  ClientContextContract,\n} from '@signalwire/core'\nimport { connect } from '@signalwire/core'\nimport type { TaskClientApiEvents } from '../types'\nimport { RealtimeClient } from '../client/index'\nimport { taskWorker } from './workers'\n\nexport interface Task\n  extends DisconnectableClientContract<Task, TaskClientApiEvents>,\n    ClientContextContract {\n  /** @internal */\n  _session: RealtimeClient\n  /**\n   * Disconnects this client. The client will stop receiving events and you will\n   * need to create a new instance if you want to use it again.\n   *\n   * @example\n   *\n   * ```js\n   * client.disconnect()\n   * ```\n   */\n  disconnect(): void\n}\n\n/** @internal */\nclass TaskAPI extends BaseComponent<TaskClientApiEvents> {\n  constructor(options: BaseComponentOptions) {\n    super(options)\n\n    this.runWorker('taskWorker', {\n      worker: taskWorker,\n    })\n  }\n}\n\n/** @internal */\nexport const createTaskObject = (params: BaseComponentOptions): Task => {\n  const task = connect<TaskClientApiEvents, TaskAPI, Task>({\n    store: params.store,\n    Component: TaskAPI,\n  })(params)\n\n  return task\n}\n\nexport * from './TaskClient'\nexport * from './send'\nexport type { TaskReceivedEventName } from '@signalwire/core'\nexport type {\n  TaskClientApiEvents,\n  RealTimeTaskApiEventsHandlerMapping,\n} from '../types'\n", "import {\n  getLogger,\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  SDKActions,\n} from '@signalwire/core'\nimport type { Task } from './Task'\n\nexport const taskWorker: SDKWorker<Task> = function* (options): SagaIterator {\n  getLogger().trace('taskWorker started')\n  const { channels, instance } = options\n  const { swEventChannel } = channels\n\n  while (true) {\n    const action = yield sagaEffects.take(\n      swEventChannel,\n      (action: SDKActions) => {\n        return action.type === 'queuing.relay.tasks'\n      }\n    )\n\n    instance.emit('task.received', action.payload.message)\n  }\n\n  getLogger().trace('taskWorker ended')\n}\n", "import { RealtimeClient, clientConnect } from '../client/index'\nimport type { ExecuteParams } from '@signalwire/core'\n\nexport const clientContextInterceptorsFactory = (client: RealtimeClient) => {\n  return {\n    async addContexts(contexts: string[]) {\n      await clientConnect(client)\n      const executeParams: ExecuteParams = {\n        method: 'signalwire.receive',\n        params: {\n          contexts,\n        },\n      }\n\n      // @ts-expect-error\n      return client.execute(executeParams)\n    },\n    async removeContexts(contexts: string[]) {\n      await clientConnect(client)\n      const executeParams: ExecuteParams = {\n        method: 'signalwire.unreceive',\n        params: {\n          contexts,\n        },\n      }\n\n      // @ts-expect-error\n      return client.execute(executeParams)\n    },\n  }\n}\n", "import type { UserOptions } from '@signalwire/core'\nimport { setupClient, clientConnect } from '../client/index'\nimport type { Task } from './Task'\nimport { createTaskObject } from './Task'\nimport { clientContextInterceptorsFactory } from '../common/clientContext'\n\ninterface TaskClient extends Task {\n  new (opts: TaskClientOptions): this\n}\n\nexport interface TaskClientOptions\n  extends Omit<UserOptions, '_onRefreshToken'> {\n  contexts: string[]\n}\n\n/**\n * Creates a new Task client.\n *\n * @param options - {@link TaskClientOptions}\n *\n * @example\n *\n * ```js\n * import { Task } from '@signalwire/realtime-api'\n *\n * const taskClient = new Task.Client({\n *   project: '<project-id>',\n *   token: '<api-token>',\n *   contexts: ['<context-name>'],\n * })\n * ```\n */\nconst TaskClient = function (options?: TaskClientOptions) {\n  const { client, store } = setupClient(options)\n\n  const task = createTaskObject({\n    store,\n  })\n\n  const disconnect = () => client.disconnect()\n\n  const interceptors = {\n    ...clientContextInterceptorsFactory(client),\n    _session: client,\n    disconnect,\n  } as const\n\n  return new Proxy<Omit<TaskClient, 'new'>>(task, {\n    get(target: TaskClient, prop: keyof TaskClient, receiver: any) {\n      if (prop in interceptors) {\n        // @ts-expect-error\n        return interceptors[prop]\n      }\n\n      // Always connect the underlying client if the user call a function on the Proxy\n      if (typeof target[prop] === 'function') {\n        clientConnect(client)\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n  // For consistency with other constructors we'll make TS force the use of `new`\n} as unknown as { new (options?: TaskClientOptions): TaskClient }\n\nexport { TaskClient as Client }\n", "import { request } from 'node:https'\n\nconst PATH = '/api/relay/rest/tasks'\nconst HOST = 'relay.signalwire.com'\n\n/** Parameters for {@link send} */\nexport interface TaskSendParams {\n  /** @ignore */\n  host?: string\n  /** SignalWire project id, e.g. `a10d8a9f-2166-4e82-56ff-118bc3a4840f` */\n  project: string\n  /** SignalWire project token, e.g. `PT9e5660c101cd140a1c93a0197640a369cf5f16975a0079c9` */\n  token: string\n  /** Context to send the task to */\n  context: string\n  /** Message to send */\n  message: Record<string, unknown>\n}\n\n/**\n * Send a job to your Task Client in a specific context.\n *\n * @param params\n * @returns\n *\n * @example\n *\n * > Send a task with a message to then make an outbound Call.\n *\n * ```js\n * const message = {\n *   'action': 'call',\n *   'from': '+18881112222'\n *   'to': '+18881113333'\n * }\n *\n * await Task.send({\n *   project: \"<project-id>\",\n *   token: \"<api-token>\",\n *   context: 'office',\n *   message: message,\n * })\n * ```\n *\n */\nexport const send = ({\n  host = HOST,\n  project,\n  token,\n  context,\n  message,\n}: TaskSendParams) => {\n  if (!project || !token) {\n    throw new Error('Invalid options: project and token are required!')\n  }\n\n  return new Promise<void>((resolve, reject) => {\n    try {\n      const Authorization = `Basic ${Buffer.from(\n        `${project}:${token}`\n      ).toString('base64')}`\n\n      const data = JSON.stringify({ context, message })\n      const options = {\n        host,\n        port: 443,\n        method: 'POST',\n        path: PATH,\n        headers: {\n          Authorization,\n          'Content-Type': 'application/json',\n          'Content-Length': data.length,\n        },\n      }\n      const req = request(options, ({ statusCode }) => {\n        statusCode === 204 ? resolve() : reject()\n      })\n\n      req.on('error', reject)\n\n      req.write(data)\n      req.end()\n    } catch (error) {\n      reject(error)\n    }\n  })\n}\n", "import {\n  DisconnectableClientContract,\n  BaseComponentOptions,\n  toExternalJSON,\n  ClientContextContract,\n  BaseConsumer,\n} from '@signalwire/core'\nimport { connect } from '@signalwire/core'\nimport type { MessagingClientApiEvents } from '../types'\nimport { RealtimeClient } from '../client/index'\nimport { messagingWorker } from './workers'\n\ninterface MessagingSendParams {\n  context?: string\n  from: string\n  to: string\n  body?: string\n  tags?: string[]\n  region?: string\n  media?: string[]\n}\n\ninterface InternalMessagingSendParams\n  extends Omit<MessagingSendParams, 'from' | 'to'> {\n  from_number: string\n  to_number: string\n}\n\nexport interface MessagingSendResult {\n  message: string\n  code: string\n  messageId: string\n}\n\ninterface MessagingSendError {\n  message: string\n  code: string\n  errors: Record<any, any>\n}\n\n/** @internal */\nexport interface Messaging\n  extends DisconnectableClientContract<Messaging, MessagingClientApiEvents>,\n    ClientContextContract {\n  /** @internal */\n  _session: RealtimeClient\n  /**\n   * Disconnects this client. The client will stop receiving events and you will\n   * need to create a new instance if you want to use it again.\n   *\n   * @example\n   *\n   * ```js\n   * client.disconnect()\n   * ```\n   */\n  disconnect(): void\n\n  /**\n   * Send an outbound SMS or MMS message.\n   *\n   * @param params - {@link MessagingSendParams}\n   *\n   * @returns - {@link MessagingSendResult}\n   *\n   * @example\n   *\n   * > Send a message.\n   *\n   * ```js\n   * try {\n   *   const sendResult = await client.send({\n   *     from: '+1xxx',\n   *     to: '+1yyy',\n   *     body: 'Hello World!'\n   *   })\n   *   console.log('Message ID: ', sendResult.messageId)\n   * } catch (e) {\n   *   console.error(e.message)\n   * }\n   * ```\n   */\n  send(params: MessagingSendParams): Promise<MessagingSendResult>\n}\n\n/** @internal */\nclass MessagingAPI extends BaseConsumer<MessagingClientApiEvents> {\n  /** @internal */\n\n  constructor(options: BaseComponentOptions) {\n    super(options)\n\n    this.runWorker('messagingWorker', {\n      worker: messagingWorker,\n    })\n  }\n\n  async send(params: MessagingSendParams): Promise<any> {\n    const { from = '', to = '', ...rest } = params\n    const sendParams: InternalMessagingSendParams = {\n      ...rest,\n      from_number: from,\n      to_number: to,\n    }\n\n    try {\n      const response: any = await this.execute({\n        method: 'messaging.send',\n        params: sendParams,\n      })\n\n      return toExternalJSON<MessagingSendResult>(response)\n    } catch (error) {\n      this.logger.error('Error sending message', error)\n      throw error as MessagingSendError\n    }\n  }\n}\n\n/** @internal */\nexport const createMessagingObject = (\n  params: BaseComponentOptions\n): Messaging => {\n  const messaging = connect<MessagingClientApiEvents, MessagingAPI, Messaging>({\n    store: params.store,\n    Component: MessagingAPI,\n  })(params)\n\n  return messaging\n}\n\nexport * from './MessagingClient'\nexport * from './Message'\nexport type { MessagingMessageState } from '@signalwire/core'\n", "import {\n  MessagingAction,\n  SDKActions,\n  SDKWorker,\n  SagaIterator,\n  getLogger,\n  sagaEffects,\n} from '@signalwire/core'\nimport { Message, Messaging } from '../Messaging'\n\nexport const messagingWorker: SDKWorker<Messaging> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('messagingWorker started')\n  const {\n    instance: client,\n    channels: { swEventChannel },\n  } = options\n\n  function* worker(action: MessagingAction) {\n    const { payload, type } = action\n\n    // @ts-expect-error\n    const message = new Message(payload)\n\n    switch (type) {\n      case 'messaging.receive':\n        client.emit('message.received', message)\n        break\n      case 'messaging.state':\n        client.emit('message.updated', message)\n        break\n      default:\n        getLogger().warn(`Unknown message event: \"${action.type}\"`)\n        break\n    }\n  }\n\n  const isMessagingEvent = (action: SDKActions) =>\n    action.type.startsWith('messaging.')\n\n  while (true) {\n    const action: MessagingAction = yield sagaEffects.take(\n      swEventChannel,\n      isMessagingEvent\n    )\n\n    yield sagaEffects.fork(worker, action)\n  }\n\n  getLogger().trace('messagingWorker ended')\n}\n", "import type { UserOptions } from '@signalwire/core'\nimport { setupClient, clientConnect } from '../client/index'\nimport type { Messaging } from './Messaging'\nimport { createMessagingObject } from './Messaging'\nimport { clientContextInterceptorsFactory } from '../common/clientContext'\nexport type {\n  MessagingClientApiEvents,\n  RealTimeMessagingApiEventsHandlerMapping,\n} from '../types'\nexport type {\n  MessageReceivedEventName,\n  MessageUpdatedEventName,\n} from '@signalwire/core'\n\ninterface MessagingClient extends Messaging {\n  new (opts: MessagingClientOptions): this\n}\n\nexport interface MessagingClientOptions\n  extends Omit<UserOptions, '_onRefreshToken'> {}\n\n/**\n * You can use instances of this class to send or receive messages. Please see\n * {@link MessagingClientApiEvents} for the full list of events you can subscribe\n * to.\n *\n * @param params - {@link MessagingClientOptions}\n *\n * @example\n *\n * ```javascript\n * const client = new Messaging.Client({\n *   project: \"<project-id>\",\n *   token: \"<api-token>\",\n *   contexts: ['office']\n * })\n *\n * client.on('message.received', (message) => {\n *   console.log('message.received', message)\n * })\n *\n * await client.send({\n *   context: 'office',\n *   from: '+1xxx',\n *   to: '+1yyy',\n *   body: 'Hello World!'\n * })\n * ```\n */\nconst MessagingClient = function (options?: MessagingClientOptions) {\n  const { client, store } = setupClient(options)\n\n  const messaging = createMessagingObject({\n    store,\n  })\n\n  const send: Messaging['send'] = async (...args) => {\n    await clientConnect(client)\n\n    return messaging.send(...args)\n  }\n  const disconnect = () => client.disconnect()\n\n  const interceptors = {\n    ...clientContextInterceptorsFactory(client),\n    send,\n    _session: client,\n    disconnect,\n  } as const\n\n  return new Proxy<Omit<MessagingClient, 'new'>>(messaging, {\n    get(target: MessagingClient, prop: keyof MessagingClient, receiver: any) {\n      if (prop in interceptors) {\n        // @ts-expect-error\n        return interceptors[prop]\n      }\n\n      // Always connect the underlying client if the user call a function on the Proxy\n      if (typeof target[prop] === 'function') {\n        clientConnect(client)\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n  // For consistency with other constructors we'll make TS force the use of `new`\n} as unknown as { new (options?: MessagingClientOptions): MessagingClient }\n\nexport { MessagingClient as Client }\n", "import { MessagingMessageState } from '@signalwire/core'\n\n/**\n * An object representing an SMS or MMS message.\n */\nexport interface MessageContract {\n  /** The unique identifier of the message. */\n  id: string\n  /** The current state of the message. */\n  state: MessagingMessageState\n  /** The context of the message. */\n  context: string\n  /** The phone number the message comes from. */\n  from: string\n  /** The destination number of the message. */\n  to: string\n  /** The direction of the message: `inbound` or `outbound`. */\n  direction: string\n  /** Array of strings with message tags. */\n  tags: string[]\n  /** Body of the message */\n  body: string\n  /** Array of URLs media. */\n  media: string[]\n  /** Number of segments of the message. */\n  segments: number\n  /** Reason why the message was not sent. This is present only in case of failure. */\n  reason?: string\n}\n\ninterface MessageOptions {\n  message_id: string\n  message_state: MessagingMessageState\n  context: string\n  from_number: string\n  to_number: string\n  direction: 'inbound' | 'outbound'\n  tags: string[]\n  body: string\n  media: string[]\n  segments: number\n  reason?: string\n}\n\n/** @internal */\nexport class Message implements MessageContract {\n  public id: string\n  public state: MessagingMessageState\n  public context: string\n  public from: string\n  public to: string\n  public body: string\n  public direction: 'inbound' | 'outbound'\n  public media: string[]\n  public segments: number\n  public tags: string[]\n  public reason?: string\n\n  constructor(options: MessageOptions) {\n    this.id = options.message_id\n    this.state = options.message_state\n    this.context = options.context\n    this.from = options.from_number\n    this.to = options.to_number\n    this.body = options.body\n    this.direction = options.direction\n    this.media = options.media || []\n    this.segments = options.segments\n    this.tags = options.tags || []\n    this.reason = options.reason\n  }\n}\n", "import {\n  connect,\n  BaseComponentOptions,\n  toExternalJSON,\n  ClientContextContract,\n  uuid,\n  BaseConsumer,\n} from '@signalwire/core'\nimport type {\n  DisconnectableClientContract,\n  VoiceDeviceBuilder,\n  VoiceCallDialPhoneMethodParams,\n  VoiceCallDialSipMethodParams,\n  ToExternalJSONResult,\n  CallingCallDialFailedEventParams,\n  VoiceDialerParams,\n} from '@signalwire/core'\nimport { RealtimeClient } from '../client/index'\nimport { Call } from './Call'\nimport { voiceCallingWroker } from './workers'\nimport { DeviceBuilder } from './DeviceBuilder'\nimport type { RealTimeCallApiEvents } from '../types'\nimport { toInternalDevices } from './utils'\n\nexport * from './VoiceClient'\nexport { Call } from './Call'\nexport type { RealTimeCallApiEvents }\nexport { DeviceBuilder }\nexport { Playlist } from './Playlist'\nexport type { CallPlayback } from './CallPlayback'\nexport type { CallPrompt } from './CallPrompt'\nexport type { CallRecording } from './CallRecording'\nexport type { CallTap } from './CallTap'\nexport type {\n  CallingCallDirection,\n  CallingCallState,\n  CallingCallWaitForState,\n  ClientEvents,\n  CollectDigitsConfig,\n  CollectSpeechConfig,\n  CreateVoicePlaylistParams,\n  NestedArray,\n  RingtoneName,\n  SipCodec,\n  SipHeader,\n  SpeechOrDigits,\n  TapDevice,\n  TapDeviceRTP,\n  TapDeviceWS,\n  TapDirection,\n  VoiceCallConnectMethodParams,\n  VoiceCallConnectPhoneMethodParams,\n  VoiceCallConnectSipMethodParams,\n  VoiceCallContract,\n  VoiceCallDetectContract,\n  VoiceCallDetectDigitParams,\n  VoiceCallDetectFaxParams,\n  VoiceCallDetectMachineParams,\n  VoiceCallDetectMethodParams,\n  VoiceCallCollectContract,\n  VoiceCallCollectMethodParams,\n  VoiceCallDeviceParams,\n  VoiceCallDialPhoneMethodParams,\n  VoiceCallDialRegionParams,\n  VoiceCallDialSipMethodParams,\n  VoiceCallDisconnectReason,\n  VoiceCallPhoneParams,\n  VoiceCallPlayAudioMethodParams,\n  VoiceCallPlayAudioParams,\n  VoiceCallPlaybackContract,\n  VoiceCallPlayParams,\n  VoiceCallPlayRingtoneMethodParams,\n  VoiceCallPlayRingtoneParams,\n  VoiceCallPlaySilenceMethodParams,\n  VoiceCallPlaySilenceParams,\n  VoiceCallPlayTTSMethodParams,\n  VoiceCallPlayTTSParams,\n  VoiceCallPromptAudioMethodParams,\n  VoiceCallPromptContract,\n  VoiceCallPromptMethodParams,\n  VoiceCallPromptRingtoneMethodParams,\n  VoiceCallPromptTTSMethodParams,\n  VoiceCallRecordingContract,\n  VoiceCallRecordMethodParams,\n  VoiceCallSipParams,\n  VoiceCallTapAudioMethodParams,\n  VoiceCallTapContract,\n  VoiceCallTapMethodParams,\n  VoiceDeviceBuilder,\n  VoiceDialerParams,\n  VoicePlaylist,\n} from '@signalwire/core'\n\n/**\n * List of events for {@link Voice.Call}.\n */\nexport interface VoiceClientApiEvents extends RealTimeCallApiEvents {}\n\nexport interface Voice\n  extends DisconnectableClientContract<Voice, VoiceClientApiEvents>,\n    ClientContextContract {\n  /** @internal */\n  _session: RealtimeClient\n\n  /**\n   * Disconnects this client. The client will stop receiving events and you will\n   * need to create a new instance if you want to use it again.\n   *\n   * @example\n   *\n   * ```js\n   * client.disconnect()\n   * ```\n   */\n  disconnect(): void\n\n  /**\n   * Makes an outbound Call and waits until it has been answered or hung up.\n   * This is an advanced method that lets you call multiple devices in parallel\n   * or series: for simpler use cases, see {@link dialPhone} and\n   * {@link dialSip}.\n   *\n   * With this method you can specify a configuration of devices to call in\n   * series and/or in parallel: as soon as one device answers the call, the\n   * returned promise is resolved. You specify a configuration through a\n   * {@link VoiceDeviceBuilder} object.\n   *\n   * @param dialer - {@link VoiceDeviceBuilder}\n   *\n   * @example Calls a phone number. If the number doesn't answer within 30\n   * seconds, calls two different SIP endpoints in parallel.\n   *\n   * ```js\n   * const devices = new Voice.DeviceBuilder()\n   *   .add(Voice.DeviceBuilder.Phone({ from: '+XXXXXX', to: '+YYYYYY', timeout: 30 }))\n   *   .add([\n   *     Voice.DeviceBuilder.Sip({ from: 'sip:aaa@bbb.cc', to: 'sip:xxx@yyy.zz' }),\n   *     Voice.DeviceBuilder.Sip({ from: 'sip:aaa@bbb.cc', to: 'sip:ppp@qqq.rr' })\n   *   ])\n   *\n   * try {\n   *   const call = await client.dial(devices)\n   *   console.log(\"Call answered\")\n   * } catch (e) {\n   *   console.log(\"Call not answered\")\n   * }\n   * ```\n   *\n   * @param dialer The Dialer specifying the devices to call.\n   *\n   * @returns A call object.\n   */\n  dial(dialer: VoiceDeviceBuilder): Promise<Call>\n  /**\n   * Makes an outbound call to a PSTN number.\n   *\n   * @param params - {@link VoiceCallDialPhoneMethodParams}\n   *\n   * @example\n   *\n   * ```js\n   * try {\n   *   const call = await client.dialPhone({\n   *     from: '+YYYYYYYYYY',\n   *     to: '+XXXXXXXXXX',\n   *     timeout: 30,\n   *   })\n   * } catch (e) {\n   *   console.log(\"Call not answered.\")\n   * }\n   * ```\n   *\n   * @returns A call object.\n   */\n  dialPhone(params: VoiceCallDialPhoneMethodParams): Promise<Call>\n  /**\n   * Makes an outbound call to a SIP endpoint.\n   *\n   * @param params - {@link VoiceCallDialSipMethodParams}\n   *\n   * @example\n   *\n   * ```js\n   * try {\n   *   const call = await client.dialPhone({\n   *     from: 'sip:xxx@yyy.zz',\n   *     to: 'sip:ppp@qqq.rr',\n   *     timeout: 30,\n   *   })\n   * } catch (e) {\n   *   console.log(\"Call not answered.\")\n   * }\n   * ```\n   *\n   * @returns A call object.\n   */\n  dialSip(params: VoiceCallDialSipMethodParams): Promise<Call>\n}\n\n/** @internal */\nclass VoiceAPI extends BaseConsumer<VoiceClientApiEvents> {\n  private _tag: string\n\n  constructor(options: BaseComponentOptions) {\n    super(options)\n\n    this._tag = uuid()\n\n    this.runWorker('voiceCallingWorker', {\n      worker: voiceCallingWroker,\n      initialState: {\n        tag: this._tag,\n      },\n    })\n  }\n\n  dial(params: VoiceDialerParams) {\n    return new Promise((resolve, reject) => {\n      const resolveHandler = (call: Call) => {\n        // @ts-expect-error\n        this.off('dial.failed', rejectHandler)\n        resolve(call)\n      }\n\n      const rejectHandler = (\n        error: ToExternalJSONResult<CallingCallDialFailedEventParams>\n      ) => {\n        // @ts-expect-error\n        this.off('dial.answered', resolveHandler)\n        reject(toExternalJSON(error))\n      }\n\n      // @ts-expect-error\n      this.once('dial.answered', resolveHandler)\n      // @ts-expect-error\n      this.once('dial.failed', rejectHandler)\n\n      let executeParams: Record<string, any>\n      if (params instanceof DeviceBuilder) {\n        const { devices } = params\n        executeParams = {\n          tag: this._tag,\n          devices: toInternalDevices(devices),\n        }\n      } else if ('region' in params) {\n        const { region, nodeId, devices: deviceBuilder } = params\n        executeParams = {\n          tag: this._tag,\n          region,\n          node_id: nodeId,\n          devices: toInternalDevices(deviceBuilder.devices),\n        }\n      } else {\n        throw new Error('[dial] Invalid input')\n      }\n\n      this.execute({\n        method: 'calling.dial',\n        params: executeParams,\n      }).catch((e) => {\n        reject(e)\n      })\n    })\n  }\n\n  dialPhone({\n    region,\n    maxPricePerMinute,\n    nodeId,\n    ...params\n  }: VoiceCallDialPhoneMethodParams) {\n    const devices = new DeviceBuilder().add(DeviceBuilder.Phone(params))\n    // dial is available through the VoiceClient Proxy\n    return this.dial({\n      maxPricePerMinute,\n      region,\n      nodeId,\n      devices,\n    })\n  }\n\n  dialSip({\n    region,\n    maxPricePerMinute,\n    nodeId,\n    ...params\n  }: VoiceCallDialSipMethodParams) {\n    const devices = new DeviceBuilder().add(DeviceBuilder.Sip(params))\n    // dial is available through the VoiceClient Proxy\n    return this.dial({\n      maxPricePerMinute,\n      region,\n      nodeId,\n      devices,\n    })\n  }\n}\n\n/** @internal */\nexport const createVoiceObject = (params: BaseComponentOptions): Voice => {\n  const voice = connect<VoiceClientApiEvents, VoiceAPI, Voice>({\n    store: params.store,\n    Component: VoiceAPI,\n  })(params)\n\n  return voice\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  CallingCallStateEventParams,\n} from '@signalwire/core'\nimport { Call, createCallObject } from '../Call'\nimport type { VoiceCallWorkerParams } from './voiceCallingWorker'\n\nexport const voiceCallStateWorker = function* (\n  options: VoiceCallWorkerParams<CallingCallStateEventParams>\n): SagaIterator {\n  getLogger().trace('voiceCallStateWorker started')\n  const {\n    instance: client,\n    payload,\n    instanceMap: { get, set, remove },\n  } = options\n\n  let callInstance = get<Call>(payload.call_id)\n  if (!callInstance) {\n    callInstance = createCallObject({\n      store: client.store,\n      payload,\n    })\n  } else {\n    callInstance.setPayload(payload)\n  }\n  set<Call>(payload.call_id, callInstance)\n\n  switch (payload.call_state) {\n    case 'ended': {\n      callInstance.emit('call.state', callInstance)\n\n      // Resolves the promise when user disconnects using a peer call instance\n      // @ts-expect-error\n      callInstance.emit('connect.disconnected', callInstance)\n      remove<Call>(payload.call_id)\n      break\n    }\n    default:\n      callInstance.emit('call.state', callInstance)\n      break\n  }\n\n  getLogger().trace('voiceCallStateWorker ended')\n}\n", "import {\n  uuid,\n  BaseComponentOptionsWithPayload,\n  connect,\n  EmitterContract,\n  extendComponent,\n  VoiceCallMethods,\n  VoiceCallContract,\n  VoiceCallDisconnectReason,\n  VoicePlaylist,\n  VoiceCallPlayAudioMethodParams,\n  VoiceCallPlaySilenceMethodParams,\n  VoiceCallPlayRingtoneMethodParams,\n  VoiceCallPlayTTSMethodParams,\n  VoiceCallRecordMethodParams,\n  VoiceCallPromptMethodParams,\n  VoiceCallPromptAudioMethodParams,\n  VoiceCallPromptRingtoneMethodParams,\n  VoiceCallPromptTTSMethodParams,\n  VoiceCallCollectMethodParams,\n  toExternalJSON,\n  toSnakeCaseKeys,\n  VoiceCallTapMethodParams,\n  VoiceCallTapAudioMethodParams,\n  CallingCallState,\n  VoiceCallConnectMethodParams,\n  VoiceCallConnectPhoneMethodParams,\n  VoiceCallConnectSipMethodParams,\n  CallingCallConnectEventParams,\n  VoiceCallDetectMethodParams,\n  VoiceCallDetectMachineParams,\n  VoiceCallDetectFaxParams,\n  VoiceCallDetectDigitParams,\n  CallingCallWaitForState,\n  CallingCall,\n  configureStore,\n  BaseConsumer,\n} from '@signalwire/core'\nimport { RealTimeCallApiEvents } from '../types'\nimport { toInternalDevices, toInternalPlayParams } from './utils'\nimport { Playlist } from './Playlist'\nimport { CallPlayback } from './CallPlayback'\nimport { CallRecording } from './CallRecording'\nimport { CallPrompt, createCallPromptObject } from './CallPrompt'\nimport { CallTap } from './CallTap'\nimport { CallDetect, createCallDetectObject } from './CallDetect'\nimport { CallCollect, createCallCollectObject } from './CallCollect'\nimport { DeviceBuilder } from './DeviceBuilder'\n\nexport type EmitterTransformsEvents =\n  | 'calling.playback.start'\n  | 'calling.playback.started'\n  | 'calling.playback.updated'\n  | 'calling.playback.ended'\n  | 'calling.playback.failed'\n  | 'calling.recording.started'\n  | 'calling.recording.updated'\n  | 'calling.recording.ended'\n  | 'calling.recording.failed'\n  | 'calling.prompt.started'\n  | 'calling.prompt.updated'\n  | 'calling.prompt.ended'\n  | 'calling.prompt.failed'\n  | 'calling.tap.started'\n  | 'calling.tap.ended'\n  | 'calling.detect.started'\n  | 'calling.detect.ended'\n  | 'calling.collect.started'\n  | 'calling.collect.updated'\n  | 'calling.collect.ended'\n  | 'calling.collect.failed'\n  | 'calling.call.state'\n  // events not exposed\n  | 'calling.detect.updated'\n  | 'calling.connect.connected'\n\nexport interface CallOptions\n  extends BaseComponentOptionsWithPayload<CallingCall> {\n  connectPayload?: CallingCallConnectEventParams\n}\n\n/**\n * A Call object represents an active call. You can get instances of a Call\n * object from a {@link Voice.Client}, by answering or initiating calls.\n */\nexport interface Call\n  extends VoiceCallContract<Call>,\n    EmitterContract<RealTimeCallApiEvents> {\n  store: ReturnType<typeof configureStore>\n  setPayload: (payload: CallingCall) => void\n  setConnectPayload: (payload: CallingCallConnectEventParams) => void\n}\n\nexport class CallConsumer extends BaseConsumer<RealTimeCallApiEvents> {\n  private _peer: Call | undefined\n  private _payload: CallingCall\n  private _connectPayload: CallingCallConnectEventParams\n\n  constructor(options: CallOptions) {\n    super(options)\n\n    this._payload = options.payload\n\n    this.on('call.state', () => {\n      /**\n       * FIXME: this no-op listener is required for our EE transforms to\n       * update the call object via the `calling.call.state` transform\n       * and apply the \"peer\" property to the Proxy.\n       */\n    })\n\n    /**\n     * It will take care of keeping instances of this class\n     * up-to-date with the latest changes sent from the\n     * server. Changes will be available to the consumer via\n     * our Proxy API.\n     */\n  }\n\n  /** Unique id for this voice call */\n  get id() {\n    return this._payload?.call_id\n  }\n\n  get callId() {\n    return this._payload?.call_id\n  }\n\n  get state() {\n    return this._payload?.call_state\n  }\n\n  get callState() {\n    return this._payload?.call_state\n  }\n\n  get tag() {\n    return this.__uuid\n  }\n\n  get nodeId() {\n    return this._payload.node_id\n  }\n\n  get device() {\n    return this._payload.device\n  }\n\n  /** The type of call. Only phone and sip are currently supported. */\n  get type() {\n    return this.device?.type ?? ''\n  }\n\n  /** The phone number that the call is coming from. */\n  get from() {\n    if (this.type === 'phone') {\n      return (\n        // @ts-expect-error\n        (this.device?.params?.from_number || this.device?.params?.fromNumber) ??\n        ''\n      )\n    }\n    return (\n      // @ts-expect-error\n      this.device?.params?.from ?? ''\n    )\n  }\n\n  /** The phone number you are attempting to call. */\n  get to() {\n    if (this.type === 'phone') {\n      return (\n        // @ts-expect-error\n        (this.device?.params?.to_number || this.device?.params?.toNumber) ?? ''\n      )\n    }\n    return (\n      // @ts-expect-error\n      this.device?.params?.to ?? ''\n    )\n  }\n\n  get headers() {\n    // @ts-expect-error\n    return this.device?.params?.headers ?? []\n  }\n\n  get active() {\n    return this.state === 'answered'\n  }\n\n  get connected() {\n    return this.connectState === 'connected'\n  }\n\n  get direction() {\n    return this._payload?.direction\n  }\n\n  get context() {\n    return this._payload.context\n  }\n\n  get connectState() {\n    return this._connectPayload?.connect_state\n  }\n\n  get peer() {\n    return this._peer\n  }\n\n  set peer(callInstance: Call | undefined) {\n    this._peer = callInstance\n  }\n\n  /** @internal */\n  protected setPayload(payload: CallingCall) {\n    this._payload = payload\n  }\n\n  /** @internal */\n  protected setConnectPayload(payload: CallingCallConnectEventParams) {\n    this._connectPayload = payload\n  }\n\n  /**\n   * Hangs up the call.\n   * @param reason Optional reason for hanging up\n   *\n   * @example\n   *\n   * ```js\n   * call.hangup();\n   * ```\n   */\n  hangup(reason: VoiceCallDisconnectReason = 'hangup') {\n    return new Promise((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(\n          new Error(\n            `Can't call hangup() on a call that hasn't been established.`\n          )\n        )\n      }\n\n      this.on('call.state', (params) => {\n        if (params.state === 'ended') {\n          resolve(new Error('Failed to hangup the call.'))\n        }\n      })\n\n      this.execute({\n        method: 'calling.end',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          reason: reason,\n        },\n      }).catch((e) => {\n        reject(e)\n      })\n    })\n  }\n\n  /**\n   * Pass the incoming call to another consumer.\n   *\n   * @example\n   *\n   * ```js\n   * call.pass();\n   * ```\n   */\n  pass() {\n    return new Promise<void>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call pass() on a call without callId.`))\n      }\n\n      this.execute({\n        method: 'calling.pass',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n        },\n      })\n        .then(() => {\n          resolve()\n        })\n        .catch((e) => {\n          reject(e)\n        })\n    })\n  }\n\n  /**\n   * Answers the incoming call.\n   *\n   * @example\n   *\n   * ```js\n   * client.on('call.received', async (call) => {\n   *   try {\n   *     await call.answer()\n   *     console.log('Inbound call answered')\n   *   } catch (error) {\n   *     console.error('Error answering inbound call', error)\n   *   }\n   * })\n   * ```\n   */\n  answer() {\n    return new Promise<this>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call answer() on a call without callId.`))\n      }\n\n      this.on('call.state', (params) => {\n        if (params.state === 'answered') {\n          resolve(this)\n        } else if (params.state === 'ended') {\n          reject(new Error('Failed to answer the call.'))\n        }\n      })\n\n      this.execute({\n        method: 'calling.answer',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n        },\n      }).catch((e) => {\n        reject(e)\n      })\n    })\n  }\n\n  /**\n   * Play one or multiple media in a Call and waits until the playing has ended.\n   *\n   * The play method is a generic method for all types of media, see\n   * {@link playAudio}, {@link playSilence}, {@link playTTS} or\n   * {@link playRingtone} for more specific usages.\n   *\n   * @param params a media playlist. See {@link Voice.Playlist}.\n   *\n   * @example\n   *\n   * ```js\n   * await call.play(new Voice.Playlist({ volume: 1.0 }).add(\n   *   Voice.Playlist.TTS({\n   *     text: 'Welcome to SignalWire! Please enter your 4 digits PIN',\n   *   })\n   * ))\n   * ```\n   */\n  play(params: VoicePlaylist) {\n    return new Promise<CallPlayback>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call play() on a call not established yet.`))\n      }\n\n      const resolveHandler = (callPlayback: CallPlayback) => {\n        this.off('playback.failed', rejectHandler)\n        resolve(callPlayback)\n      }\n\n      const rejectHandler = (callPlayback: CallPlayback) => {\n        this.off('playback.started', resolveHandler)\n        reject(callPlayback)\n      }\n\n      this.once('playback.started', resolveHandler)\n      this.once('playback.failed', rejectHandler)\n\n      const controlId = uuid()\n\n      this.execute({\n        method: 'calling.play',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          control_id: controlId,\n          volume: params.volume,\n          play: toInternalPlayParams(params.media),\n        },\n      })\n        .then(() => {\n          // TODO: handle then?\n        })\n        .catch((e) => {\n          this.off('playback.started', resolveHandler)\n          this.off('playback.failed', rejectHandler)\n          reject(e)\n        })\n    })\n  }\n\n  /**\n   * Plays an audio file.\n   *\n   * @example\n   *\n   * ```js\n   * const playback = await call.playAudio({ url: 'https://cdn.signalwire.com/default-music/welcome.mp3' });\n   * await playback.ended();\n   * ```\n   */\n  playAudio(params: VoiceCallPlayAudioMethodParams) {\n    const { volume, ...rest } = params\n    const playlist = new Playlist({ volume }).add(Playlist.Audio(rest))\n    return this.play(playlist)\n  }\n\n  /**\n   * Plays some silence.\n   *\n   * @example\n   *\n   * ```js\n   * const playback = await call.playSilence({ duration: 3 });\n   * await playback.ended();\n   * ```\n   */\n  playSilence(params: VoiceCallPlaySilenceMethodParams) {\n    const playlist = new Playlist().add(Playlist.Silence(params))\n    return this.play(playlist)\n  }\n\n  /**\n   * Plays a ringtone.\n   *\n   * @example\n   *\n   * ```js\n   * const playback = await call.playRingtone({ name: 'it' });\n   * await playback.ended();\n   * ```\n   */\n  playRingtone(params: VoiceCallPlayRingtoneMethodParams) {\n    const { volume, ...rest } = params\n    const playlist = new Playlist({ volume }).add(Playlist.Ringtone(rest))\n    return this.play(playlist)\n  }\n\n  /**\n   * Plays text-to-speech.\n   *\n   * @example\n   *\n   * ```js\n   * const playback = await call.playTTS({ text: 'Welcome to SignalWire!' });\n   * await playback.ended();\n   * ```\n   */\n  playTTS(params: VoiceCallPlayTTSMethodParams) {\n    const { volume, ...rest } = params\n    const playlist = new Playlist({ volume }).add(Playlist.TTS(rest))\n    return this.play(playlist)\n  }\n\n  /**\n   * Generic method to record a call. Please see {@link recordAudio}.\n   */\n  record(params: VoiceCallRecordMethodParams) {\n    return new Promise<CallRecording>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call record() on a call not established yet.`))\n      }\n\n      const resolveHandler = (callRecording: CallRecording) => {\n        this.off('recording.failed', rejectHandler)\n        resolve(callRecording)\n      }\n\n      const rejectHandler = (callRecording: CallRecording) => {\n        this.off('recording.started', resolveHandler)\n        reject(callRecording)\n      }\n\n      this.once('recording.started', resolveHandler)\n      this.once('recording.failed', rejectHandler)\n\n      const controlId = uuid()\n      const record = toSnakeCaseKeys(params)\n\n      this.execute({\n        method: 'calling.record',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          control_id: controlId,\n          record,\n        },\n      })\n        .then(() => {\n          // TODO: handle then?\n        })\n        .catch((e) => {\n          this.off('recording.started', resolveHandler)\n          this.off('recording.failed', rejectHandler)\n          reject(e)\n        })\n    })\n  }\n\n  /**\n   * Records the audio from the call.\n   *\n   * @example\n   *\n   * ```js\n   * const recording = await call.recordAudio({ direction: 'both' })\n   * await recording.stop()\n   * ```\n   */\n  recordAudio(params: VoiceCallRecordMethodParams['audio'] = {}) {\n    return this.record({\n      audio: params,\n    })\n  }\n\n  /**\n   * Generic method to prompt the user for input. Please see {@link promptAudio}, {@link promptRingtone}, {@link promptTTS}.\n   */\n  prompt(params: VoiceCallPromptMethodParams) {\n    return new Promise<CallPrompt>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call record() on a call not established yet.`))\n      }\n      if (!params.playlist) {\n        reject(new Error(`Missing 'playlist' params.`))\n      }\n\n      const controlId = `${uuid()}.prompt`\n\n      const { volume, media } = params.playlist\n      // TODO: move this to a method to build `collect`\n      const { initial_timeout, digits, speech } = toSnakeCaseKeys(params)\n      const collect = {\n        initial_timeout,\n        digits,\n        speech,\n      }\n\n      this.execute({\n        method: 'calling.play_and_collect',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          control_id: controlId,\n          volume,\n          play: toInternalPlayParams(media),\n          collect,\n        },\n      })\n        .then(() => {\n          const promptInstance = createCallPromptObject({\n            store: this.store,\n            // @ts-expect-error\n            payload: {\n              control_id: controlId,\n              call_id: this.id,\n              node_id: this.nodeId,\n            },\n          })\n          this.instanceMap.set<CallPrompt>(controlId, promptInstance)\n          this.emit('prompt.started', promptInstance)\n          resolve(promptInstance)\n        })\n        .catch((e) => {\n          this.emit('prompt.failed', e)\n          reject(e)\n        })\n    })\n  }\n\n  /**\n   * Play an audio while collecting user input from the call, such as `digits` or `speech`.\n   *\n   * @example\n   *\n   * Prompting for digits and waiting for a result:\n   *\n   * ```js\n   * const prompt = await call.promptAudio({\n   *   url: 'https://cdn.signalwire.com/default-music/welcome.mp3',\n   *   digits: {\n   *     max: 5,\n   *     digitTimeout: 2,\n   *     terminators: '#*'\n   *   }\n   * })\n   * const { type, digits, terminator } = await prompt.ended()\n   * ```\n   */\n  promptAudio(params: VoiceCallPromptAudioMethodParams) {\n    const { url, volume, ...rest } = params\n    const playlist = new Playlist({ volume }).add(Playlist.Audio({ url }))\n\n    return this.prompt({\n      playlist,\n      ...rest,\n    })\n  }\n\n  /**\n   * Play a ringtone while collecting user input from the call, such as `digits` or `speech`.\n   *\n   * @example\n   *\n   * Prompting for digits and waiting for a result:\n   *\n   * ```js\n   * const prompt = await call.promptRingtone({\n   *   name: 'it',\n   *   duration: 10,\n   *   digits: {\n   *     max: 5,\n   *     digitTimeout: 2,\n   *     terminators: '#*'\n   *   }\n   * })\n   * const { type, digits, terminator } = await prompt.ended()\n   * ```\n   */\n  promptRingtone(params: VoiceCallPromptRingtoneMethodParams) {\n    const { name, duration, volume, ...rest } = params\n    const playlist = new Playlist({ volume }).add(\n      Playlist.Ringtone({ name, duration })\n    )\n\n    return this.prompt({\n      playlist,\n      ...rest,\n    })\n  }\n\n  /**\n   * Say some text while collecting user input from the call, such as `digits` or `speech`.\n   *\n   * @example\n   *\n   * Prompting for digits and waiting for a result:\n   *\n   * ```js\n   * const prompt = await call.promptTTS({\n   *   text: 'Please enter your PIN',\n   *   digits: {\n   *     max: 5,\n   *     digitTimeout: 2,\n   *     terminators: '#*'\n   *   }\n   * })\n   * const { type, digits, terminator } = await prompt.ended()\n   * ```\n   */\n  promptTTS(params: VoiceCallPromptTTSMethodParams) {\n    const { text, language, gender, volume, ...rest } = params\n    const playlist = new Playlist({ volume }).add(\n      Playlist.TTS({ text, language, gender })\n    )\n\n    return this.prompt({\n      playlist,\n      ...rest,\n    })\n  }\n\n  /**\n   * Play DTMF digits to the other party on the call.\n   *\n   * @example\n   *\n   * ```js\n   * await call.sendDigits('123')\n   * ```\n   */\n  sendDigits(digits: string) {\n    return new Promise((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(\n          new Error(`Can't call sendDigits() on a call not established yet.`)\n        )\n      }\n\n      const callStateHandler = (params: any) => {\n        if (params.callState === 'ended' || params.callState === 'ending') {\n          reject(\n            new Error(\n              \"Call is ended or about to end, couldn't send digits in time.\"\n            )\n          )\n        }\n      }\n\n      this.once('call.state', callStateHandler)\n\n      const cleanup = () => {\n        this.off('call.state', callStateHandler)\n      }\n\n      const resolveHandler = (call: Call) => {\n        cleanup()\n        // @ts-expect-error\n        this.off('send_digits.failed', rejectHandler)\n        resolve(call)\n      }\n\n      const rejectHandler = (error: Error) => {\n        cleanup()\n        // @ts-expect-error\n        this.off('send_digits.finished', resolveHandler)\n        reject(error)\n      }\n\n      // @ts-expect-error\n      this.once('send_digits.finished', resolveHandler)\n      // @ts-expect-error\n      this.once('send_digits.failed', rejectHandler)\n\n      const controlId = uuid()\n\n      this.execute({\n        method: 'calling.send_digits',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          control_id: controlId,\n          digits,\n        },\n      }).catch((e) => {\n        reject(e)\n      })\n    })\n  }\n\n  /**\n   * Intercept call media and stream it to the specified WebSocket endpoint.\n   * Prefer using {@link tapAudio} if you only need to tap audio.\n   *\n   * @example\n   *\n   * ```js\n   * const tap = await call.tapAudio({\n   *   audio: {\n   *     direction: 'both',\n   *   },\n   *   device: {\n   *     type: 'ws',\n   *     uri: 'wss://example.domain.com/endpoint',\n   *   },\n   * })\n   *\n   * await tap.stop()\n   * ```\n   */\n  tap(params: VoiceCallTapMethodParams) {\n    return new Promise<CallTap>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call tap() on a call not established yet.`))\n      }\n\n      const resolveHandler = (callTap: CallTap) => {\n        this.off('tap.ended', rejectHandler)\n        resolve(callTap)\n      }\n\n      const rejectHandler = (callTap: CallTap) => {\n        this.off('tap.started', resolveHandler)\n        reject(callTap)\n      }\n\n      this.once('tap.started', resolveHandler)\n      this.once('tap.ended', rejectHandler)\n\n      const controlId = uuid()\n\n      // TODO: Move to a method to build the objects and transform camelCase to snake_case\n      const {\n        audio = {},\n        device: { type, ...rest },\n      } = params\n\n      this.execute({\n        method: 'calling.tap',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          control_id: controlId,\n          tap: {\n            type: 'audio',\n            params: audio,\n          },\n          device: {\n            type,\n            params: rest,\n          },\n        },\n      })\n        .then(() => {\n          // TODO: handle then?\n        })\n        .catch((e) => {\n          this.off('tap.started', resolveHandler)\n          this.off('tap.ended', rejectHandler)\n          reject(e)\n        })\n    })\n  }\n\n  /**\n   * Intercept call audio and stream it to the specified WebSocket endpoint.\n   *\n   * @example\n   *\n   * ```js\n   * const tap = await call.tapAudio({\n   *   direction: 'both',\n   *   device: {\n   *     type: 'ws',\n   *     uri: 'wss://example.domain.com/endpoint',\n   *   },\n   * })\n   *\n   * await tap.stop()\n   * ```\n   */\n  tapAudio(params: VoiceCallTapAudioMethodParams) {\n    const { direction, device } = params\n    return this.tap({ audio: { direction }, device })\n  }\n\n  /**\n   * Attempt to connect an existing call to a new outbound call. You can wait\n   * until the call is disconnected by calling {@link waitForDisconnected}.\n   *\n   * This is a generic method that allows you to connect to multiple devices in\n   * series, parallel, or combinations of both with the use of a\n   * {@link Voice.DeviceBuilder}. For simpler use cases, prefer using\n   * {@link connectPhone} or {@link connectSip}.\n   *\n   * @example\n   *\n   * Connecting to a new SIP call.\n   *\n   * ```js\n   * const plan = new Voice.DeviceBuilder().add(\n   *   Voice.DeviceBuilder.Sip({\n   *     from: 'sip:user1@domain.com',\n   *     to: 'sip:user2@domain.com',\n   *     timeout: 30,\n   *   })\n   * )\n   *\n   * const peer = await call.connect(plan)\n   * ```\n   */\n  connect(params: VoiceCallConnectMethodParams) {\n    return new Promise<any>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call connect() on a call not established yet.`))\n      }\n\n      // We can ignore the \"ringback\" error since we just want to cleanup \"...rest\"\n      // @ts-expect-error\n      const { devices, ringback, ...rest } = params\n      const executeParams: Record<string, any> = {\n        tag: this.__uuid,\n        ...toSnakeCaseKeys(rest),\n      }\n      if ('ringback' in params) {\n        executeParams.ringback = toInternalPlayParams(\n          params.ringback?.media ?? []\n        )\n      }\n\n      if (params instanceof DeviceBuilder) {\n        executeParams.devices = toInternalDevices(params.devices)\n      } else if (devices instanceof DeviceBuilder) {\n        executeParams.devices = toInternalDevices(devices.devices)\n      } else {\n        throw new Error('[connect] Invalid \"devices\" parameter.')\n      }\n\n      const resolveHandler = (payload: Call) => {\n        // @ts-expect-error\n        this.off('connect.failed', rejectHandler)\n        resolve(payload)\n      }\n\n      const rejectHandler = (payload: Call) => {\n        // @ts-expect-error\n        this.off('connect.connected', resolveHandler)\n        reject(toExternalJSON(payload))\n      }\n\n      // @ts-expect-error\n      this.once('connect.connected', resolveHandler)\n      // @ts-expect-error\n      this.once('connect.failed', rejectHandler)\n\n      this.execute({\n        method: 'calling.connect',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          tag: this.__uuid,\n          ...executeParams,\n        },\n      }).catch((e) => {\n        // @ts-expect-error\n        this.off('connect.connected', resolveHandler)\n        // @ts-expect-error\n        this.off('connect.failed', rejectHandler)\n\n        reject(e)\n      })\n    })\n  }\n\n  /**\n   * Attempt to connect an existing call to a new outbound phone call. You can\n   * wait until the call is disconnected by calling {@link waitForDisconnected}.\n   *\n   * @example\n   *\n   * ```js\n   * const peer = await call.connectPhone({\n   *   from: '+xxxxxx',\n   *   to: '+yyyyyy',\n   *   timeout: 30\n   * })\n   * ```\n   */\n  connectPhone({\n    ringback,\n    maxPricePerMinute,\n    ...params\n  }: VoiceCallConnectPhoneMethodParams) {\n    const devices = new DeviceBuilder().add(DeviceBuilder.Phone(params))\n    return this.connect({ devices, maxPricePerMinute, ringback })\n  }\n\n  /**\n   * Attempt to connect an existing call to a new outbound SIP call. You can\n   * wait until the call is disconnected by calling {@link waitForDisconnected}.\n   *\n   * @example\n   *\n   * ```js\n   * const peer = await call.connectPhone({\n   *   from: 'sip:user1@domain.com',\n   *   to: 'sip:user2@domain.com',\n   *   timeout: 30\n   * })\n   * ```\n   */\n  connectSip({\n    ringback,\n    maxPricePerMinute,\n    ...params\n  }: VoiceCallConnectSipMethodParams) {\n    const devices = new DeviceBuilder().add(DeviceBuilder.Sip(params))\n    return this.connect({ devices, maxPricePerMinute, ringback })\n  }\n\n  disconnect() {\n    return new Promise<void>((resolve, reject) => {\n      if (!this.callId || !this.nodeId || !this.peer) {\n        reject(\n          new Error(`Can't call disconnect() on a call not connected yet.`)\n        )\n      }\n\n      const resolveHandler = () => {\n        resolve()\n      }\n      // @ts-expect-error\n      this.once('connect.disconnected', resolveHandler)\n\n      this.execute({\n        method: 'calling.disconnect',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n        },\n      }).catch((e) => {\n        // @ts-expect-error\n        this.off('connect.disconnected', resolveHandler)\n\n        reject(e)\n      })\n    })\n  }\n\n  /**\n   * @deprecated use {@link disconnected} instead.\n   */\n  waitForDisconnected() {\n    return this.disconnect\n  }\n\n  disconnected() {\n    return new Promise<this>((resolve) => {\n      const resolveHandler = () => {\n        resolve(this)\n      }\n      // @ts-expect-error\n      this.once('connect.disconnected', resolveHandler)\n      // @ts-expect-error\n      this.once('connect.failed', resolveHandler)\n\n      if (this.state === 'ended' || this.state === 'ending') {\n        return resolveHandler()\n      }\n    })\n  }\n\n  /**\n   * Generic method. Please see {@link amd}, {@link detectFax}, {@link detectDigit}.\n   */\n  detect(params: VoiceCallDetectMethodParams) {\n    return new Promise<CallDetect>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call detect() on a call not established yet.`))\n      }\n\n      const controlId = uuid()\n\n      // TODO: build params in a method\n      const { timeout, type, waitForBeep = false, ...rest } = params\n\n      this.execute({\n        method: 'calling.detect',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          control_id: controlId,\n          timeout,\n          detect: {\n            type,\n            params: toSnakeCaseKeys(rest),\n          },\n        },\n      })\n        .then(() => {\n          const detectInstance = createCallDetectObject({\n            store: this.store,\n            payload: {\n              control_id: controlId,\n              call_id: this.id,\n              node_id: this.nodeId,\n              waitForBeep,\n            },\n          })\n          this.instanceMap.set<CallDetect>(controlId, detectInstance)\n          // @ts-expect-error\n          this.emit('detect.started', detectInstance)\n          resolve(detectInstance)\n        })\n        .catch((e) => {\n          // @ts-expect-error\n          this.emit('detect.ended', e)\n          reject(e)\n        })\n    })\n  }\n\n  /**\n   * Detects the presence of an answering machine.\n   *\n   * @example\n   *\n   * ```js\n   * const detect = await call.amd()\n   * const result = await detect.ended()\n   *\n   * console.log('Detect result:', result.type)\n   * ```\n   */\n  amd(params: Omit<VoiceCallDetectMachineParams, 'type'> = {}) {\n    return this.detect({\n      ...params,\n      type: 'machine',\n    })\n  }\n\n  /**\n   * Alias for amd()\n   */\n  detectAnsweringMachine = this.amd\n\n  /**\n   * Detects the presence of a fax machine.\n   *\n   * @example\n   *\n   * ```js\n   * const detect = await call.detectFax()\n   * const result = await detect.ended()\n   *\n   * console.log('Detect result:', result.type)\n   * ```\n   */\n  detectFax(params: Omit<VoiceCallDetectFaxParams, 'type'> = {}) {\n    return this.detect({\n      ...params,\n      type: 'fax',\n    })\n  }\n\n  /**\n   * Detects digits in the audio stream.\n   *\n   * @example\n   *\n   * ```js\n   * const detect = await call.detectDigit()\n   * const result = await detect.ended()\n   *\n   * console.log('Detect result:', result.type)\n   * ```\n   */\n  detectDigit(params: Omit<VoiceCallDetectDigitParams, 'type'> = {}) {\n    return this.detect({\n      ...params,\n      type: 'digit',\n    })\n  }\n\n  /**\n   * Returns a promise that is resolved only after the current call is in one of\n   * the specified states.\n   *\n   * @returns true if the requested states have been reached, false if they\n   * won't be reached because the call ended.\n   *\n   * @example\n   *\n   * ```js\n   * await call.waitFor('ended')\n   * ```\n   */\n  waitFor(params: CallingCallWaitForState | CallingCallWaitForState[]) {\n    return new Promise((resolve) => {\n      if (!params) {\n        resolve(true)\n      }\n\n      const events = Array.isArray(params) ? params : [params]\n      const emittedCallStates = new Set<CallingCallState>()\n      const shouldResolve = () => emittedCallStates.size === events.length\n      const shouldWaitForEnded = events.includes('ended')\n      // If the user is not awaiting for the `ended` state\n      // and we've got that from the server then we won't\n      // get the event/s the user was awaiting for\n      const shouldResolveUnsuccessful = (state: CallingCallState) => {\n        return !shouldWaitForEnded && state === 'ended'\n      }\n\n      this.on('call.state', (params) => {\n        if (events.includes(params.state as CallingCallWaitForState)) {\n          emittedCallStates.add(params.state)\n        } else if (shouldResolveUnsuccessful(params.state)) {\n          return resolve(false)\n        }\n\n        if (shouldResolve()) {\n          resolve(true)\n        }\n      })\n    })\n  }\n\n  /**\n   * Collect user input from the call, such as `digits` or `speech`.\n   *\n   * @example\n   *\n   * Collect digits and waiting for a result:\n   *\n   * ```js\n   * const collectObj = await call.collect({\n   *   digits: {\n   *     max: 5,\n   *     digitTimeout: 2,\n   *     terminators: '#*'\n   *   }\n   * })\n   * const { digits, terminator } = await collectObj.ended()\n   * ```\n   */\n  collect(params: VoiceCallCollectMethodParams) {\n    return new Promise<CallCollect>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call collect() on a call not established yet.`))\n      }\n\n      const controlId = uuid()\n\n      // TODO: move this to a method to build the params\n      const {\n        initial_timeout,\n        partial_results,\n        digits,\n        speech,\n        continuous,\n        send_start_of_input,\n        start_input_timers,\n      } = toSnakeCaseKeys(params)\n\n      this.execute({\n        method: 'calling.collect',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          control_id: controlId,\n          initial_timeout,\n          digits,\n          speech,\n          partial_results,\n          continuous,\n          send_start_of_input,\n          start_input_timers,\n        },\n      })\n        .then(() => {\n          const collectInstance = createCallCollectObject({\n            store: this.store,\n            // @ts-expect-error\n            payload: {\n              control_id: controlId,\n              call_id: this.id,\n              node_id: this.nodeId,\n            },\n          })\n          this.instanceMap.set<CallCollect>(controlId, collectInstance)\n          this.emit('collect.started', collectInstance)\n          resolve(collectInstance)\n        })\n        .catch((e) => {\n          this.emit('collect.failed', e)\n          reject(e)\n        })\n    })\n  }\n}\n\n// FIXME: instead of Omit methods, i used \"Partial<VoiceCallMethods>\"\nexport const CallAPI = extendComponent<CallConsumer, Partial<VoiceCallMethods>>(\n  CallConsumer,\n  {}\n)\n\nexport const createCallObject = (params: CallOptions): Call => {\n  const call = connect<RealTimeCallApiEvents, CallConsumer, Call>({\n    store: params.store,\n    Component: CallAPI,\n  })(params)\n\n  return call\n}\n", "import type {\n  VoiceCallDeviceParams,\n  VoiceCallDialMethodParams,\n  VoiceCallPlayParams,\n  VoiceCallPlayMethodParams,\n} from '@signalwire/core'\nimport { toSnakeCaseKeys } from '@signalwire/core'\n\nconst toInternalDevice = (device: VoiceCallDeviceParams) => {\n  switch (device.type) {\n    case 'sip': {\n      const { type, ...params } = device\n      return {\n        type,\n        params: toSnakeCaseKeys(params),\n      }\n    }\n    case 'phone': {\n      const { to, from, type, ...rest } = device\n      return {\n        type,\n        params: toSnakeCaseKeys({\n          ...rest,\n          to_number: to,\n          from_number: from,\n        }),\n      }\n    }\n\n    // TODO: handle other devices\n  }\n\n  return device\n}\n\n// TODO: add proper to internal mapping\ntype ToInternalDialParams<T> = T extends any ? any : any\n\nexport const toInternalDevices = (\n  params: VoiceCallDialMethodParams['devices'],\n  internalDevices: ToInternalDialParams<\n    VoiceCallDialMethodParams['devices']\n  > = []\n) => {\n  params.forEach((dev, index) => {\n    if (Array.isArray(dev)) {\n      internalDevices[index] = toInternalDevices(dev)\n    } else {\n      internalDevices[index] = toInternalDevice(dev)\n    }\n  })\n  return internalDevices\n}\n\nconst toInternalPlay = (media: VoiceCallPlayParams) => {\n  const { type, ...params } = media\n  return { type, params }\n}\n\n// TODO: add proper to internal mapping\ntype ToInternalPlayParams<T> = T extends any ? any : any\n\nexport const toInternalPlayParams = (\n  params: VoiceCallPlayMethodParams['media'],\n  result: ToInternalPlayParams<VoiceCallPlayMethodParams['media']> = []\n) => {\n  params.forEach((media, index) => {\n    if (Array.isArray(media)) {\n      result[index] = toInternalPlayParams(media)\n    } else {\n      result[index] = toInternalPlay(media)\n    }\n  })\n  return result\n}\n", "import type {\n  CreateVoicePlaylistParams,\n  VoicePlaylist,\n  VoiceCallPlayParams,\n  VoiceCallPlayAudioParams,\n  VoiceCallPlayTTSParams,\n  VoiceCallPlaySilenceParams,\n  VoiceCallPlayRingtoneParams,\n  VoicePlaylistAudioParams,\n  VoicePlaylistTTSParams,\n  VoicePlaylistSilenceParams,\n  VoicePlaylistRingtoneParams,\n} from '@signalwire/core'\n\n/**\n * A Playlist object allows you to specify a series of media which should be\n * played in sequence. You can then pass the playlist to the methods that\n * support it, for example {@link Call.play}.\n *\n * @example\n *\n * Creates a playlist for playing, in sequence, a TTS message, 1 second of\n * silence, and an mp3 file.\n *\n * ```js\n * const playlist = new Voice.Playlist({ volume: 1.0 })\n *   .add(Voice.Playlist.TTS({\n *     text: 'Welcome to SignalWire!',\n *   }))\n *   .add(Voice.Playlist.Silence({ duration: 1 }))\n *   .add(Voice.Playlist.Audio({\n *     url: 'https://cdn.signalwire.com/default-music/welcome.mp3'\n *   }))\n * ```\n */\nexport class Playlist implements VoicePlaylist {\n  private _media: VoicePlaylist['media'] = []\n\n  constructor(private params: CreateVoicePlaylistParams = {}) {}\n\n  /** Default volume for the audio in the playlist. */\n  get volume() {\n    return this.params?.volume\n  }\n\n  /** The media in this playlist. */\n  get media() {\n    return this._media\n  }\n\n  /** Adds a new media to the playlist*/\n  add(params: VoiceCallPlayParams) {\n    this._media.push(params)\n    return this\n  }\n\n  /**\n   * An audio media.\n   * @params params - {@link VoicePlaylistAudioParams}\n   * @returns - {@link VoiceCallPlayAudioParams}\n   **/\n  static Audio(params: VoicePlaylistAudioParams): VoiceCallPlayAudioParams {\n    return { type: 'audio', ...params }\n  }\n\n  /**\n   * A TTS media.\n   * @params params - {@link VoicePlaylistTTSParams}\n   * @returns - {@link VoiceCallPlayTTSParams}\n   **/\n  static TTS(params: VoicePlaylistTTSParams): VoiceCallPlayTTSParams {\n    return { type: 'tts', ...params }\n  }\n\n  /**\n   * A silence interval.\n   * @params params - {@link VoicePlaylistSilenceParams}\n   * @returns - {@link VoiceCallPlaySilenceParams}\n   **/\n  static Silence(\n    params: VoicePlaylistSilenceParams\n  ): VoiceCallPlaySilenceParams {\n    return { type: 'silence', ...params }\n  }\n\n  /**\n   * A ringtone media.\n   * @params param - {@link VoicePlaylistRingtoneParams}\n   * @returns - {@link VoiceCallPlayRingtoneParams}\n   **/\n  static Ringtone(\n    params: VoicePlaylistRingtoneParams\n  ): VoiceCallPlayRingtoneParams {\n    return { type: 'ringtone', ...params }\n  }\n}\n", "import {\n  connect,\n  BaseComponentOptionsWithPayload,\n  VoiceCallPromptContract,\n  CallingCallCollectEndState,\n  CallPromptEndedEvent,\n  CallingCallCollectEventParams,\n  EventEmitter,\n  BaseConsumer,\n} from '@signalwire/core'\n\n/**\n * Instances of this class allow you to control (e.g., resume) the\n * prompt inside a Voice Call. You can obtain instances of this class by\n * starting a Prompt from the desired {@link Call} (see\n * {@link Call.prompt})\n */\nexport interface CallPrompt extends VoiceCallPromptContract {\n  setPayload: (payload: CallingCallCollectEventParams) => void\n  /** @internal */\n  emit(event: EventEmitter.EventNames<any>, ...args: any[]): void\n}\n\nexport type CallPromptEventsHandlerMapping = {}\n\nexport interface CallPromptOptions\n  extends BaseComponentOptionsWithPayload<CallingCallCollectEventParams> {}\n\nconst ENDED_STATES: CallingCallCollectEndState[] = [\n  'no_input',\n  'error',\n  'no_match',\n  'digit',\n  'speech',\n]\n\nexport class CallPromptAPI\n  extends BaseConsumer<CallPromptEventsHandlerMapping>\n  implements VoiceCallPromptContract\n{\n  private _payload: CallingCallCollectEventParams\n\n  constructor(options: CallPromptOptions) {\n    super(options)\n\n    this._payload = options.payload\n  }\n\n  get id() {\n    return this._payload?.control_id.split('.')[0]\n  }\n\n  get controlId() {\n    return this._payload.control_id\n  }\n\n  get callId() {\n    return this._payload.call_id\n  }\n\n  get nodeId() {\n    return this._payload.node_id\n  }\n\n  get result() {\n    return this._payload.result\n  }\n\n  get type() {\n    return this.result?.type\n  }\n\n  /**\n   * User-friendly alias to understand the reason in case of errors\n   * no_match | no_input | error\n   */\n  get reason() {\n    return this.type\n  }\n\n  get digits() {\n    if (this.result?.type === 'digit') {\n      return this.result.params.digits\n    }\n    return undefined\n  }\n\n  get speech() {\n    if (this.result?.type === 'speech') {\n      return this.result.params.text\n    }\n    return undefined\n  }\n\n  get terminator() {\n    if (this.result?.type === 'digit') {\n      return this.result.params.terminator\n    }\n    return undefined\n  }\n\n  get text() {\n    if (this.result?.type === 'speech') {\n      return this.result.params.text\n    }\n    return undefined\n  }\n\n  get confidence() {\n    if (this.result?.type === 'speech') {\n      return this.result.params.confidence\n    }\n    return undefined\n  }\n\n  /** @internal */\n  protected setPayload(payload: CallingCallCollectEventParams) {\n    this._payload = payload\n  }\n\n  async stop() {\n    // Execute stop only if we don't have result yet\n    if (!this.result) {\n      await this.execute({\n        method: 'calling.play_and_collect.stop',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          control_id: this.controlId,\n        },\n      })\n    }\n\n    /**\n     * TODO: we should wait for the prompt to be finished to allow\n     * the CallPrompt/Proxy object to update the payload properly\n     */\n\n    return this\n  }\n\n  async setVolume(volume: number): Promise<this> {\n    await this.execute({\n      method: 'calling.play_and_collect.volume',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n        volume,\n      },\n    })\n\n    return this\n  }\n\n  /** @deprecated */\n  waitForResult() {\n    return this.ended()\n  }\n\n  ended() {\n    // Resolve the promise if the prompt has already ended\n    if (\n      ENDED_STATES.includes(this.result?.type as CallingCallCollectEndState)\n    ) {\n      return Promise.resolve(this)\n    }\n\n    return new Promise<this>((resolve) => {\n      const handler = (_callPrompt: CallPromptEndedEvent['params']) => {\n        // @ts-expect-error\n        this.off('prompt.ended', handler)\n        // @ts-expect-error\n        this.off('prompt.failed', handler)\n        // It's important to notice that we're returning\n        // `this` instead of creating a brand new instance\n        // using the payload + EventEmitter Transform\n        // pipeline. `this` is the instance created by the\n        // `Call` Emitter Transform pipeline (singleton per\n        // `Call.prompt()`) that gets auto updated (using\n        // the latest payload per event) by the\n        // `voiceCallPromptWorker`\n        resolve(this)\n      }\n      // @ts-expect-error\n      this.once('prompt.ended', handler)\n      // @ts-expect-error\n      this.once('prompt.failed', handler)\n    })\n  }\n}\n\nexport const createCallPromptObject = (\n  params: CallPromptOptions\n): CallPrompt => {\n  const record = connect<\n    CallPromptEventsHandlerMapping,\n    CallPromptAPI,\n    CallPrompt\n  >({\n    store: params.store,\n    Component: CallPromptAPI,\n  })(params)\n\n  return record\n}\n", "import {\n  connect,\n  BaseComponentOptionsWithPayload,\n  VoiceCallDetectContract,\n  CallingCallDetectEventParams,\n  BaseConsumer,\n  EventEmitter,\n  type DetectorResult,\n} from '@signalwire/core'\n\n/**\n * Instances of this class allow you to control (e.g., resume) the\n * detect inside a Voice Call. You can obtain instances of this class by\n * starting a Detect from the desired {@link Call} (see\n * {@link Call.detect})\n */\nexport interface CallDetect extends VoiceCallDetectContract {\n  setPayload: (payload: CallingCallDetectEventParams) => void\n  waitingForReady: boolean\n  waitForBeep: boolean\n  /** @internal */\n  emit(event: EventEmitter.EventNames<any>, ...args: any[]): void\n}\n\nexport type CallDetectEventsHandlerMapping = {}\n\nexport interface CallDetectOptions\n  extends BaseComponentOptionsWithPayload<CallingCallDetectEventParams> {}\n\nconst ENDED_STATES: DetectorResult[] = ['finished', 'error']\n\nexport class CallDetectAPI\n  extends BaseConsumer<CallDetectEventsHandlerMapping>\n  implements VoiceCallDetectContract\n{\n  private _payload: CallingCallDetectEventParams\n  private _waitForBeep: boolean\n  private _result: DetectorResult = 'UNKNOWN'\n\n  constructor(options: CallDetectOptions) {\n    super(options)\n\n    this._payload = options.payload\n    this._waitForBeep = options.payload.waitForBeep\n  }\n\n  get id() {\n    return this._payload.control_id\n  }\n\n  get controlId() {\n    return this._payload.control_id\n  }\n\n  get callId() {\n    return this._payload.call_id\n  }\n\n  get nodeId() {\n    return this._payload.node_id\n  }\n\n  get detect() {\n    return this._payload.detect\n  }\n\n  get type() {\n    return this?.detect?.type\n  }\n\n  get result() {\n    return this._result\n  }\n\n  get waitForBeep() {\n    return this._waitForBeep\n  }\n\n  get beep() {\n    if (this.detect?.params.event === 'MACHINE') {\n      return Boolean(this.detect.params.beep)\n    }\n    return undefined\n  }\n\n  /** @internal */\n  protected setPayload(payload: CallingCallDetectEventParams) {\n    this._payload = payload\n\n    const lastEvent = this._lastEvent()\n    if (lastEvent && lastEvent !== 'finished') {\n      this._result = lastEvent\n    }\n  }\n\n  async stop() {\n    // if (this.state !== 'finished') {\n    await this.execute({\n      method: 'calling.detect.stop',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n    // }\n\n    return this\n  }\n\n  /** @deprecated */\n  waitForResult() {\n    return this.ended()\n  }\n\n  ended() {\n    // Resolve the promise if the detect has already ended\n    const lastEvent = this._lastEvent()\n    if (lastEvent && ENDED_STATES.includes(lastEvent)) {\n      return Promise.resolve(this)\n    }\n\n    return new Promise<this>((resolve) => {\n      const handler = () => {\n        // @ts-expect-error\n        this.off('detect.ended', handler)\n        // It's important to notice that we're returning\n        // `this` instead of creating a brand new instance\n        // using the payload + EventEmitter Transform\n        // pipeline. `this` is the instance created by the\n        // `Call` Emitter Transform pipeline (singleton per\n        // `Call.detect()`) that gets auto updated (using\n        // the latest payload per event) by the\n        // `voiceCallDetectWorker`\n        resolve(this)\n      }\n\n      // @ts-expect-error\n      this.once('detect.ended', handler)\n    })\n  }\n\n  private _lastEvent() {\n    return this.detect?.params.event\n  }\n}\n\nexport const createCallDetectObject = (\n  params: CallDetectOptions\n): CallDetect => {\n  const detect = connect<\n    CallDetectEventsHandlerMapping,\n    CallDetectAPI,\n    CallDetect\n  >({\n    store: params.store,\n    Component: CallDetectAPI,\n  })(params)\n\n  return detect\n}\n", "import {\n  connect,\n  BaseComponentOptionsWithPayload,\n  VoiceCallCollectContract,\n  CallingCallCollectEndState,\n  CallCollectEndedEvent,\n  CallingCallCollectEventParams,\n  EventEmitter,\n  BaseConsumer,\n} from '@signalwire/core'\n\n/**\n * Instances of this class allow you to control (e.g., resume) the\n * prompt inside a Voice Call. You can obtain instances of this class by\n * starting a Prompt from the desired {@link Call} (see\n * {@link Call.prompt})\n */\nexport interface CallCollect extends VoiceCallCollectContract {\n  setPayload: (payload: CallingCallCollectEventParams) => void\n  /** @internal */\n  emit(event: EventEmitter.EventNames<any>, ...args: any[]): void\n}\n\nexport type CallCollectEventsHandlerMapping = {}\n\nexport interface CallCollectOptions\n  extends BaseComponentOptionsWithPayload<CallingCallCollectEventParams> {}\n\nconst ENDED_STATES: CallingCallCollectEndState[] = [\n  'error',\n  'no_input',\n  'no_match',\n  'digit',\n  'speech',\n]\n\nexport class CallCollectAPI\n  extends BaseConsumer<CallCollectEventsHandlerMapping>\n  implements VoiceCallCollectContract\n{\n  private _payload: CallingCallCollectEventParams\n\n  constructor(options: CallCollectOptions) {\n    super(options)\n\n    this._payload = options.payload\n  }\n\n  get id() {\n    return this._payload?.control_id.split('.')[0]\n  }\n\n  get controlId() {\n    return this._payload.control_id\n  }\n\n  get callId() {\n    return this._payload.call_id\n  }\n\n  get nodeId() {\n    return this._payload.node_id\n  }\n\n  get result() {\n    return this._payload.result\n  }\n\n  get type() {\n    return this.result?.type\n  }\n\n  /**\n   * User-friendly alias to understand the reason in case of errors\n   * no_match | no_input | error\n   */\n  get reason() {\n    return this.type\n  }\n\n  get digits() {\n    if (this.result?.type === 'digit') {\n      return this.result.params.digits\n    }\n    return undefined\n  }\n\n  get speech() {\n    if (this.result?.type === 'speech') {\n      return this.result.params.text\n    }\n    return undefined\n  }\n\n  get terminator() {\n    if (this.result?.type === 'digit') {\n      return this.result.params.terminator\n    }\n    return undefined\n  }\n\n  get text() {\n    if (this.result?.type === 'speech') {\n      return this.result.params.text\n    }\n    return undefined\n  }\n\n  get confidence() {\n    if (this.result?.type === 'speech') {\n      return this.result.params.confidence\n    }\n    return undefined\n  }\n\n  get state() {\n    return this._payload.state\n  }\n\n  get final() {\n    return this._payload.final\n  }\n\n  /** @internal */\n  protected setPayload(payload: CallingCallCollectEventParams) {\n    this._payload = payload\n  }\n\n  async stop() {\n    // Execute stop only if we don't have result yet\n    if (!this.result) {\n      await this.execute({\n        method: 'calling.collect.stop',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          control_id: this.controlId,\n        },\n      })\n    }\n\n    /**\n     * TODO: we should wait for the prompt to be finished to allow\n     * the CallCollect/Proxy object to update the payload properly\n     */\n\n    return this\n  }\n\n  async startInputTimers() {\n    await this.execute({\n      method: 'calling.collect.start_input_timers',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    return this\n  }\n\n  ended() {\n    // Resolve the promise if the collect has already ended\n    if (\n      this.state != 'collecting' && this.final !== false &&\n      ENDED_STATES.includes(this.result?.type as CallingCallCollectEndState)\n    ) {\n      return Promise.resolve(this)\n    }\n\n    return new Promise<this>((resolve) => {\n      const handler = (_callCollect: CallCollectEndedEvent['params']) => {\n        // @ts-expect-error\n        this.off('collect.ended', handler)\n        // @ts-expect-error\n        this.off('collect.failed', handler)\n        // It's important to notice that we're returning\n        // `this` instead of creating a brand new instance\n        // using the payload + EventEmitter Transform\n        // pipeline. `this` is the instance created by the\n        // `Call` Emitter Transform pipeline (singleton per\n        // `Call.prompt()`) that gets auto updated (using\n        // the latest payload per event) by the\n        // `voiceCallCollectWorker`\n        resolve(this)\n      }\n      // @ts-expect-error\n      this.once('collect.ended', handler)\n      // @ts-expect-error\n      this.once('collect.failed', handler)\n    })\n  }\n}\n\nexport const createCallCollectObject = (\n  params: CallCollectOptions\n): CallCollect => {\n  const collect = connect<\n    CallCollectEventsHandlerMapping,\n    CallCollectAPI,\n    CallCollect\n  >({\n    store: params.store,\n    Component: CallCollectAPI,\n  })(params)\n\n  return collect\n}\n", "import type {\n  VoiceDeviceBuilder,\n  VoiceCallDeviceParams,\n  VoiceCallPhoneParams,\n  VoiceCallDialPhoneMethodParams,\n  VoiceCallSipParams,\n  VoiceCallDialSipMethodParams,\n} from '@signalwire/core'\n\n/**\n * A DeviceBuilder object allows you to specify a set of devices which should be\n * dialed in sequence or parallel. You can then pass the device plan to the\n * methods that support it, for example {@link Call.connect}.\n *\n * @example\n *\n * Creates a plan which specifies to dial a SIP endpoint. If there is no answer\n * within 30 seconds, calls two phone numbers in parallel (as indicated by the\n * array syntax). As soon as one of the two answers, the operation is\n * considered successful.\n *\n * ```js\n * const plan = new Voice.DeviceBuilder()\n *   .add(Voice.DeviceBuilder.Sip({\n *     from: 'sip:user1@domain.com',\n *     to: 'sip:user2@domain.com',\n *     timeout: 30,\n *   }))\n *   .add([\n *     Voice.DeviceBuilder.Phone({ to: '+yyyyyy', timeout: 30 }),\n *     Voice.DeviceBuilder.Phone({ to: '+zzzzzz', timeout: 30 })\n *   ])\n * ```\n */\nexport class DeviceBuilder implements VoiceDeviceBuilder {\n  private _devices: VoiceDeviceBuilder['devices'] = []\n\n  get devices() {\n    return this._devices\n  }\n\n  add(params: VoiceCallDeviceParams | VoiceCallDeviceParams[]) {\n    if (Array.isArray(params)) {\n      this._devices.push(params)\n    } else {\n      this._devices.push([params])\n    }\n\n    return this\n  }\n\n  static Phone(params: VoiceCallDialPhoneMethodParams): VoiceCallPhoneParams {\n    return { type: 'phone', ...params }\n  }\n\n  static Sip(params: VoiceCallDialSipMethodParams): VoiceCallSipParams {\n    return { type: 'sip', ...params }\n  }\n}\n", "import { CallingCall, getLogger, SagaIterator } from '@signalwire/core'\nimport { createCallObject } from '../Call'\nimport type { Call } from '../Call'\nimport type { VoiceCallWorkerParams } from './voiceCallingWorker'\n\nexport const voiceCallReceiveWorker = function* (\n  options: VoiceCallWorkerParams<CallingCall>\n): SagaIterator {\n  getLogger().trace('voiceCallReceiveWorker started')\n  const {\n    instance: client,\n    payload,\n    instanceMap: { get, set },\n  } = options\n\n  // Contexts is required\n  const { contexts = [], topics = [] } = client?.options ?? {}\n  if (!contexts.length && !topics.length) {\n    throw new Error('Invalid contexts to receive inbound calls')\n  }\n\n  let callInstance = get<Call>(payload.call_id)\n  if (!callInstance) {\n    callInstance = createCallObject({\n      store: client.store,\n      payload: payload,\n    })\n  } else {\n    callInstance.setPayload(payload)\n  }\n\n  set<Call>(payload.call_id, callInstance)\n  // @ts-expect-error\n  client.emit('call.received', callInstance)\n\n  getLogger().trace('voiceCallReceiveWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  CallingCallPlayEventParams,\n} from '@signalwire/core'\nimport { CallPlayback, createCallPlaybackObject } from '../CallPlayback'\nimport { Call } from '../Voice'\nimport type { VoiceCallWorkerParams } from './voiceCallingWorker'\n\nexport const voiceCallPlayWorker = function* (\n  options: VoiceCallWorkerParams<CallingCallPlayEventParams>\n): SagaIterator {\n  getLogger().trace('voiceCallPlayWorker started')\n  const {\n    payload,\n    instanceMap: { get, set, remove },\n  } = options\n\n  const callInstance = get<Call>(payload.call_id)\n  if (!callInstance) {\n    throw new Error('Missing call instance for playback')\n  }\n\n  // Playback events control id for prompt contains `.prompt` keyword at the end of the string\n  const [controlId] = payload.control_id.split('.')\n  getLogger().trace('voiceCallPlayWorker controlId', controlId)\n\n  let playbackInstance = get<CallPlayback>(controlId)\n  if (!playbackInstance) {\n    getLogger().trace('voiceCallPlayWorker create instance')\n    playbackInstance = createCallPlaybackObject({\n      store: callInstance.store,\n      payload,\n    })\n  } else {\n    getLogger().trace('voiceCallPlayWorker GOT instance')\n    playbackInstance.setPayload(payload)\n  }\n  set<CallPlayback>(controlId, playbackInstance)\n\n  switch (payload.state) {\n    case 'playing': {\n      const type = playbackInstance._paused\n        ? 'playback.updated'\n        : 'playback.started'\n      playbackInstance._paused = false\n\n      callInstance.emit(type, playbackInstance)\n      break\n    }\n    case 'paused': {\n      playbackInstance._paused = true\n      callInstance.emit('playback.updated', playbackInstance)\n      break\n    }\n    case 'error': {\n      callInstance.emit('playback.failed', playbackInstance)\n\n      // To resolve the ended() promise in CallPlayback\n      playbackInstance.emit('playback.failed', playbackInstance)\n\n      remove<CallPlayback>(controlId)\n      break\n    }\n    case 'finished': {\n      callInstance.emit('playback.ended', playbackInstance)\n\n      // To resolve the ended() promise in CallPlayback\n      playbackInstance.emit('playback.ended', playbackInstance)\n\n      remove<CallPlayback>(controlId)\n      break\n    }\n    default:\n      getLogger().warn(`Unknown playback state: \"${payload.state}\"`)\n      break\n  }\n\n  getLogger().trace('voiceCallPlayWorker ended')\n}\n", "import {\n  connect,\n  VoiceCallPlaybackContract,\n  CallingCallPlayEndState,\n  CallingCallPlayEventParams,\n  BaseConsumer,\n  BaseComponentOptionsWithPayload,\n  EventEmitter,\n} from '@signalwire/core'\n\n/**\n * Instances of this class allow you to control (e.g., pause, resume, stop) the\n * playback inside a Voice Call. You can obtain instances of this class by\n * starting a playback from the desired {@link Call} (see\n * {@link Call.play})\n */\nexport interface CallPlayback extends VoiceCallPlaybackContract {\n  setPayload: (payload: CallingCallPlayEventParams) => void\n  _paused: boolean\n  /** @internal */\n  emit(event: EventEmitter.EventNames<any>, ...args: any[]): void\n}\n\n// export type CallPlaybackEventsHandlerMapping = Record<\n//   VideoPlaybackEventNames,\n//   (playback: CallPlayback) => void\n// >\nexport type CallPlaybackEventsHandlerMapping = {}\n\nexport interface CallPlaybackOptions\n  extends BaseComponentOptionsWithPayload<CallingCallPlayEventParams> {}\n\nconst ENDED_STATES: CallingCallPlayEndState[] = ['finished', 'error']\n\nexport class CallPlaybackAPI\n  extends BaseConsumer<CallPlaybackEventsHandlerMapping>\n  implements VoiceCallPlaybackContract\n{\n  public _paused: boolean\n  private _volume: number\n  private _payload: CallingCallPlayEventParams\n\n  constructor(options: CallPlaybackOptions) {\n    super(options)\n\n    this._payload = options.payload\n    this._paused = false\n  }\n\n  get id() {\n    return this._payload?.control_id.split('.')[0]\n  }\n\n  get volume() {\n    return this._volume\n  }\n\n  get callId() {\n    return this._payload?.call_id\n  }\n\n  get nodeId() {\n    return this._payload?.node_id\n  }\n\n  get controlId() {\n    return this._payload?.control_id\n  }\n\n  get state() {\n    return this._payload?.state\n  }\n\n  /** @internal */\n  protected setPayload(payload: CallingCallPlayEventParams) {\n    this._payload = payload\n  }\n\n  async pause() {\n    await this.execute({\n      method: 'calling.play.pause',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    return this\n  }\n\n  async resume() {\n    await this.execute({\n      method: 'calling.play.resume',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    return this\n  }\n\n  async stop() {\n    await this.execute({\n      method: 'calling.play.stop',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    return this\n  }\n\n  async setVolume(volume: number) {\n    this._volume = volume\n\n    await this.execute({\n      method: 'calling.play.volume',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n        volume,\n      },\n    })\n\n    return this\n  }\n\n  /** @deprecated */\n  waitForEnded() {\n    return this.ended()\n  }\n\n  ended() {\n    return new Promise<this>((resolve) => {\n      const handler = () => {\n        // @ts-expect-error\n        this.off('playback.ended', handler)\n        // @ts-expect-error\n        this.off('playback.failed', handler)\n        // It's important to notice that we're returning\n        // `this` instead of creating a brand new instance\n        // using the payload + EventEmitter Transform\n        // pipeline. `this` is the instance created by the\n        // `Call` Emitter Transform pipeline (singleton per\n        // `Call.play()`) that gets auto updated (using\n        // the latest payload per event) by the\n        // `voiceCallPlayWorker`\n        resolve(this)\n      }\n      // @ts-expect-error\n      this.once('playback.ended', handler)\n      // @ts-expect-error\n      this.once('playback.failed', handler)\n\n      // Resolve the promise if the recording has already ended\n      if (ENDED_STATES.includes(this.state as CallingCallPlayEndState)) {\n        handler()\n      }\n    })\n  }\n}\n\nexport const createCallPlaybackObject = (\n  params: CallPlaybackOptions\n): CallPlayback => {\n  const playback = connect<\n    CallPlaybackEventsHandlerMapping,\n    CallPlaybackAPI,\n    CallPlayback\n  >({\n    store: params.store,\n    Component: CallPlaybackAPI,\n  })(params)\n\n  return playback\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  CallingCallRecordEventParams,\n} from '@signalwire/core'\nimport { CallRecording, createCallRecordingObject } from '../CallRecording'\nimport { Call } from '../Voice'\nimport type { VoiceCallWorkerParams } from './voiceCallingWorker'\n\nexport const voiceCallRecordWorker = function* (\n  options: VoiceCallWorkerParams<CallingCallRecordEventParams>\n): SagaIterator {\n  getLogger().trace('voiceCallRecordWorker started')\n  const {\n    payload,\n    instanceMap: { get, set, remove },\n  } = options\n\n  const callInstance = get<Call>(payload.call_id)\n  if (!callInstance) {\n    throw new Error('Missing call instance for recording')\n  }\n\n  let recordingInstance = get<CallRecording>(payload.control_id)\n  if (!recordingInstance) {\n    recordingInstance = createCallRecordingObject({\n      store: callInstance.store,\n      payload,\n    })\n  } else {\n    recordingInstance.setPayload(payload)\n  }\n  set<CallRecording>(payload.control_id, recordingInstance)\n\n  switch (payload.state) {\n    case 'recording': {\n      const type = recordingInstance._paused\n        ? 'recording.updated'\n        : 'recording.started'\n      recordingInstance._paused = false\n\n      callInstance.emit(type, recordingInstance)\n      break\n    }\n    case 'paused': {\n      recordingInstance._paused = true\n      callInstance.emit('recording.updated', recordingInstance)\n      break\n    }\n    case 'no_input':\n    case 'finished': {\n      const type =\n        payload.state === 'finished' ? 'recording.ended' : 'recording.failed'\n      callInstance.emit(type, recordingInstance)\n\n      // To resolve the ended() promise in CallRecording\n      recordingInstance.emit(type, recordingInstance)\n\n      remove<CallRecording>(payload.control_id)\n      break\n    }\n    default:\n      getLogger().warn(`Unknown recording state: \"${payload.state}\"`)\n      break\n  }\n\n  getLogger().trace('voiceCallRecordWorker ended')\n}\n", "import {\n  connect,\n  BaseComponentOptionsWithPayload,\n  VoiceCallRecordingContract,\n  CallingCallRecordEndState,\n  CallingCallRecordEventParams,\n  EventEmitter,\n  BaseConsumer,\n  CallingCallRecordPauseMethodParams,\n} from '@signalwire/core'\n\n/**\n * Instances of this class allow you to control (e.g., resume) the\n * recording inside a Voice Call. You can obtain instances of this class by\n * starting a recording from the desired {@link Call} (see\n * {@link Call.record})\n */\nexport interface CallRecording extends VoiceCallRecordingContract {\n  setPayload: (payload: CallingCallRecordEventParams) => void\n  _paused: boolean\n  /** @internal */\n  emit(event: EventEmitter.EventNames<any>, ...args: any[]): void\n}\n\nexport type CallRecordingEventsHandlerMapping = {}\n\nexport interface CallRecordingOptions\n  extends BaseComponentOptionsWithPayload<CallingCallRecordEventParams> {}\n\nconst ENDED_STATES: CallingCallRecordEndState[] = ['finished', 'no_input']\n\nexport class CallRecordingAPI\n  extends BaseConsumer<CallRecordingEventsHandlerMapping>\n  implements VoiceCallRecordingContract\n{\n  public _paused: boolean\n  private _payload: CallingCallRecordEventParams\n\n  constructor(options: CallRecordingOptions) {\n    super(options)\n\n    this._payload = options.payload\n    this._paused = false\n  }\n\n  get id() {\n    return this._payload?.control_id\n  }\n\n  get callId() {\n    return this._payload?.call_id\n  }\n\n  get nodeId() {\n    return this._payload?.node_id\n  }\n\n  get controlId() {\n    return this._payload?.control_id\n  }\n\n  get state() {\n    return this._payload?.state\n  }\n\n  get url() {\n    return this._payload?.url\n  }\n\n  get size() {\n    return this._payload?.size\n  }\n\n  get duration() {\n    return this._payload?.duration\n  }\n\n  get record() {\n    return this._payload?.record\n  }\n\n  /** @internal */\n  protected setPayload(payload: CallingCallRecordEventParams) {\n    this._payload = payload\n  }\n\n  async pause(params?: CallingCallRecordPauseMethodParams) {\n    const { behavior = 'silence' } = params || {}\n\n    await this.execute({\n      method: 'calling.record.pause',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n        behavior,\n      },\n    })\n\n    return this\n  }\n\n  async resume() {\n    await this.execute({\n      method: 'calling.record.resume',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    return this\n  }\n\n  async stop() {\n    await this.execute({\n      method: 'calling.record.stop',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    /**\n     * TODO: we should wait for the recording `finished` event to allow\n     * the CallRecording/Proxy object to update the payload properly\n     */\n\n    return this\n  }\n\n  ended() {\n    return new Promise<this>((resolve) => {\n      const handler = () => {\n        // @ts-expect-error\n        this.off('recording.ended', handler)\n        // @ts-expect-error\n        this.off('recording.failed', handler)\n        // It's important to notice that we're returning\n        // `this` instead of creating a brand new instance\n        // using the payload + EventEmitter Transform\n        // pipeline. `this` is the instance created by the\n        // `Call` Emitter Transform pipeline (singleton per\n        // `Call.record()`) that gets auto updated (using\n        // the latest payload per event) by the\n        // `voiceCallRecordWorker`\n        resolve(this)\n      }\n      // @ts-expect-error\n      this.once('recording.ended', handler)\n      // TODO: review what else to return when `recording.failed` happens.\n      // @ts-expect-error\n      this.once('recording.failed', handler)\n\n      // Resolve the promise if the recording has already ended\n      if (ENDED_STATES.includes(this.state as CallingCallRecordEndState)) {\n        handler()\n      }\n    })\n  }\n}\n\nexport const createCallRecordingObject = (\n  params: CallRecordingOptions\n): CallRecording => {\n  const record = connect<\n    CallRecordingEventsHandlerMapping,\n    CallRecordingAPI,\n    CallRecording\n  >({\n    store: params.store,\n    Component: CallRecordingAPI,\n  })(params)\n\n  return record\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  CallingCallCollectEventParams,\n} from '@signalwire/core'\nimport type { Call } from '../Call'\nimport { CallPrompt, CallPromptAPI } from '../CallPrompt'\nimport { CallCollect } from '../CallCollect'\nimport type { VoiceCallWorkerParams } from './voiceCallingWorker'\n\nexport const voiceCallCollectWorker = function* (\n  options: VoiceCallWorkerParams<CallingCallCollectEventParams>\n): SagaIterator {\n  getLogger().trace('voiceCallCollectWorker started')\n  const {\n    payload,\n    instanceMap: { get, set, remove },\n  } = options\n\n  const callInstance = get<Call>(payload.call_id)\n  if (!callInstance) {\n    throw new Error('Missing call instance for collect')\n  }\n\n  const actionInstance = get<CallPrompt | CallCollect>(payload.control_id)\n  if (!actionInstance) {\n    throw new Error('Missing the instance')\n  }\n  actionInstance.setPayload(payload)\n  set<CallPrompt | CallCollect>(payload.control_id, actionInstance)\n\n  let eventPrefix = 'collect' as 'collect' | 'prompt'\n  if (actionInstance instanceof CallPromptAPI) {\n    eventPrefix = 'prompt'\n  }\n\n  /**\n   * Only when partial_results: true\n   */\n  if (payload.final === false) {\n    callInstance.emit(`${eventPrefix}.updated`, actionInstance)\n  } else {\n    if (payload.result) {\n      switch (payload.result.type) {\n        case 'start_of_input': {\n          // @ts-expect-error\n          callInstance.emit(`${eventPrefix}.startOfInput`, actionInstance)\n          break\n        }\n        case 'no_input':\n        case 'no_match':\n        case 'error': {\n          if (payload.state !== 'collecting') {\n            callInstance.emit(`${eventPrefix}.failed`, actionInstance)\n\n            // To resolve the ended() promise in CallPrompt or CallCollect\n            actionInstance.emit(\n              `${eventPrefix}.failed` as never,\n              actionInstance\n            )\n\n            remove<CallCollect>(payload.control_id)\n          }\n          break\n        }\n        case 'speech':\n        case 'digit': {\n          if (payload.state !== 'collecting') {\n            callInstance.emit(`${eventPrefix}.ended`, actionInstance)\n            // To resolve the ended() promise in CallPrompt or CallCollect\n            actionInstance.emit(`${eventPrefix}.ended` as never, actionInstance)\n            remove<CallCollect>(payload.control_id)\n          }\n          break\n        }\n        default:\n          getLogger().warn(\n            // @ts-expect-error\n            `Unknown prompt result type: \"${payload.result.type}\"`\n          )\n          break\n      }\n    }\n  }\n\n  getLogger().trace('voiceCallCollectWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  CallingCallTapEventParams,\n} from '@signalwire/core'\nimport type { Call } from '../Call'\nimport { CallTap, createCallTapObject } from '../CallTap'\nimport type { VoiceCallWorkerParams } from './voiceCallingWorker'\n\nexport const voiceCallTapWorker = function* (\n  options: VoiceCallWorkerParams<CallingCallTapEventParams>\n): SagaIterator {\n  getLogger().trace('voiceCallTapWorker started')\n  const {\n    payload,\n    instanceMap: { get, set, remove },\n  } = options\n\n  const callInstance = get(payload.call_id) as Call\n  if (!callInstance) {\n    throw new Error('Missing call instance for tap')\n  }\n\n  let tapInstance = get(payload.control_id) as CallTap\n  if (!tapInstance) {\n    tapInstance = createCallTapObject({\n      store: callInstance.store,\n      payload,\n    })\n  } else {\n    tapInstance.setPayload(payload)\n  }\n  set(payload.control_id, tapInstance)\n\n  switch (payload.state) {\n    case 'tapping':\n      callInstance.emit('tap.started', tapInstance)\n      break\n    case 'finished':\n      callInstance.emit('tap.ended', tapInstance)\n\n      // To resolve the ended() promise in CallTap\n      tapInstance.emit('tap.ended', tapInstance)\n\n      remove<CallTap>(payload.control_id)\n      break\n    default:\n      getLogger().warn(`Unknown tap state: \"${payload.state}\"`)\n      break\n  }\n\n  getLogger().trace('voiceCallTapWorker ended')\n}\n", "import {\n  connect,\n  BaseComponentOptionsWithPayload,\n  VoiceCallTapContract,\n  CallingCallTapEndState,\n  CallingCallTapEventParams,\n  EventEmitter,\n  BaseConsumer,\n} from '@signalwire/core'\n\n/**\n * Instances of this class allow you to control (e.g., resume) the\n * tap inside a Voice Call. You can obtain instances of this class by\n * starting a Tap from the desired {@link Call} (see\n * {@link Call.tap})\n */\nexport interface CallTap extends VoiceCallTapContract {\n  setPayload: (payload: CallingCallTapEventParams) => void\n  _paused: boolean\n  /** @internal */\n  emit(event: EventEmitter.EventNames<any>, ...args: any[]): void\n}\n\nexport type CallTapEventsHandlerMapping = {}\n\nexport interface CallTapOptions\n  extends BaseComponentOptionsWithPayload<CallingCallTapEventParams> {}\n\nconst ENDED_STATES: CallingCallTapEndState[] = ['finished']\n\nexport class CallTapAPI\n  extends BaseConsumer<CallTapEventsHandlerMapping>\n  implements VoiceCallTapContract\n{\n  private _payload: CallingCallTapEventParams\n\n  constructor(options: CallTapOptions) {\n    super(options)\n\n    this._payload = options.payload\n  }\n\n  get id() {\n    return this._payload.control_id\n  }\n\n  get controlId() {\n    return this._payload.control_id\n  }\n\n  get nodeId() {\n    return this._payload.node_id\n  }\n\n  get callId() {\n    return this._payload.call_id\n  }\n\n  get state() {\n    return this._payload.state\n  }\n\n  /** @internal */\n  protected setPayload(payload: CallingCallTapEventParams) {\n    this._payload = payload\n  }\n\n  async stop() {\n    if (this.state !== 'finished') {\n      await this.execute({\n        method: 'calling.tap.stop',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          control_id: this.controlId,\n        },\n      })\n    }\n\n    return this\n  }\n\n  ended() {\n    // Resolve the promise if the tap has already ended\n    if (ENDED_STATES.includes(this.state as CallingCallTapEndState)) {\n      return Promise.resolve(this)\n    }\n\n    return new Promise<this>((resolve) => {\n      const handler = () => {\n        // @ts-expect-error\n        this.off('tap.ended', handler)\n        // It's important to notice that we're returning\n        // `this` instead of creating a brand new instance\n        // using the payload + EventEmitter Transform\n        // pipeline. `this` is the instance created by the\n        // `Call` Emitter Transform pipeline (singleton per\n        // `Call.tap()`) that gets auto updated (using\n        // the latest payload per event) by the\n        // `voiceCallTapWorker`\n        resolve(this)\n      }\n      // @ts-expect-error\n      this.once('tap.ended', handler)\n    })\n  }\n}\n\nexport const createCallTapObject = (params: CallTapOptions): CallTap => {\n  const tap = connect<CallTapEventsHandlerMapping, CallTapAPI, CallTap>({\n    store: params.store,\n    Component: CallTapAPI,\n  })(params)\n\n  return tap\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  CallingCallConnectEventParams,\n} from '@signalwire/core'\nimport { Call, createCallObject } from '../Call'\nimport type { VoiceCallWorkerParams } from './voiceCallingWorker'\n\nexport const voiceCallConnectWorker = function* (\n  options: VoiceCallWorkerParams<CallingCallConnectEventParams>\n): SagaIterator {\n  getLogger().trace('voiceCallConnectWorker started')\n  const {\n    instance: client,\n    payload,\n    instanceMap: { get, set },\n  } = options\n\n  const callInstance = get<Call>(payload.call_id)\n  if (!callInstance) {\n    throw new Error('Missing call instance for connect')\n  }\n  callInstance.setConnectPayload(payload)\n  set<Call>(payload.call_id, callInstance)\n\n  // TODO: The below events seems to be not documented in @RealTimeCallApiEvents. For now, ingoring TS issues\n\n  switch (payload.connect_state) {\n    case 'connecting': {\n      // @ts-expect-error\n      callInstance.emit('connect.connecting', callInstance)\n      break\n    }\n    case 'connected': {\n      let peerCallInstance = get<Call>(payload.peer.call_id)\n      if (!peerCallInstance) {\n        // @ts-expect-error\n        peerCallInstance = createCallObject({\n          store: client.store,\n          connectPayload: payload,\n        })\n      } else {\n        peerCallInstance.setConnectPayload(payload)\n      }\n      set<Call>(payload.peer.call_id, peerCallInstance)\n      callInstance.peer = peerCallInstance\n      peerCallInstance.peer = callInstance\n      // @ts-expect-error\n      callInstance.emit('connect.connected', peerCallInstance)\n      break\n    }\n    case 'disconnected': {\n      const peerCallInstance = get<Call>(payload.peer.call_id)\n      // @ts-expect-error\n      callInstance.emit('connect.disconnected')\n      callInstance.peer = undefined\n\n      // Add a check because peer call can be removed from the instance map throgh voiceCallStateWorker\n      if (peerCallInstance) {\n        // @ts-expect-error\n        peerCallInstance.emit('connect.disconnected')\n        peerCallInstance.peer = undefined\n      }\n      break\n    }\n    case 'failed': {\n      callInstance.peer = undefined\n      // @ts-expect-error\n      callInstance.emit('connect.failed')\n      break\n    }\n    default:\n      // @ts-expect-error\n      getLogger().warn(`Unknown connect state: \"${payload.connect_state}\"`)\n      break\n  }\n\n  callInstance.emit('call.state', callInstance)\n\n  getLogger().trace('voiceCallConnectWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  CallingCallDialEventParams,\n} from '@signalwire/core'\nimport type { Call } from '../Call'\nimport type { VoiceCallWorkerParams } from './voiceCallingWorker'\n\nexport const voiceCallDialWorker = function* (\n  options: VoiceCallWorkerParams<CallingCallDialEventParams>\n): SagaIterator {\n  getLogger().trace('voiceCallDialWorker started')\n  const {\n    instance: client,\n    payload,\n    instanceMap: { get },\n    initialState,\n  } = options\n\n  // Inbound calls do not have the tag\n  if (payload.tag && payload.tag !== initialState.tag) return\n\n  switch (payload.dial_state) {\n    case 'failed': {\n      // @ts-expect-error\n      client.emit('dial.failed', payload)\n      break\n    }\n    case 'answered': {\n      const callInstance = get<Call>(payload.call.call_id)\n      callInstance.setPayload(payload.call)\n      // @ts-expect-error\n      client.emit('dial.answered', callInstance)\n      break\n    }\n    default:\n      break\n  }\n\n  getLogger().trace('voiceCallDialWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  CallingCallSendDigitsEventParams,\n} from '@signalwire/core'\nimport type { Call } from '../Call'\nimport type { VoiceCallWorkerParams } from './voiceCallingWorker'\n\nexport const voiceCallSendDigitsWorker = function* (\n  options: VoiceCallWorkerParams<CallingCallSendDigitsEventParams>\n): SagaIterator {\n  getLogger().trace('voiceCallSendDigitsWorker started')\n  const {\n    payload,\n    instanceMap: { get },\n  } = options\n\n  const callInstance = get<Call>(payload.call_id)\n  if (!callInstance) {\n    throw new Error('Missing call instance for send digits')\n  }\n\n  switch (payload.state) {\n    case 'finished':\n      // @ts-expect-error\n      callInstance.emit('send_digits.finished', callInstance)\n      break\n    default: {\n      const error = new Error(\n        `[voiceCallSendDigitsWorker] unhandled state: '${payload.state}'`\n      )\n      // @ts-expect-error\n      callInstance.emit('send_digits.failed', error)\n      break\n    }\n  }\n\n  getLogger().trace('voiceCallSendDigitsWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  CallingCallDetectEventParams,\n} from '@signalwire/core'\nimport type { Call } from '../Call'\nimport { CallDetect, createCallDetectObject } from '../CallDetect'\nimport type { VoiceCallWorkerParams } from './voiceCallingWorker'\n\nexport const voiceCallDetectWorker = function* (\n  options: VoiceCallWorkerParams<CallingCallDetectEventParams>\n): SagaIterator {\n  getLogger().trace('voiceCallDetectWorker started')\n  const {\n    payload,\n    instanceMap: { get, set, remove },\n  } = options\n\n  const callInstance = get<Call>(payload.call_id)\n  if (!callInstance) {\n    throw new Error('Missing call instance for collect')\n  }\n\n  let detectInstance = get<CallDetect>(payload.control_id)\n  if (!detectInstance) {\n    detectInstance = createCallDetectObject({\n      store: callInstance.store,\n      payload,\n    })\n  } else {\n    detectInstance.setPayload(payload)\n  }\n  set<CallDetect>(payload.control_id, detectInstance)\n\n  const { detect } = payload\n  if (!detect) return\n\n  const { type, params } = detect\n  const { event } = params\n\n  switch (event) {\n    case 'finished':\n    case 'error': {\n      // @ts-expect-error\n      callInstance.emit('detect.ended', detectInstance)\n\n      // To resolve the ended() promise in CallDetect\n      detectInstance.emit('detect.ended', detectInstance)\n\n      remove<CallDetect>(payload.control_id)\n      return\n    }\n    default:\n      // @ts-expect-error\n      callInstance.emit('detect.updated', detectInstance)\n      break\n  }\n\n  switch (type) {\n    case 'machine':\n      if (params.beep && detectInstance.waitForBeep) {\n        // @ts-expect-error\n        callInstance.emit('detect.ended', detectInstance)\n\n        // To resolve the ended() promise in CallDetect\n        detectInstance.emit('detect.ended', detectInstance)\n      }\n      break\n    case 'digit':\n    case 'fax':\n      break\n    default:\n      getLogger().warn(`Unknown detect type: \"${type}\"`)\n      break\n  }\n\n  getLogger().trace('voiceCallDetectWorker ended')\n}\n", "import {\n  SagaIterator,\n  SDKWorker,\n  getLogger,\n  sagaEffects,\n  SDKActions,\n  VoiceCallAction,\n  SDKWorkerParams,\n  sagaHelpers,\n} from '@signalwire/core'\nimport { fork } from '@redux-saga/core/effects'\nimport type { Client } from '../../client/index'\nimport { voiceCallReceiveWorker } from './voiceCallReceiveWorker'\nimport { voiceCallPlayWorker } from './voiceCallPlayWorker'\nimport { voiceCallRecordWorker } from './voiceCallRecordWorker'\nimport { voiceCallDialWorker } from './voiceCallDialWorker'\nimport { voiceCallStateWorker } from './voiceCallStateWorker'\nimport { voiceCallCollectWorker } from './voiceCallCollectWorker'\nimport { voiceCallSendDigitsWorker } from './VoiceCallSendDigitWorker'\nimport { voiceCallDetectWorker } from './voiceCallDetectWorker'\nimport { voiceCallTapWorker } from './voiceCallTapWorker'\nimport { voiceCallConnectWorker } from './voiceCallConnectWorker'\n\nexport type VoiceCallWorkerParams<T> = Omit<\n  SDKWorkerParams<Client>,\n  'runSaga' | 'getSession' | 'payload'\n> & { payload: T }\n\nexport const voiceCallingWroker: SDKWorker<Client> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('voiceCallingWroker started')\n  const {\n    channels: { swEventChannel },\n  } = options\n\n  function* worker(action: VoiceCallAction) {\n    const { type, payload } = action\n\n    switch (type) {\n      case 'calling.call.state':\n        yield fork(voiceCallStateWorker, {\n          ...options,\n          payload,\n        })\n        break\n      case 'calling.call.dial':\n        yield fork(voiceCallDialWorker, {\n          ...options,\n          payload,\n        })\n        break\n      case 'calling.call.receive':\n        yield fork(voiceCallReceiveWorker, {\n          ...options,\n          payload,\n        })\n        break\n      case 'calling.call.play':\n        yield fork(voiceCallPlayWorker, {\n          ...options,\n          payload,\n        })\n        break\n      case 'calling.call.record':\n        yield fork(voiceCallRecordWorker, {\n          ...options,\n          payload,\n        })\n        break\n      case 'calling.call.collect':\n        yield fork(voiceCallCollectWorker, {\n          ...options,\n          payload,\n        })\n        break\n      case 'calling.call.send_digits':\n        yield fork(voiceCallSendDigitsWorker, {\n          ...options,\n          payload,\n        })\n        break\n      case 'calling.call.detect':\n        yield fork(voiceCallDetectWorker, {\n          ...options,\n          payload,\n        })\n        break\n      case 'calling.call.tap':\n        yield fork(voiceCallTapWorker, {\n          ...options,\n          payload,\n        })\n        break\n      case 'calling.call.connect':\n        yield fork(voiceCallConnectWorker, {\n          ...options,\n          payload,\n        })\n        break\n      default:\n        getLogger().warn(`Unknown call event: \"${type}\"`)\n        break\n    }\n  }\n\n  const workerCatchable = sagaHelpers.createCatchableSaga<VoiceCallAction>(\n    worker,\n    (error) => {\n      getLogger().error('Voice calling event error', error)\n    }\n  )\n\n  const isCallingEvent = (action: SDKActions) =>\n    action.type.startsWith('calling.')\n\n  while (true) {\n    const action: VoiceCallAction = yield sagaEffects.take(\n      swEventChannel,\n      isCallingEvent\n    )\n\n    yield sagaEffects.fork(workerCatchable, action)\n  }\n\n  getLogger().trace('voiceCallingWroker ended')\n}\n", "import type { UserOptions } from '@signalwire/core'\nimport { setupClient, clientConnect } from '../client/index'\nimport { createVoiceObject, Voice } from './Voice'\nimport { clientContextInterceptorsFactory } from '../common/clientContext'\n\ninterface VoiceClient extends Voice {\n  new (opts: VoiceClientOptions): this\n}\n\nexport type VoiceClientOptions = Omit<UserOptions, '_onRefreshToken'> &\n  (\n    | {\n        contexts: string[]\n      }\n    | {\n        topics: string[]\n      }\n  )\n\n/**\n * You can use instances of this class to initiate or receive calls. Please see\n * {@link VoiceClientApiEvents} for the full list of events you can subscribe to.\n *\n * @params options - {@link VoiceClientOptions}\n *\n * @example\n *\n * The following example answers any call in the \"office\" context.\n *\n * ```javascript\n * const client = new Voice.Client({\n *   project: \"<project-id>\",\n *   token: \"<api-token>\",\n *   contexts: ['office']\n * })\n *\n * client.on('call.received', async (call) => {\n *   console.log('Got call', call.from, call.to)\n *\n *   try {\n *     await call.answer()\n *     console.log('Inbound call answered')\n *   } catch (error) {\n *     console.error('Error answering inbound call', error)\n *   }\n * })\n * ```\n *\n * @example\n *\n * The following example initiates a new call.\n *\n * ```javascript\n * const client = new Voice.Client({\n *   project: \"<project-id>\",\n *   token: \"<api-token>\",\n *   contexts: ['office']\n * })\n *\n * try {\n *   const call = await client.dialPhone({\n *     from: '+YYYYYYYYYY',\n *     to: '+XXXXXXXXXX',\n *     timeout: 30,\n *   })\n * } catch (e) {\n *   console.log(\"Call not answered.\")\n * }\n * ```\n */\nconst VoiceClient = function (options?: VoiceClientOptions) {\n  const { client, store } = setupClient(options)\n\n  const voice = createVoiceObject({\n    store,\n    ...options,\n  })\n\n  const dial: Voice['dial'] = async (dialer) => {\n    await clientConnect(client)\n\n    return voice.dial(dialer)\n  }\n  const disconnect = () => client.disconnect()\n\n  const interceptors = {\n    ...clientContextInterceptorsFactory(client),\n    dial,\n    _session: client,\n    disconnect,\n  } as const\n\n  return new Proxy<Omit<Voice, 'new'>>(voice, {\n    get(target: Voice, prop: keyof Voice, receiver: any) {\n      if (prop in interceptors) {\n        // @ts-expect-error\n        return interceptors[prop]\n      }\n\n      // Always connect the underlying client if the user call a function on the Proxy\n      if (typeof target[prop] === 'function') {\n        clientConnect(client)\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n  // For consistency with other constructors we'll make TS force the use of `new`\n} as unknown as { new (options?: VoiceClientOptions): VoiceClient }\n\nexport { VoiceClient as Client }\n"],
  "mappings": "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",
  "names": []
}
