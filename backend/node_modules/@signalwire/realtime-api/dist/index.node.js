var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// ../../node_modules/@redux-saga/symbols/dist/redux-saga-symbols.cjs.js
var require_redux_saga_symbols_cjs = __commonJS({
  "../../node_modules/@redux-saga/symbols/dist/redux-saga-symbols.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var createSymbol = function createSymbol2(name) {
      return "@@redux-saga/" + name;
    };
    var CANCEL = /* @__PURE__ */ createSymbol("CANCEL_PROMISE");
    var CHANNEL_END_TYPE = /* @__PURE__ */ createSymbol("CHANNEL_END");
    var IO = /* @__PURE__ */ createSymbol("IO");
    var MATCH = /* @__PURE__ */ createSymbol("MATCH");
    var MULTICAST = /* @__PURE__ */ createSymbol("MULTICAST");
    var SAGA_ACTION = /* @__PURE__ */ createSymbol("SAGA_ACTION");
    var SELF_CANCELLATION = /* @__PURE__ */ createSymbol("SELF_CANCELLATION");
    var TASK = /* @__PURE__ */ createSymbol("TASK");
    var TASK_CANCEL = /* @__PURE__ */ createSymbol("TASK_CANCEL");
    var TERMINATE = /* @__PURE__ */ createSymbol("TERMINATE");
    var SAGA_LOCATION = /* @__PURE__ */ createSymbol("LOCATION");
    exports.CANCEL = CANCEL;
    exports.CHANNEL_END_TYPE = CHANNEL_END_TYPE;
    exports.IO = IO;
    exports.MATCH = MATCH;
    exports.MULTICAST = MULTICAST;
    exports.SAGA_ACTION = SAGA_ACTION;
    exports.SAGA_LOCATION = SAGA_LOCATION;
    exports.SELF_CANCELLATION = SELF_CANCELLATION;
    exports.TASK = TASK;
    exports.TASK_CANCEL = TASK_CANCEL;
    exports.TERMINATE = TERMINATE;
  }
});

// ../../node_modules/@babel/runtime/helpers/extends.js
var require_extends = __commonJS({
  "../../node_modules/@babel/runtime/helpers/extends.js"(exports, module2) {
    function _extends() {
      module2.exports = _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      return _extends.apply(this, arguments);
    }
    module2.exports = _extends, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/@redux-saga/is/dist/redux-saga-is.cjs.js
var require_redux_saga_is_cjs = __commonJS({
  "../../node_modules/@redux-saga/is/dist/redux-saga-is.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var symbols = require_redux_saga_symbols_cjs();
    var undef = function undef2(v) {
      return v === null || v === void 0;
    };
    var notUndef = function notUndef2(v) {
      return v !== null && v !== void 0;
    };
    var func = function func2(f) {
      return typeof f === "function";
    };
    var number = function number2(n) {
      return typeof n === "number";
    };
    var string = function string2(s) {
      return typeof s === "string";
    };
    var array = Array.isArray;
    var object = function object2(obj) {
      return obj && !array(obj) && typeof obj === "object";
    };
    var promise = function promise2(p) {
      return p && func(p.then);
    };
    var iterator = function iterator2(it) {
      return it && func(it.next) && func(it.throw);
    };
    var iterable = function iterable2(it) {
      return it && func(Symbol) ? func(it[Symbol.iterator]) : array(it);
    };
    var task = function task2(t) {
      return t && t[symbols.TASK];
    };
    var sagaAction = function sagaAction2(a) {
      return Boolean(a && a[symbols.SAGA_ACTION]);
    };
    var observable = function observable2(ob) {
      return ob && func(ob.subscribe);
    };
    var buffer = function buffer2(buf) {
      return buf && func(buf.isEmpty) && func(buf.take) && func(buf.put);
    };
    var pattern = function pattern2(pat) {
      return pat && (string(pat) || symbol(pat) || func(pat) || array(pat) && pat.every(pattern2));
    };
    var channel = function channel2(ch) {
      return ch && func(ch.take) && func(ch.close);
    };
    var stringableFunc = function stringableFunc2(f) {
      return func(f) && f.hasOwnProperty("toString");
    };
    var symbol = function symbol2(sym) {
      return Boolean(sym) && typeof Symbol === "function" && sym.constructor === Symbol && sym !== Symbol.prototype;
    };
    var multicast = function multicast2(ch) {
      return channel(ch) && ch[symbols.MULTICAST];
    };
    var effect = function effect2(eff) {
      return eff && eff[symbols.IO];
    };
    exports.array = array;
    exports.buffer = buffer;
    exports.channel = channel;
    exports.effect = effect;
    exports.func = func;
    exports.iterable = iterable;
    exports.iterator = iterator;
    exports.multicast = multicast;
    exports.notUndef = notUndef;
    exports.number = number;
    exports.object = object;
    exports.observable = observable;
    exports.pattern = pattern;
    exports.promise = promise;
    exports.sagaAction = sagaAction;
    exports.string = string;
    exports.stringableFunc = stringableFunc;
    exports.symbol = symbol;
    exports.task = task;
    exports.undef = undef;
  }
});

// ../../node_modules/@redux-saga/delay-p/dist/redux-saga-delay-p.cjs.js
var require_redux_saga_delay_p_cjs = __commonJS({
  "../../node_modules/@redux-saga/delay-p/dist/redux-saga-delay-p.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var symbols = require_redux_saga_symbols_cjs();
    var MAX_SIGNED_INT = 2147483647;
    function delayP(ms, val) {
      if (val === void 0) {
        val = true;
      }
      if (process.env.NODE_ENV !== "production" && ms > MAX_SIGNED_INT) {
        throw new Error("delay only supports a maximum value of " + MAX_SIGNED_INT + "ms");
      }
      var timeoutId;
      var promise = new Promise(function(resolve) {
        timeoutId = setTimeout(resolve, Math.min(MAX_SIGNED_INT, ms), val);
      });
      promise[symbols.CANCEL] = function() {
        clearTimeout(timeoutId);
      };
      return promise;
    }
    exports.default = delayP;
  }
});

// ../../node_modules/@redux-saga/core/dist/io-d39dbb58.js
var require_io_d39dbb58 = __commonJS({
  "../../node_modules/@redux-saga/core/dist/io-d39dbb58.js"(exports) {
    "use strict";
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var symbols = require_redux_saga_symbols_cjs();
    var _extends = _interopDefault(require_extends());
    var is = require_redux_saga_is_cjs();
    var delayP = _interopDefault(require_redux_saga_delay_p_cjs());
    var konst = function konst2(v) {
      return function() {
        return v;
      };
    };
    var kTrue = /* @__PURE__ */ konst(true);
    exports.noop = function noop() {
    };
    var identity = function identity2(v) {
      return v;
    };
    var assignWithSymbols = function assignWithSymbols2(target, source) {
      _extends(target, source);
      if (Object.getOwnPropertySymbols) {
        Object.getOwnPropertySymbols(source).forEach(function(s) {
          target[s] = source[s];
        });
      }
    };
    var flatMap = function flatMap2(mapper, arr) {
      var _ref;
      return (_ref = []).concat.apply(_ref, arr.map(mapper));
    };
    function remove(array, item) {
      var index = array.indexOf(item);
      if (index >= 0) {
        array.splice(index, 1);
      }
    }
    function once(fn) {
      var called = false;
      return function() {
        if (called) {
          return;
        }
        called = true;
        fn();
      };
    }
    var kThrow = function kThrow2(err) {
      throw err;
    };
    var kReturn = function kReturn2(value) {
      return {
        value,
        done: true
      };
    };
    function makeIterator(next, thro, name) {
      if (thro === void 0) {
        thro = kThrow;
      }
      if (name === void 0) {
        name = "iterator";
      }
      var iterator = {
        meta: {
          name
        },
        next,
        throw: thro,
        return: kReturn,
        isSagaIterator: true
      };
      if (typeof Symbol !== "undefined") {
        iterator[Symbol.iterator] = function() {
          return iterator;
        };
      }
      return iterator;
    }
    function logError(error, _ref2) {
      var sagaStack = _ref2.sagaStack;
      console.error(error);
      console.error(sagaStack);
    }
    var createEmptyArray = function createEmptyArray2(n) {
      return Array.apply(null, new Array(n));
    };
    var wrapSagaDispatch = function wrapSagaDispatch2(dispatch) {
      return function(action) {
        return dispatch(Object.defineProperty(action, symbols.SAGA_ACTION, {
          value: true
        }));
      };
    };
    var shouldTerminate = function shouldTerminate2(res) {
      return res === symbols.TERMINATE;
    };
    var shouldCancel = function shouldCancel2(res) {
      return res === symbols.TASK_CANCEL;
    };
    var shouldComplete = function shouldComplete2(res) {
      return shouldTerminate(res) || shouldCancel(res);
    };
    function createAllStyleChildCallbacks(shape, parentCallback) {
      var keys = Object.keys(shape);
      var totalCount = keys.length;
      var completedCount = 0;
      var completed;
      var results = is.array(shape) ? createEmptyArray(totalCount) : {};
      var childCallbacks = {};
      function checkEnd() {
        if (completedCount === totalCount) {
          completed = true;
          parentCallback(results);
        }
      }
      keys.forEach(function(key) {
        var chCbAtKey = function chCbAtKey2(res, isErr) {
          if (completed) {
            return;
          }
          if (isErr || shouldComplete(res)) {
            parentCallback.cancel();
            parentCallback(res, isErr);
          } else {
            results[key] = res;
            completedCount++;
            checkEnd();
          }
        };
        chCbAtKey.cancel = exports.noop;
        childCallbacks[key] = chCbAtKey;
      });
      parentCallback.cancel = function() {
        if (!completed) {
          completed = true;
          keys.forEach(function(key) {
            return childCallbacks[key].cancel();
          });
        }
      };
      return childCallbacks;
    }
    function getMetaInfo(fn) {
      return {
        name: fn.name || "anonymous",
        location: getLocation(fn)
      };
    }
    function getLocation(instrumented) {
      return instrumented[symbols.SAGA_LOCATION];
    }
    var BUFFER_OVERFLOW = "Channel's Buffer overflow!";
    var ON_OVERFLOW_THROW = 1;
    var ON_OVERFLOW_DROP = 2;
    var ON_OVERFLOW_SLIDE = 3;
    var ON_OVERFLOW_EXPAND = 4;
    var zeroBuffer = {
      isEmpty: kTrue,
      put: exports.noop,
      take: exports.noop
    };
    function ringBuffer(limit, overflowAction) {
      if (limit === void 0) {
        limit = 10;
      }
      var arr = new Array(limit);
      var length = 0;
      var pushIndex = 0;
      var popIndex = 0;
      var push = function push2(it) {
        arr[pushIndex] = it;
        pushIndex = (pushIndex + 1) % limit;
        length++;
      };
      var take2 = function take3() {
        if (length != 0) {
          var it = arr[popIndex];
          arr[popIndex] = null;
          length--;
          popIndex = (popIndex + 1) % limit;
          return it;
        }
      };
      var flush2 = function flush3() {
        var items = [];
        while (length) {
          items.push(take2());
        }
        return items;
      };
      return {
        isEmpty: function isEmpty() {
          return length == 0;
        },
        put: function put2(it) {
          if (length < limit) {
            push(it);
          } else {
            var doubledLimit;
            switch (overflowAction) {
              case ON_OVERFLOW_THROW:
                throw new Error(BUFFER_OVERFLOW);
              case ON_OVERFLOW_SLIDE:
                arr[pushIndex] = it;
                pushIndex = (pushIndex + 1) % limit;
                popIndex = pushIndex;
                break;
              case ON_OVERFLOW_EXPAND:
                doubledLimit = 2 * limit;
                arr = flush2();
                length = arr.length;
                pushIndex = arr.length;
                popIndex = 0;
                arr.length = doubledLimit;
                limit = doubledLimit;
                push(it);
                break;
              default:
            }
          }
        },
        take: take2,
        flush: flush2
      };
    }
    var none = function none2() {
      return zeroBuffer;
    };
    var fixed = function fixed2(limit) {
      return ringBuffer(limit, ON_OVERFLOW_THROW);
    };
    var dropping = function dropping2(limit) {
      return ringBuffer(limit, ON_OVERFLOW_DROP);
    };
    var sliding = function sliding2(limit) {
      return ringBuffer(limit, ON_OVERFLOW_SLIDE);
    };
    var expanding = function expanding2(initialSize) {
      return ringBuffer(initialSize, ON_OVERFLOW_EXPAND);
    };
    var buffers = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      none,
      fixed,
      dropping,
      sliding,
      expanding
    });
    var TAKE = "TAKE";
    var PUT = "PUT";
    var ALL = "ALL";
    var RACE = "RACE";
    var CALL = "CALL";
    var CPS = "CPS";
    var FORK = "FORK";
    var JOIN = "JOIN";
    var CANCEL = "CANCEL";
    var SELECT = "SELECT";
    var ACTION_CHANNEL = "ACTION_CHANNEL";
    var CANCELLED = "CANCELLED";
    var FLUSH = "FLUSH";
    var GET_CONTEXT = "GET_CONTEXT";
    var SET_CONTEXT = "SET_CONTEXT";
    var effectTypes = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      TAKE,
      PUT,
      ALL,
      RACE,
      CALL,
      CPS,
      FORK,
      JOIN,
      CANCEL,
      SELECT,
      ACTION_CHANNEL,
      CANCELLED,
      FLUSH,
      GET_CONTEXT,
      SET_CONTEXT
    });
    var makeEffect = function makeEffect2(type, payload) {
      var _ref;
      return _ref = {}, _ref[symbols.IO] = true, _ref.combinator = false, _ref.type = type, _ref.payload = payload, _ref;
    };
    var detach = function detach2(eff) {
      return makeEffect(FORK, _extends({}, eff.payload, {
        detached: true
      }));
    };
    function take(patternOrChannel, multicastPattern) {
      if (patternOrChannel === void 0) {
        patternOrChannel = "*";
      }
      if (is.pattern(patternOrChannel)) {
        if (is.notUndef(multicastPattern)) {
          console.warn("take(pattern) takes one argument but two were provided. Consider passing an array for listening to several action types");
        }
        return makeEffect(TAKE, {
          pattern: patternOrChannel
        });
      }
      if (is.multicast(patternOrChannel) && is.notUndef(multicastPattern) && is.pattern(multicastPattern)) {
        return makeEffect(TAKE, {
          channel: patternOrChannel,
          pattern: multicastPattern
        });
      }
      if (is.channel(patternOrChannel)) {
        if (is.notUndef(multicastPattern)) {
          console.warn("take(channel) takes one argument but two were provided. Second argument is ignored.");
        }
        return makeEffect(TAKE, {
          channel: patternOrChannel
        });
      }
    }
    var takeMaybe = function takeMaybe2() {
      var eff = take.apply(void 0, arguments);
      eff.payload.maybe = true;
      return eff;
    };
    function put(channel, action) {
      if (is.undef(action)) {
        action = channel;
        channel = void 0;
      }
      return makeEffect(PUT, {
        channel,
        action
      });
    }
    var putResolve = function putResolve2() {
      var eff = put.apply(void 0, arguments);
      eff.payload.resolve = true;
      return eff;
    };
    function all(effects) {
      var eff = makeEffect(ALL, effects);
      eff.combinator = true;
      return eff;
    }
    function race(effects) {
      var eff = makeEffect(RACE, effects);
      eff.combinator = true;
      return eff;
    }
    function getFnCallDescriptor(fnDescriptor, args) {
      var context = null;
      var fn;
      if (is.func(fnDescriptor)) {
        fn = fnDescriptor;
      } else {
        if (is.array(fnDescriptor)) {
          context = fnDescriptor[0];
          fn = fnDescriptor[1];
        } else {
          context = fnDescriptor.context;
          fn = fnDescriptor.fn;
        }
        if (context && is.string(fn) && is.func(context[fn])) {
          fn = context[fn];
        }
      }
      return {
        context,
        fn,
        args
      };
    }
    function call(fnDescriptor) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return makeEffect(CALL, getFnCallDescriptor(fnDescriptor, args));
    }
    function apply(context, fn, args) {
      if (args === void 0) {
        args = [];
      }
      return makeEffect(CALL, getFnCallDescriptor([context, fn], args));
    }
    function cps(fnDescriptor) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      return makeEffect(CPS, getFnCallDescriptor(fnDescriptor, args));
    }
    function fork4(fnDescriptor) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      return makeEffect(FORK, getFnCallDescriptor(fnDescriptor, args));
    }
    function spawn2(fnDescriptor) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      return detach(fork4.apply(void 0, [fnDescriptor].concat(args)));
    }
    function join(taskOrTasks) {
      return makeEffect(JOIN, taskOrTasks);
    }
    function cancel(taskOrTasks) {
      if (taskOrTasks === void 0) {
        taskOrTasks = symbols.SELF_CANCELLATION;
      }
      return makeEffect(CANCEL, taskOrTasks);
    }
    function select(selector) {
      if (selector === void 0) {
        selector = identity;
      }
      for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        args[_key5 - 1] = arguments[_key5];
      }
      return makeEffect(SELECT, {
        selector,
        args
      });
    }
    function actionChannel(pattern, buffer) {
      return makeEffect(ACTION_CHANNEL, {
        pattern,
        buffer
      });
    }
    function cancelled() {
      return makeEffect(CANCELLED, {});
    }
    function flush(channel) {
      return makeEffect(FLUSH, channel);
    }
    function getContext(prop) {
      return makeEffect(GET_CONTEXT, prop);
    }
    function setContext(props) {
      return makeEffect(SET_CONTEXT, props);
    }
    var delay = /* @__PURE__ */ call.bind(null, delayP);
    exports.ACTION_CHANNEL = ACTION_CHANNEL;
    exports.ALL = ALL;
    exports.CALL = CALL;
    exports.CANCEL = CANCEL;
    exports.CANCELLED = CANCELLED;
    exports.CPS = CPS;
    exports.FLUSH = FLUSH;
    exports.FORK = FORK;
    exports.GET_CONTEXT = GET_CONTEXT;
    exports.JOIN = JOIN;
    exports.PUT = PUT;
    exports.RACE = RACE;
    exports.SELECT = SELECT;
    exports.SET_CONTEXT = SET_CONTEXT;
    exports.TAKE = TAKE;
    exports.actionChannel = actionChannel;
    exports.all = all;
    exports.apply = apply;
    exports.assignWithSymbols = assignWithSymbols;
    exports.buffers = buffers;
    exports.call = call;
    exports.cancel = cancel;
    exports.cancelled = cancelled;
    exports.cps = cps;
    exports.createAllStyleChildCallbacks = createAllStyleChildCallbacks;
    exports.createEmptyArray = createEmptyArray;
    exports.delay = delay;
    exports.detach = detach;
    exports.effectTypes = effectTypes;
    exports.expanding = expanding;
    exports.flatMap = flatMap;
    exports.flush = flush;
    exports.fork = fork4;
    exports.getContext = getContext;
    exports.getLocation = getLocation;
    exports.getMetaInfo = getMetaInfo;
    exports.identity = identity;
    exports.join = join;
    exports.kTrue = kTrue;
    exports.logError = logError;
    exports.makeIterator = makeIterator;
    exports.none = none;
    exports.once = once;
    exports.put = put;
    exports.putResolve = putResolve;
    exports.race = race;
    exports.remove = remove;
    exports.select = select;
    exports.setContext = setContext;
    exports.shouldCancel = shouldCancel;
    exports.shouldComplete = shouldComplete;
    exports.shouldTerminate = shouldTerminate;
    exports.sliding = sliding;
    exports.spawn = spawn2;
    exports.take = take;
    exports.takeMaybe = takeMaybe;
    exports.wrapSagaDispatch = wrapSagaDispatch;
  }
});

// ../../node_modules/@redux-saga/core/dist/redux-saga-effects.prod.cjs.js
var require_redux_saga_effects_prod_cjs = __commonJS({
  "../../node_modules/@redux-saga/core/dist/redux-saga-effects.prod.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require_redux_saga_symbols_cjs();
    require_extends();
    var is = require_redux_saga_is_cjs();
    var io = require_io_d39dbb58();
    require_redux_saga_delay_p_cjs();
    var done = function done2(value) {
      return {
        done: true,
        value
      };
    };
    var qEnd = {};
    function safeName(patternOrChannel) {
      if (is.channel(patternOrChannel)) {
        return "channel";
      }
      if (is.stringableFunc(patternOrChannel)) {
        return String(patternOrChannel);
      }
      if (is.func(patternOrChannel)) {
        return patternOrChannel.name;
      }
      return String(patternOrChannel);
    }
    function fsmIterator(fsm, startState, name) {
      var stateUpdater, errorState, effect, nextState = startState;
      function next(arg, error) {
        if (nextState === qEnd) {
          return done(arg);
        }
        if (error && !errorState) {
          nextState = qEnd;
          throw error;
        } else {
          stateUpdater && stateUpdater(arg);
          var currentState = error ? fsm[errorState](error) : fsm[nextState]();
          nextState = currentState.nextState;
          effect = currentState.effect;
          stateUpdater = currentState.stateUpdater;
          errorState = currentState.errorState;
          return nextState === qEnd ? done(arg) : effect;
        }
      }
      return io.makeIterator(next, function(error) {
        return next(null, error);
      }, name);
    }
    function takeEvery(patternOrChannel, worker) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      var yTake = {
        done: false,
        value: io.take(patternOrChannel)
      };
      var yFork = function yFork2(ac) {
        return {
          done: false,
          value: io.fork.apply(void 0, [worker].concat(args, [ac]))
        };
      };
      var action, setAction = function setAction2(ac) {
        return action = ac;
      };
      return fsmIterator({
        q1: function q1() {
          return {
            nextState: "q2",
            effect: yTake,
            stateUpdater: setAction
          };
        },
        q2: function q2() {
          return {
            nextState: "q1",
            effect: yFork(action)
          };
        }
      }, "q1", "takeEvery(" + safeName(patternOrChannel) + ", " + worker.name + ")");
    }
    function takeLatest(patternOrChannel, worker) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      var yTake = {
        done: false,
        value: io.take(patternOrChannel)
      };
      var yFork = function yFork2(ac) {
        return {
          done: false,
          value: io.fork.apply(void 0, [worker].concat(args, [ac]))
        };
      };
      var yCancel = function yCancel2(task2) {
        return {
          done: false,
          value: io.cancel(task2)
        };
      };
      var task, action;
      var setTask = function setTask2(t) {
        return task = t;
      };
      var setAction = function setAction2(ac) {
        return action = ac;
      };
      return fsmIterator({
        q1: function q1() {
          return {
            nextState: "q2",
            effect: yTake,
            stateUpdater: setAction
          };
        },
        q2: function q2() {
          return task ? {
            nextState: "q3",
            effect: yCancel(task)
          } : {
            nextState: "q1",
            effect: yFork(action),
            stateUpdater: setTask
          };
        },
        q3: function q3() {
          return {
            nextState: "q1",
            effect: yFork(action),
            stateUpdater: setTask
          };
        }
      }, "q1", "takeLatest(" + safeName(patternOrChannel) + ", " + worker.name + ")");
    }
    function takeLeading(patternOrChannel, worker) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      var yTake = {
        done: false,
        value: io.take(patternOrChannel)
      };
      var yCall = function yCall2(ac) {
        return {
          done: false,
          value: io.call.apply(void 0, [worker].concat(args, [ac]))
        };
      };
      var action;
      var setAction = function setAction2(ac) {
        return action = ac;
      };
      return fsmIterator({
        q1: function q1() {
          return {
            nextState: "q2",
            effect: yTake,
            stateUpdater: setAction
          };
        },
        q2: function q2() {
          return {
            nextState: "q1",
            effect: yCall(action)
          };
        }
      }, "q1", "takeLeading(" + safeName(patternOrChannel) + ", " + worker.name + ")");
    }
    function throttle(delayLength, patternOrChannel, worker) {
      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }
      var action, channel;
      var yTake = function yTake2() {
        return {
          done: false,
          value: io.take(channel)
        };
      };
      var yFork = function yFork2(ac) {
        return {
          done: false,
          value: io.fork.apply(void 0, [worker].concat(args, [ac]))
        };
      };
      var yDelay = {
        done: false,
        value: io.delay(delayLength)
      };
      var setAction = function setAction2(ac) {
        return action = ac;
      };
      var setChannel = function setChannel2(ch) {
        return channel = ch;
      };
      var needsChannel = !is.channel(patternOrChannel);
      if (!needsChannel) {
        setChannel(patternOrChannel);
      }
      return fsmIterator({
        q1: function q1() {
          var yActionChannel = {
            done: false,
            value: io.actionChannel(patternOrChannel, io.sliding(1))
          };
          return {
            nextState: "q2",
            effect: yActionChannel,
            stateUpdater: setChannel
          };
        },
        q2: function q2() {
          return {
            nextState: "q3",
            effect: yTake(),
            stateUpdater: setAction
          };
        },
        q3: function q3() {
          return {
            nextState: "q4",
            effect: yFork(action)
          };
        },
        q4: function q4() {
          return {
            nextState: "q2",
            effect: yDelay
          };
        }
      }, needsChannel ? "q1" : "q2", "throttle(" + safeName(patternOrChannel) + ", " + worker.name + ")");
    }
    function retry(maxTries, delayLength, fn) {
      var counter = maxTries;
      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }
      var yCall = {
        done: false,
        value: io.call.apply(void 0, [fn].concat(args))
      };
      var yDelay = {
        done: false,
        value: io.delay(delayLength)
      };
      return fsmIterator({
        q1: function q1() {
          return {
            nextState: "q2",
            effect: yCall,
            errorState: "q10"
          };
        },
        q2: function q2() {
          return {
            nextState: qEnd
          };
        },
        q10: function q10(error) {
          counter -= 1;
          if (counter <= 0) {
            throw error;
          }
          return {
            nextState: "q1",
            effect: yDelay
          };
        }
      }, "q1", "retry(" + fn.name + ")");
    }
    function debounceHelper(delayLength, patternOrChannel, worker) {
      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }
      var action, raceOutput;
      var yTake = {
        done: false,
        value: io.take(patternOrChannel)
      };
      var yRace = {
        done: false,
        value: io.race({
          action: io.take(patternOrChannel),
          debounce: io.delay(delayLength)
        })
      };
      var yFork = function yFork2(ac) {
        return {
          done: false,
          value: io.fork.apply(void 0, [worker].concat(args, [ac]))
        };
      };
      var yNoop = function yNoop2(value) {
        return {
          done: false,
          value
        };
      };
      var setAction = function setAction2(ac) {
        return action = ac;
      };
      var setRaceOutput = function setRaceOutput2(ro) {
        return raceOutput = ro;
      };
      return fsmIterator({
        q1: function q1() {
          return {
            nextState: "q2",
            effect: yTake,
            stateUpdater: setAction
          };
        },
        q2: function q2() {
          return {
            nextState: "q3",
            effect: yRace,
            stateUpdater: setRaceOutput
          };
        },
        q3: function q3() {
          return raceOutput.debounce ? {
            nextState: "q1",
            effect: yFork(action)
          } : {
            nextState: "q2",
            effect: yNoop(raceOutput.action),
            stateUpdater: setAction
          };
        }
      }, "q1", "debounce(" + safeName(patternOrChannel) + ", " + worker.name + ")");
    }
    function takeEvery$1(patternOrChannel, worker) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      return io.fork.apply(void 0, [takeEvery, patternOrChannel, worker].concat(args));
    }
    function takeLatest$1(patternOrChannel, worker) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }
      return io.fork.apply(void 0, [takeLatest, patternOrChannel, worker].concat(args));
    }
    function takeLeading$1(patternOrChannel, worker) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        args[_key3 - 2] = arguments[_key3];
      }
      return io.fork.apply(void 0, [takeLeading, patternOrChannel, worker].concat(args));
    }
    function throttle$1(ms, patternOrChannel, worker) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {
        args[_key4 - 3] = arguments[_key4];
      }
      return io.fork.apply(void 0, [throttle, ms, patternOrChannel, worker].concat(args));
    }
    function retry$1(maxTries, delayLength, worker) {
      for (var _len5 = arguments.length, args = new Array(_len5 > 3 ? _len5 - 3 : 0), _key5 = 3; _key5 < _len5; _key5++) {
        args[_key5 - 3] = arguments[_key5];
      }
      return io.call.apply(void 0, [retry, maxTries, delayLength, worker].concat(args));
    }
    function debounce3(delayLength, pattern, worker) {
      for (var _len6 = arguments.length, args = new Array(_len6 > 3 ? _len6 - 3 : 0), _key6 = 3; _key6 < _len6; _key6++) {
        args[_key6 - 3] = arguments[_key6];
      }
      return io.fork.apply(void 0, [debounceHelper, delayLength, pattern, worker].concat(args));
    }
    exports.actionChannel = io.actionChannel;
    exports.all = io.all;
    exports.apply = io.apply;
    exports.call = io.call;
    exports.cancel = io.cancel;
    exports.cancelled = io.cancelled;
    exports.cps = io.cps;
    exports.delay = io.delay;
    exports.effectTypes = io.effectTypes;
    exports.flush = io.flush;
    exports.fork = io.fork;
    exports.getContext = io.getContext;
    exports.join = io.join;
    exports.put = io.put;
    exports.putResolve = io.putResolve;
    exports.race = io.race;
    exports.select = io.select;
    exports.setContext = io.setContext;
    exports.spawn = io.spawn;
    exports.take = io.take;
    exports.takeMaybe = io.takeMaybe;
    exports.debounce = debounce3;
    exports.retry = retry$1;
    exports.takeEvery = takeEvery$1;
    exports.takeLatest = takeLatest$1;
    exports.takeLeading = takeLeading$1;
    exports.throttle = throttle$1;
  }
});

// ../../node_modules/@redux-saga/core/dist/io-a03c6210.js
var require_io_a03c6210 = __commonJS({
  "../../node_modules/@redux-saga/core/dist/io-a03c6210.js"(exports) {
    "use strict";
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var symbols = require_redux_saga_symbols_cjs();
    var _extends = _interopDefault(require_extends());
    var is = require_redux_saga_is_cjs();
    var delayP = _interopDefault(require_redux_saga_delay_p_cjs());
    var konst = function konst2(v) {
      return function() {
        return v;
      };
    };
    var kTrue = /* @__PURE__ */ konst(true);
    exports.noop = function noop() {
    };
    if (typeof Proxy !== "undefined") {
      exports.noop = /* @__PURE__ */ new Proxy(exports.noop, {
        set: function set() {
          throw internalErr("There was an attempt to assign a property to internal `noop` function.");
        }
      });
    }
    var identity = function identity2(v) {
      return v;
    };
    var hasSymbol = typeof Symbol === "function";
    var asyncIteratorSymbol = hasSymbol && Symbol.asyncIterator ? Symbol.asyncIterator : "@@asyncIterator";
    function check(value, predicate, error) {
      if (!predicate(value)) {
        throw new Error(error);
      }
    }
    var assignWithSymbols = function assignWithSymbols2(target, source) {
      _extends(target, source);
      if (Object.getOwnPropertySymbols) {
        Object.getOwnPropertySymbols(source).forEach(function(s) {
          target[s] = source[s];
        });
      }
    };
    var flatMap = function flatMap2(mapper, arr) {
      var _ref;
      return (_ref = []).concat.apply(_ref, arr.map(mapper));
    };
    function remove(array, item) {
      var index = array.indexOf(item);
      if (index >= 0) {
        array.splice(index, 1);
      }
    }
    function once(fn) {
      var called = false;
      return function() {
        if (called) {
          return;
        }
        called = true;
        fn();
      };
    }
    var kThrow = function kThrow2(err) {
      throw err;
    };
    var kReturn = function kReturn2(value) {
      return {
        value,
        done: true
      };
    };
    function makeIterator(next, thro, name) {
      if (thro === void 0) {
        thro = kThrow;
      }
      if (name === void 0) {
        name = "iterator";
      }
      var iterator = {
        meta: {
          name
        },
        next,
        throw: thro,
        return: kReturn,
        isSagaIterator: true
      };
      if (typeof Symbol !== "undefined") {
        iterator[Symbol.iterator] = function() {
          return iterator;
        };
      }
      return iterator;
    }
    function logError(error, _ref2) {
      var sagaStack = _ref2.sagaStack;
      console.error(error);
      console.error(sagaStack);
    }
    var internalErr = function internalErr2(err) {
      return new Error("\n  redux-saga: Error checking hooks detected an inconsistent state. This is likely a bug\n  in redux-saga code and not yours. Thanks for reporting this in the project's github repo.\n  Error: " + err + "\n");
    };
    var createSetContextWarning = function createSetContextWarning2(ctx, props) {
      return (ctx ? ctx + "." : "") + "setContext(props): argument " + props + " is not a plain object";
    };
    var FROZEN_ACTION_ERROR = "You can't put (a.k.a. dispatch from saga) frozen actions.\nWe have to define a special non-enumerable property on those actions for scheduling purposes.\nOtherwise you wouldn't be able to communicate properly between sagas & other subscribers (action ordering would become far less predictable).\nIf you are using redux and you care about this behaviour (frozen actions),\nthen you might want to switch to freezing actions in a middleware rather than in action creator.\nExample implementation:\n\nconst freezeActions = store => next => action => next(Object.freeze(action))\n";
    var createEmptyArray = function createEmptyArray2(n) {
      return Array.apply(null, new Array(n));
    };
    var wrapSagaDispatch = function wrapSagaDispatch2(dispatch) {
      return function(action) {
        {
          check(action, function(ac) {
            return !Object.isFrozen(ac);
          }, FROZEN_ACTION_ERROR);
        }
        return dispatch(Object.defineProperty(action, symbols.SAGA_ACTION, {
          value: true
        }));
      };
    };
    var shouldTerminate = function shouldTerminate2(res) {
      return res === symbols.TERMINATE;
    };
    var shouldCancel = function shouldCancel2(res) {
      return res === symbols.TASK_CANCEL;
    };
    var shouldComplete = function shouldComplete2(res) {
      return shouldTerminate(res) || shouldCancel(res);
    };
    function createAllStyleChildCallbacks(shape, parentCallback) {
      var keys = Object.keys(shape);
      var totalCount = keys.length;
      {
        check(totalCount, function(c) {
          return c > 0;
        }, "createAllStyleChildCallbacks: get an empty array or object");
      }
      var completedCount = 0;
      var completed;
      var results = is.array(shape) ? createEmptyArray(totalCount) : {};
      var childCallbacks = {};
      function checkEnd() {
        if (completedCount === totalCount) {
          completed = true;
          parentCallback(results);
        }
      }
      keys.forEach(function(key) {
        var chCbAtKey = function chCbAtKey2(res, isErr) {
          if (completed) {
            return;
          }
          if (isErr || shouldComplete(res)) {
            parentCallback.cancel();
            parentCallback(res, isErr);
          } else {
            results[key] = res;
            completedCount++;
            checkEnd();
          }
        };
        chCbAtKey.cancel = exports.noop;
        childCallbacks[key] = chCbAtKey;
      });
      parentCallback.cancel = function() {
        if (!completed) {
          completed = true;
          keys.forEach(function(key) {
            return childCallbacks[key].cancel();
          });
        }
      };
      return childCallbacks;
    }
    function getMetaInfo(fn) {
      return {
        name: fn.name || "anonymous",
        location: getLocation(fn)
      };
    }
    function getLocation(instrumented) {
      return instrumented[symbols.SAGA_LOCATION];
    }
    var BUFFER_OVERFLOW = "Channel's Buffer overflow!";
    var ON_OVERFLOW_THROW = 1;
    var ON_OVERFLOW_DROP = 2;
    var ON_OVERFLOW_SLIDE = 3;
    var ON_OVERFLOW_EXPAND = 4;
    var zeroBuffer = {
      isEmpty: kTrue,
      put: exports.noop,
      take: exports.noop
    };
    function ringBuffer(limit, overflowAction) {
      if (limit === void 0) {
        limit = 10;
      }
      var arr = new Array(limit);
      var length = 0;
      var pushIndex = 0;
      var popIndex = 0;
      var push = function push2(it) {
        arr[pushIndex] = it;
        pushIndex = (pushIndex + 1) % limit;
        length++;
      };
      var take2 = function take3() {
        if (length != 0) {
          var it = arr[popIndex];
          arr[popIndex] = null;
          length--;
          popIndex = (popIndex + 1) % limit;
          return it;
        }
      };
      var flush2 = function flush3() {
        var items = [];
        while (length) {
          items.push(take2());
        }
        return items;
      };
      return {
        isEmpty: function isEmpty() {
          return length == 0;
        },
        put: function put2(it) {
          if (length < limit) {
            push(it);
          } else {
            var doubledLimit;
            switch (overflowAction) {
              case ON_OVERFLOW_THROW:
                throw new Error(BUFFER_OVERFLOW);
              case ON_OVERFLOW_SLIDE:
                arr[pushIndex] = it;
                pushIndex = (pushIndex + 1) % limit;
                popIndex = pushIndex;
                break;
              case ON_OVERFLOW_EXPAND:
                doubledLimit = 2 * limit;
                arr = flush2();
                length = arr.length;
                pushIndex = arr.length;
                popIndex = 0;
                arr.length = doubledLimit;
                limit = doubledLimit;
                push(it);
                break;
              default:
            }
          }
        },
        take: take2,
        flush: flush2
      };
    }
    var none = function none2() {
      return zeroBuffer;
    };
    var fixed = function fixed2(limit) {
      return ringBuffer(limit, ON_OVERFLOW_THROW);
    };
    var dropping = function dropping2(limit) {
      return ringBuffer(limit, ON_OVERFLOW_DROP);
    };
    var sliding = function sliding2(limit) {
      return ringBuffer(limit, ON_OVERFLOW_SLIDE);
    };
    var expanding = function expanding2(initialSize) {
      return ringBuffer(initialSize, ON_OVERFLOW_EXPAND);
    };
    var buffers = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      none,
      fixed,
      dropping,
      sliding,
      expanding
    });
    var TAKE = "TAKE";
    var PUT = "PUT";
    var ALL = "ALL";
    var RACE = "RACE";
    var CALL = "CALL";
    var CPS = "CPS";
    var FORK = "FORK";
    var JOIN = "JOIN";
    var CANCEL = "CANCEL";
    var SELECT = "SELECT";
    var ACTION_CHANNEL = "ACTION_CHANNEL";
    var CANCELLED = "CANCELLED";
    var FLUSH = "FLUSH";
    var GET_CONTEXT = "GET_CONTEXT";
    var SET_CONTEXT = "SET_CONTEXT";
    var effectTypes = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      TAKE,
      PUT,
      ALL,
      RACE,
      CALL,
      CPS,
      FORK,
      JOIN,
      CANCEL,
      SELECT,
      ACTION_CHANNEL,
      CANCELLED,
      FLUSH,
      GET_CONTEXT,
      SET_CONTEXT
    });
    var TEST_HINT = "\n(HINT: if you are getting these errors in tests, consider using createMockTask from @redux-saga/testing-utils)";
    var makeEffect = function makeEffect2(type, payload) {
      var _ref;
      return _ref = {}, _ref[symbols.IO] = true, _ref.combinator = false, _ref.type = type, _ref.payload = payload, _ref;
    };
    var isForkEffect = function isForkEffect2(eff) {
      return is.effect(eff) && eff.type === FORK;
    };
    var detach = function detach2(eff) {
      {
        check(eff, isForkEffect, "detach(eff): argument must be a fork effect");
      }
      return makeEffect(FORK, _extends({}, eff.payload, {
        detached: true
      }));
    };
    function take(patternOrChannel, multicastPattern) {
      if (patternOrChannel === void 0) {
        patternOrChannel = "*";
      }
      if (arguments.length) {
        check(arguments[0], is.notUndef, "take(patternOrChannel): patternOrChannel is undefined");
      }
      if (is.pattern(patternOrChannel)) {
        if (is.notUndef(multicastPattern)) {
          console.warn("take(pattern) takes one argument but two were provided. Consider passing an array for listening to several action types");
        }
        return makeEffect(TAKE, {
          pattern: patternOrChannel
        });
      }
      if (is.multicast(patternOrChannel) && is.notUndef(multicastPattern) && is.pattern(multicastPattern)) {
        return makeEffect(TAKE, {
          channel: patternOrChannel,
          pattern: multicastPattern
        });
      }
      if (is.channel(patternOrChannel)) {
        if (is.notUndef(multicastPattern)) {
          console.warn("take(channel) takes one argument but two were provided. Second argument is ignored.");
        }
        return makeEffect(TAKE, {
          channel: patternOrChannel
        });
      }
      {
        throw new Error("take(patternOrChannel): argument " + patternOrChannel + " is not valid channel or a valid pattern");
      }
    }
    var takeMaybe = function takeMaybe2() {
      var eff = take.apply(void 0, arguments);
      eff.payload.maybe = true;
      return eff;
    };
    function put(channel, action) {
      {
        if (arguments.length > 1) {
          check(channel, is.notUndef, "put(channel, action): argument channel is undefined");
          check(channel, is.channel, "put(channel, action): argument " + channel + " is not a valid channel");
          check(action, is.notUndef, "put(channel, action): argument action is undefined");
        } else {
          check(channel, is.notUndef, "put(action): argument action is undefined");
        }
      }
      if (is.undef(action)) {
        action = channel;
        channel = void 0;
      }
      return makeEffect(PUT, {
        channel,
        action
      });
    }
    var putResolve = function putResolve2() {
      var eff = put.apply(void 0, arguments);
      eff.payload.resolve = true;
      return eff;
    };
    function all(effects) {
      var eff = makeEffect(ALL, effects);
      eff.combinator = true;
      return eff;
    }
    function race(effects) {
      var eff = makeEffect(RACE, effects);
      eff.combinator = true;
      return eff;
    }
    var validateFnDescriptor = function validateFnDescriptor2(effectName, fnDescriptor) {
      check(fnDescriptor, is.notUndef, effectName + ": argument fn is undefined or null");
      if (is.func(fnDescriptor)) {
        return;
      }
      var context = null;
      var fn;
      if (is.array(fnDescriptor)) {
        context = fnDescriptor[0];
        fn = fnDescriptor[1];
        check(fn, is.notUndef, effectName + ": argument of type [context, fn] has undefined or null `fn`");
      } else if (is.object(fnDescriptor)) {
        context = fnDescriptor.context;
        fn = fnDescriptor.fn;
        check(fn, is.notUndef, effectName + ": argument of type {context, fn} has undefined or null `fn`");
      } else {
        check(fnDescriptor, is.func, effectName + ": argument fn is not function");
        return;
      }
      if (context && is.string(fn)) {
        check(context[fn], is.func, effectName + ': context arguments has no such method - "' + fn + '"');
        return;
      }
      check(fn, is.func, effectName + ": unpacked fn argument (from [context, fn] or {context, fn}) is not a function");
    };
    function getFnCallDescriptor(fnDescriptor, args) {
      var context = null;
      var fn;
      if (is.func(fnDescriptor)) {
        fn = fnDescriptor;
      } else {
        if (is.array(fnDescriptor)) {
          context = fnDescriptor[0];
          fn = fnDescriptor[1];
        } else {
          context = fnDescriptor.context;
          fn = fnDescriptor.fn;
        }
        if (context && is.string(fn) && is.func(context[fn])) {
          fn = context[fn];
        }
      }
      return {
        context,
        fn,
        args
      };
    }
    var isNotDelayEffect = function isNotDelayEffect2(fn) {
      return fn !== delay;
    };
    function call(fnDescriptor) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      {
        var arg0 = typeof args[0] === "number" ? args[0] : "ms";
        check(fnDescriptor, isNotDelayEffect, "instead of writing `yield call(delay, " + arg0 + ")` where delay is an effect from `redux-saga/effects` you should write `yield delay(" + arg0 + ")`");
        validateFnDescriptor("call", fnDescriptor);
      }
      return makeEffect(CALL, getFnCallDescriptor(fnDescriptor, args));
    }
    function apply(context, fn, args) {
      if (args === void 0) {
        args = [];
      }
      var fnDescriptor = [context, fn];
      {
        validateFnDescriptor("apply", fnDescriptor);
      }
      return makeEffect(CALL, getFnCallDescriptor([context, fn], args));
    }
    function cps(fnDescriptor) {
      {
        validateFnDescriptor("cps", fnDescriptor);
      }
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      return makeEffect(CPS, getFnCallDescriptor(fnDescriptor, args));
    }
    function fork4(fnDescriptor) {
      {
        validateFnDescriptor("fork", fnDescriptor);
        check(fnDescriptor, function(arg) {
          return !is.effect(arg);
        }, "fork: argument must not be an effect");
      }
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      return makeEffect(FORK, getFnCallDescriptor(fnDescriptor, args));
    }
    function spawn2(fnDescriptor) {
      {
        validateFnDescriptor("spawn", fnDescriptor);
      }
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      return detach(fork4.apply(void 0, [fnDescriptor].concat(args)));
    }
    function join(taskOrTasks) {
      {
        if (arguments.length > 1) {
          throw new Error("join(...tasks) is not supported any more. Please use join([...tasks]) to join multiple tasks.");
        }
        if (is.array(taskOrTasks)) {
          taskOrTasks.forEach(function(t) {
            check(t, is.task, "join([...tasks]): argument " + t + " is not a valid Task object " + TEST_HINT);
          });
        } else {
          check(taskOrTasks, is.task, "join(task): argument " + taskOrTasks + " is not a valid Task object " + TEST_HINT);
        }
      }
      return makeEffect(JOIN, taskOrTasks);
    }
    function cancel(taskOrTasks) {
      if (taskOrTasks === void 0) {
        taskOrTasks = symbols.SELF_CANCELLATION;
      }
      {
        if (arguments.length > 1) {
          throw new Error("cancel(...tasks) is not supported any more. Please use cancel([...tasks]) to cancel multiple tasks.");
        }
        if (is.array(taskOrTasks)) {
          taskOrTasks.forEach(function(t) {
            check(t, is.task, "cancel([...tasks]): argument " + t + " is not a valid Task object " + TEST_HINT);
          });
        } else if (taskOrTasks !== symbols.SELF_CANCELLATION && is.notUndef(taskOrTasks)) {
          check(taskOrTasks, is.task, "cancel(task): argument " + taskOrTasks + " is not a valid Task object " + TEST_HINT);
        }
      }
      return makeEffect(CANCEL, taskOrTasks);
    }
    function select(selector) {
      if (selector === void 0) {
        selector = identity;
      }
      for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        args[_key5 - 1] = arguments[_key5];
      }
      if (arguments.length) {
        check(arguments[0], is.notUndef, "select(selector, [...]): argument selector is undefined");
        check(selector, is.func, "select(selector, [...]): argument " + selector + " is not a function");
      }
      return makeEffect(SELECT, {
        selector,
        args
      });
    }
    function actionChannel(pattern, buffer) {
      {
        check(pattern, is.pattern, "actionChannel(pattern,...): argument pattern is not valid");
        if (arguments.length > 1) {
          check(buffer, is.notUndef, "actionChannel(pattern, buffer): argument buffer is undefined");
          check(buffer, is.buffer, "actionChannel(pattern, buffer): argument " + buffer + " is not a valid buffer");
        }
      }
      return makeEffect(ACTION_CHANNEL, {
        pattern,
        buffer
      });
    }
    function cancelled() {
      return makeEffect(CANCELLED, {});
    }
    function flush(channel) {
      {
        check(channel, is.channel, "flush(channel): argument " + channel + " is not valid channel");
      }
      return makeEffect(FLUSH, channel);
    }
    function getContext(prop) {
      {
        check(prop, is.string, "getContext(prop): argument " + prop + " is not a string");
      }
      return makeEffect(GET_CONTEXT, prop);
    }
    function setContext(props) {
      {
        check(props, is.object, createSetContextWarning(null, props));
      }
      return makeEffect(SET_CONTEXT, props);
    }
    var delay = /* @__PURE__ */ call.bind(null, delayP);
    exports.ACTION_CHANNEL = ACTION_CHANNEL;
    exports.ALL = ALL;
    exports.CALL = CALL;
    exports.CANCEL = CANCEL;
    exports.CANCELLED = CANCELLED;
    exports.CPS = CPS;
    exports.FLUSH = FLUSH;
    exports.FORK = FORK;
    exports.GET_CONTEXT = GET_CONTEXT;
    exports.JOIN = JOIN;
    exports.PUT = PUT;
    exports.RACE = RACE;
    exports.SELECT = SELECT;
    exports.SET_CONTEXT = SET_CONTEXT;
    exports.TAKE = TAKE;
    exports.actionChannel = actionChannel;
    exports.all = all;
    exports.apply = apply;
    exports.assignWithSymbols = assignWithSymbols;
    exports.asyncIteratorSymbol = asyncIteratorSymbol;
    exports.buffers = buffers;
    exports.call = call;
    exports.cancel = cancel;
    exports.cancelled = cancelled;
    exports.check = check;
    exports.cps = cps;
    exports.createAllStyleChildCallbacks = createAllStyleChildCallbacks;
    exports.createEmptyArray = createEmptyArray;
    exports.createSetContextWarning = createSetContextWarning;
    exports.delay = delay;
    exports.detach = detach;
    exports.effectTypes = effectTypes;
    exports.expanding = expanding;
    exports.flatMap = flatMap;
    exports.flush = flush;
    exports.fork = fork4;
    exports.getContext = getContext;
    exports.getLocation = getLocation;
    exports.getMetaInfo = getMetaInfo;
    exports.identity = identity;
    exports.internalErr = internalErr;
    exports.join = join;
    exports.kTrue = kTrue;
    exports.logError = logError;
    exports.makeIterator = makeIterator;
    exports.none = none;
    exports.once = once;
    exports.put = put;
    exports.putResolve = putResolve;
    exports.race = race;
    exports.remove = remove;
    exports.select = select;
    exports.setContext = setContext;
    exports.shouldCancel = shouldCancel;
    exports.shouldComplete = shouldComplete;
    exports.shouldTerminate = shouldTerminate;
    exports.sliding = sliding;
    exports.spawn = spawn2;
    exports.take = take;
    exports.takeMaybe = takeMaybe;
    exports.wrapSagaDispatch = wrapSagaDispatch;
  }
});

// ../../node_modules/@redux-saga/core/dist/redux-saga-effects.dev.cjs.js
var require_redux_saga_effects_dev_cjs = __commonJS({
  "../../node_modules/@redux-saga/core/dist/redux-saga-effects.dev.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require_redux_saga_symbols_cjs();
    require_extends();
    var is = require_redux_saga_is_cjs();
    var io = require_io_a03c6210();
    require_redux_saga_delay_p_cjs();
    var done = function done2(value) {
      return {
        done: true,
        value
      };
    };
    var qEnd = {};
    function safeName(patternOrChannel) {
      if (is.channel(patternOrChannel)) {
        return "channel";
      }
      if (is.stringableFunc(patternOrChannel)) {
        return String(patternOrChannel);
      }
      if (is.func(patternOrChannel)) {
        return patternOrChannel.name;
      }
      return String(patternOrChannel);
    }
    function fsmIterator(fsm, startState, name) {
      var stateUpdater, errorState, effect, nextState = startState;
      function next(arg, error) {
        if (nextState === qEnd) {
          return done(arg);
        }
        if (error && !errorState) {
          nextState = qEnd;
          throw error;
        } else {
          stateUpdater && stateUpdater(arg);
          var currentState = error ? fsm[errorState](error) : fsm[nextState]();
          nextState = currentState.nextState;
          effect = currentState.effect;
          stateUpdater = currentState.stateUpdater;
          errorState = currentState.errorState;
          return nextState === qEnd ? done(arg) : effect;
        }
      }
      return io.makeIterator(next, function(error) {
        return next(null, error);
      }, name);
    }
    function takeEvery(patternOrChannel, worker) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      var yTake = {
        done: false,
        value: io.take(patternOrChannel)
      };
      var yFork = function yFork2(ac) {
        return {
          done: false,
          value: io.fork.apply(void 0, [worker].concat(args, [ac]))
        };
      };
      var action, setAction = function setAction2(ac) {
        return action = ac;
      };
      return fsmIterator({
        q1: function q1() {
          return {
            nextState: "q2",
            effect: yTake,
            stateUpdater: setAction
          };
        },
        q2: function q2() {
          return {
            nextState: "q1",
            effect: yFork(action)
          };
        }
      }, "q1", "takeEvery(" + safeName(patternOrChannel) + ", " + worker.name + ")");
    }
    function takeLatest(patternOrChannel, worker) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      var yTake = {
        done: false,
        value: io.take(patternOrChannel)
      };
      var yFork = function yFork2(ac) {
        return {
          done: false,
          value: io.fork.apply(void 0, [worker].concat(args, [ac]))
        };
      };
      var yCancel = function yCancel2(task2) {
        return {
          done: false,
          value: io.cancel(task2)
        };
      };
      var task, action;
      var setTask = function setTask2(t) {
        return task = t;
      };
      var setAction = function setAction2(ac) {
        return action = ac;
      };
      return fsmIterator({
        q1: function q1() {
          return {
            nextState: "q2",
            effect: yTake,
            stateUpdater: setAction
          };
        },
        q2: function q2() {
          return task ? {
            nextState: "q3",
            effect: yCancel(task)
          } : {
            nextState: "q1",
            effect: yFork(action),
            stateUpdater: setTask
          };
        },
        q3: function q3() {
          return {
            nextState: "q1",
            effect: yFork(action),
            stateUpdater: setTask
          };
        }
      }, "q1", "takeLatest(" + safeName(patternOrChannel) + ", " + worker.name + ")");
    }
    function takeLeading(patternOrChannel, worker) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      var yTake = {
        done: false,
        value: io.take(patternOrChannel)
      };
      var yCall = function yCall2(ac) {
        return {
          done: false,
          value: io.call.apply(void 0, [worker].concat(args, [ac]))
        };
      };
      var action;
      var setAction = function setAction2(ac) {
        return action = ac;
      };
      return fsmIterator({
        q1: function q1() {
          return {
            nextState: "q2",
            effect: yTake,
            stateUpdater: setAction
          };
        },
        q2: function q2() {
          return {
            nextState: "q1",
            effect: yCall(action)
          };
        }
      }, "q1", "takeLeading(" + safeName(patternOrChannel) + ", " + worker.name + ")");
    }
    function throttle(delayLength, patternOrChannel, worker) {
      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }
      var action, channel;
      var yTake = function yTake2() {
        return {
          done: false,
          value: io.take(channel)
        };
      };
      var yFork = function yFork2(ac) {
        return {
          done: false,
          value: io.fork.apply(void 0, [worker].concat(args, [ac]))
        };
      };
      var yDelay = {
        done: false,
        value: io.delay(delayLength)
      };
      var setAction = function setAction2(ac) {
        return action = ac;
      };
      var setChannel = function setChannel2(ch) {
        return channel = ch;
      };
      var needsChannel = !is.channel(patternOrChannel);
      if (!needsChannel) {
        setChannel(patternOrChannel);
      }
      return fsmIterator({
        q1: function q1() {
          var yActionChannel = {
            done: false,
            value: io.actionChannel(patternOrChannel, io.sliding(1))
          };
          return {
            nextState: "q2",
            effect: yActionChannel,
            stateUpdater: setChannel
          };
        },
        q2: function q2() {
          return {
            nextState: "q3",
            effect: yTake(),
            stateUpdater: setAction
          };
        },
        q3: function q3() {
          return {
            nextState: "q4",
            effect: yFork(action)
          };
        },
        q4: function q4() {
          return {
            nextState: "q2",
            effect: yDelay
          };
        }
      }, needsChannel ? "q1" : "q2", "throttle(" + safeName(patternOrChannel) + ", " + worker.name + ")");
    }
    function retry(maxTries, delayLength, fn) {
      var counter = maxTries;
      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }
      var yCall = {
        done: false,
        value: io.call.apply(void 0, [fn].concat(args))
      };
      var yDelay = {
        done: false,
        value: io.delay(delayLength)
      };
      return fsmIterator({
        q1: function q1() {
          return {
            nextState: "q2",
            effect: yCall,
            errorState: "q10"
          };
        },
        q2: function q2() {
          return {
            nextState: qEnd
          };
        },
        q10: function q10(error) {
          counter -= 1;
          if (counter <= 0) {
            throw error;
          }
          return {
            nextState: "q1",
            effect: yDelay
          };
        }
      }, "q1", "retry(" + fn.name + ")");
    }
    function debounceHelper(delayLength, patternOrChannel, worker) {
      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }
      var action, raceOutput;
      var yTake = {
        done: false,
        value: io.take(patternOrChannel)
      };
      var yRace = {
        done: false,
        value: io.race({
          action: io.take(patternOrChannel),
          debounce: io.delay(delayLength)
        })
      };
      var yFork = function yFork2(ac) {
        return {
          done: false,
          value: io.fork.apply(void 0, [worker].concat(args, [ac]))
        };
      };
      var yNoop = function yNoop2(value) {
        return {
          done: false,
          value
        };
      };
      var setAction = function setAction2(ac) {
        return action = ac;
      };
      var setRaceOutput = function setRaceOutput2(ro) {
        return raceOutput = ro;
      };
      return fsmIterator({
        q1: function q1() {
          return {
            nextState: "q2",
            effect: yTake,
            stateUpdater: setAction
          };
        },
        q2: function q2() {
          return {
            nextState: "q3",
            effect: yRace,
            stateUpdater: setRaceOutput
          };
        },
        q3: function q3() {
          return raceOutput.debounce ? {
            nextState: "q1",
            effect: yFork(action)
          } : {
            nextState: "q2",
            effect: yNoop(raceOutput.action),
            stateUpdater: setAction
          };
        }
      }, "q1", "debounce(" + safeName(patternOrChannel) + ", " + worker.name + ")");
    }
    var validateTakeEffect = function validateTakeEffect2(fn, patternOrChannel, worker) {
      io.check(patternOrChannel, is.notUndef, fn.name + " requires a pattern or channel");
      io.check(worker, is.notUndef, fn.name + " requires a saga parameter");
    };
    function takeEvery$1(patternOrChannel, worker) {
      {
        validateTakeEffect(takeEvery$1, patternOrChannel, worker);
      }
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      return io.fork.apply(void 0, [takeEvery, patternOrChannel, worker].concat(args));
    }
    function takeLatest$1(patternOrChannel, worker) {
      {
        validateTakeEffect(takeLatest$1, patternOrChannel, worker);
      }
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }
      return io.fork.apply(void 0, [takeLatest, patternOrChannel, worker].concat(args));
    }
    function takeLeading$1(patternOrChannel, worker) {
      {
        validateTakeEffect(takeLeading$1, patternOrChannel, worker);
      }
      for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        args[_key3 - 2] = arguments[_key3];
      }
      return io.fork.apply(void 0, [takeLeading, patternOrChannel, worker].concat(args));
    }
    function throttle$1(ms, patternOrChannel, worker) {
      {
        io.check(patternOrChannel, is.notUndef, "throttle requires a pattern or channel");
        io.check(worker, is.notUndef, "throttle requires a saga parameter");
      }
      for (var _len4 = arguments.length, args = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {
        args[_key4 - 3] = arguments[_key4];
      }
      return io.fork.apply(void 0, [throttle, ms, patternOrChannel, worker].concat(args));
    }
    function retry$1(maxTries, delayLength, worker) {
      for (var _len5 = arguments.length, args = new Array(_len5 > 3 ? _len5 - 3 : 0), _key5 = 3; _key5 < _len5; _key5++) {
        args[_key5 - 3] = arguments[_key5];
      }
      return io.call.apply(void 0, [retry, maxTries, delayLength, worker].concat(args));
    }
    function debounce3(delayLength, pattern, worker) {
      for (var _len6 = arguments.length, args = new Array(_len6 > 3 ? _len6 - 3 : 0), _key6 = 3; _key6 < _len6; _key6++) {
        args[_key6 - 3] = arguments[_key6];
      }
      return io.fork.apply(void 0, [debounceHelper, delayLength, pattern, worker].concat(args));
    }
    exports.actionChannel = io.actionChannel;
    exports.all = io.all;
    exports.apply = io.apply;
    exports.call = io.call;
    exports.cancel = io.cancel;
    exports.cancelled = io.cancelled;
    exports.cps = io.cps;
    exports.delay = io.delay;
    exports.effectTypes = io.effectTypes;
    exports.flush = io.flush;
    exports.fork = io.fork;
    exports.getContext = io.getContext;
    exports.join = io.join;
    exports.put = io.put;
    exports.putResolve = io.putResolve;
    exports.race = io.race;
    exports.select = io.select;
    exports.setContext = io.setContext;
    exports.spawn = io.spawn;
    exports.take = io.take;
    exports.takeMaybe = io.takeMaybe;
    exports.debounce = debounce3;
    exports.retry = retry$1;
    exports.takeEvery = takeEvery$1;
    exports.takeLatest = takeLatest$1;
    exports.takeLeading = takeLeading$1;
    exports.throttle = throttle$1;
  }
});

// ../../node_modules/@redux-saga/core/dist/redux-saga-effects.cjs.js
var require_redux_saga_effects_cjs = __commonJS({
  "../../node_modules/@redux-saga/core/dist/redux-saga-effects.cjs.js"(exports, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_redux_saga_effects_prod_cjs();
    } else {
      module2.exports = require_redux_saga_effects_dev_cjs();
    }
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Chat: () => Chat_exports,
  Messaging: () => Messaging_exports,
  PubSub: () => PubSub_exports,
  Task: () => Task_exports,
  Video: () => Video_exports,
  Voice: () => Voice_exports,
  config: () => config,
  createClient: () => createClient2,
  getConfig: () => getConfig
});
module.exports = __toCommonJS(src_exports);

// src/video/Video.ts
var Video_exports = {};
__export(Video_exports, {
  Client: () => VideoClient,
  createVideoObject: () => createVideoObject
});
var import_core17 = require("@signalwire/core");

// src/AutoSubscribeConsumer.ts
var import_core = require("@signalwire/core");
var AutoSubscribeConsumer = class extends import_core.BaseConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "debouncedSubscribe");
    this.debouncedSubscribe = (0, import_core.debounce)(this.subscribe, 100);
  }
  getSubscriptions() {
    const eventNamesWithPrefix = this.eventNames().map((event) => `video.${String(event)}`);
    return (0, import_core.validateEventsToSubscribe)(eventNamesWithPrefix);
  }
  on(event, fn) {
    const instance = super.on(event, fn);
    this.debouncedSubscribe();
    return instance;
  }
  once(event, fn) {
    const instance = super.once(event, fn);
    this.debouncedSubscribe();
    return instance;
  }
  off(event, fn) {
    const instance = super.off(event, fn);
    return instance;
  }
};

// src/video/RoomSession.ts
var import_core3 = require("@signalwire/core");

// src/video/RoomSessionMember.ts
var import_core2 = require("@signalwire/core");
var RoomSessionMemberComponent = class extends import_core2.BaseComponent {
  constructor(options) {
    super(options);
    __publicField(this, "_payload");
    this._payload = options.payload;
  }
  get id() {
    return this._payload.member.id;
  }
  get memberId() {
    return this._payload.member.id;
  }
  get roomSessionId() {
    return this._payload.member.room_session_id;
  }
  get roomId() {
    return this._payload.member.room_id;
  }
  get parentId() {
    return this._payload.member.parent_id;
  }
  get name() {
    return this._payload.member.name;
  }
  get type() {
    return this._payload.member.type;
  }
  get meta() {
    return this._payload.member.meta;
  }
  get requestedPosition() {
    return this._payload.member.requested_position;
  }
  get visible() {
    return this._payload.member.visible;
  }
  get audioMuted() {
    return this._payload.member.audio_muted;
  }
  get videoMuted() {
    return this._payload.member.video_muted;
  }
  get deaf() {
    return this._payload.member.deaf;
  }
  get inputVolume() {
    return this._payload.member.input_volume;
  }
  get outputVolume() {
    return this._payload.member.output_volume;
  }
  get inputSensitivity() {
    return this._payload.member.input_sensitivity;
  }
  get talking() {
    return this._payload.member.talking;
  }
  get handraised() {
    return this._payload.member.handraised;
  }
  setPayload(payload) {
    const newPayload = __spreadProps(__spreadValues({}, payload), {
      member: __spreadValues(__spreadValues({}, this._payload.member), payload.member)
    });
    this._payload = newPayload;
  }
  remove() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "video.member.remove",
        params: {
          room_session_id: this.getStateProperty("roomSessionId"),
          member_id: this.getStateProperty("memberId")
        }
      });
    });
  }
};
var RoomSessionMemberAPI = (0, import_core2.extendComponent)(RoomSessionMemberComponent, {
  audioMute: import_core2.Rooms.audioMuteMember,
  audioUnmute: import_core2.Rooms.audioUnmuteMember,
  videoMute: import_core2.Rooms.videoMuteMember,
  videoUnmute: import_core2.Rooms.videoUnmuteMember,
  setDeaf: import_core2.Rooms.setDeaf,
  setMicrophoneVolume: import_core2.Rooms.setInputVolumeMember,
  setInputVolume: import_core2.Rooms.setInputVolumeMember,
  setSpeakerVolume: import_core2.Rooms.setOutputVolumeMember,
  setOutputVolume: import_core2.Rooms.setOutputVolumeMember,
  setInputSensitivity: import_core2.Rooms.setInputSensitivityMember,
  setRaisedHand: import_core2.Rooms.setRaisedHand
});
var createRoomSessionMemberObject = (params) => {
  const member = (0, import_core2.connect)({
    store: params.store,
    Component: RoomSessionMemberAPI
  })(params);
  return member;
};

// src/video/RoomSession.ts
var RoomSessionConsumer = class extends import_core3.BaseConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "_payload");
    __publicField(this, "subscribeParams", {
      get_initial_state: true
    });
    __publicField(this, "debouncedSubscribe");
    this._payload = options.payload;
    this.debouncedSubscribe = (0, import_core3.debounce)(this.subscribe, 100);
  }
  get id() {
    return this._payload.room_session.id;
  }
  get roomSessionId() {
    return this._payload.room_session.id;
  }
  get roomId() {
    return this._payload.room_session.room_id;
  }
  get name() {
    return this._payload.room_session.name;
  }
  get displayName() {
    return this._payload.room_session.display_name;
  }
  get hideVideoMuted() {
    return this._payload.room_session.hide_video_muted;
  }
  get layoutName() {
    return this._payload.room_session.layout_name;
  }
  get meta() {
    return this._payload.room_session.meta;
  }
  get previewUrl() {
    return this._payload.room_session.preview_url;
  }
  get recording() {
    return this._payload.room_session.recording;
  }
  get locked() {
    return this._payload.room_session.locked;
  }
  get eventChannel() {
    return this._payload.room_session.event_channel;
  }
  get prioritizeHandraise() {
    return this._payload.room_session.prioritize_handraise;
  }
  getSubscriptions() {
    const eventNamesWithPrefix = this.eventNames().map((event) => `video.${String(event)}`);
    return (0, import_core3.validateEventsToSubscribe)(eventNamesWithPrefix);
  }
  _internal_on(event, fn) {
    return super.on(event, fn);
  }
  on(event, fn) {
    const instance = super.on(event, fn);
    this.debouncedSubscribe();
    return instance;
  }
  once(event, fn) {
    const instance = super.once(event, fn);
    this.debouncedSubscribe();
    return instance;
  }
  off(event, fn) {
    const instance = super.off(event, fn);
    return instance;
  }
  subscribe() {
    return new Promise((resolve, reject) => __async(this, null, function* () {
      const handler = (payload) => {
        resolve(payload);
      };
      const subscriptions = this.getSubscriptions();
      if (subscriptions.length === 0) {
        this.logger.debug("`subscribe()` was called without any listeners attached.");
        return;
      }
      try {
        __superGet(RoomSessionConsumer.prototype, this, "once").call(this, "room.subscribed", handler);
        yield __superGet(RoomSessionConsumer.prototype, this, "subscribe").call(this);
      } catch (error) {
        __superGet(RoomSessionConsumer.prototype, this, "off").call(this, "room.subscribed", handler);
        return reject(error);
      }
    }));
  }
  setPayload(payload) {
    this._payload = payload;
  }
  getMembers() {
    return new Promise((resolve, reject) => __async(this, null, function* () {
      try {
        const { members } = yield this.execute({
          method: "video.members.get",
          params: {
            room_session_id: this.roomSessionId
          }
        });
        const memberInstances = [];
        members.forEach((member) => {
          let memberInstance = this.instanceMap.get(member.id);
          if (!memberInstance) {
            memberInstance = createRoomSessionMemberObject({
              store: this.store,
              payload: {
                room_id: this.roomId,
                room_session_id: this.roomSessionId,
                member
              }
            });
          } else {
            memberInstance.setPayload({
              member
            });
          }
          memberInstances.push(memberInstance);
          this.instanceMap.set(memberInstance.id, memberInstance);
        });
        resolve({ members: memberInstances });
      } catch (error) {
        reject(error);
      }
    }));
  }
};
var RoomSessionAPI = (0, import_core3.extendComponent)(RoomSessionConsumer, {
  videoMute: import_core3.Rooms.videoMuteMember,
  videoUnmute: import_core3.Rooms.videoUnmuteMember,
  audioMute: import_core3.Rooms.audioMuteMember,
  audioUnmute: import_core3.Rooms.audioUnmuteMember,
  deaf: import_core3.Rooms.deafMember,
  undeaf: import_core3.Rooms.undeafMember,
  setInputVolume: import_core3.Rooms.setInputVolumeMember,
  setOutputVolume: import_core3.Rooms.setOutputVolumeMember,
  setMicrophoneVolume: import_core3.Rooms.setInputVolumeMember,
  setSpeakerVolume: import_core3.Rooms.setOutputVolumeMember,
  setInputSensitivity: import_core3.Rooms.setInputSensitivityMember,
  removeMember: import_core3.Rooms.removeMember,
  removeAllMembers: import_core3.Rooms.removeAllMembers,
  setHideVideoMuted: import_core3.Rooms.setHideVideoMuted,
  getLayouts: import_core3.Rooms.getLayouts,
  setLayout: import_core3.Rooms.setLayout,
  setPositions: import_core3.Rooms.setPositions,
  setMemberPosition: import_core3.Rooms.setMemberPosition,
  getRecordings: import_core3.Rooms.getRecordings,
  startRecording: import_core3.Rooms.startRecording,
  getPlaybacks: import_core3.Rooms.getPlaybacks,
  play: import_core3.Rooms.play,
  getMeta: import_core3.Rooms.getMeta,
  setMeta: import_core3.Rooms.setMeta,
  updateMeta: import_core3.Rooms.updateMeta,
  deleteMeta: import_core3.Rooms.deleteMeta,
  getMemberMeta: import_core3.Rooms.getMemberMeta,
  setMemberMeta: import_core3.Rooms.setMemberMeta,
  updateMemberMeta: import_core3.Rooms.updateMemberMeta,
  deleteMemberMeta: import_core3.Rooms.deleteMemberMeta,
  promote: import_core3.Rooms.promote,
  demote: import_core3.Rooms.demote,
  getStreams: import_core3.Rooms.getStreams,
  startStream: import_core3.Rooms.startStream,
  lock: import_core3.Rooms.lock,
  unlock: import_core3.Rooms.unlock,
  setRaisedHand: import_core3.Rooms.setRaisedHand,
  setPrioritizeHandraise: import_core3.Rooms.setPrioritizeHandraise
});
var createRoomSessionObject = (params) => {
  const roomSession = (0, import_core3.connect)({
    store: params.store,
    Component: RoomSessionAPI
  })(params);
  return roomSession;
};

// src/video/workers/videoCallingWorker.ts
var import_core11 = require("@signalwire/core");
var import_effects2 = __toESM(require_redux_saga_effects_cjs());

// src/video/workers/videoRoomWorker.ts
var import_core5 = require("@signalwire/core");
var import_effects = __toESM(require_redux_saga_effects_cjs());

// src/video/workers/videoMemberWorker.ts
var import_core4 = require("@signalwire/core");
var videoMemberWorker = function* (options) {
  (0, import_core4.getLogger)().trace("videoMemberWorker started");
  const {
    instance,
    action: { type, payload },
    instanceMap: { get, set, remove }
  } = options;
  const roomSessionInstance = get(payload.room_session_id);
  if (!roomSessionInstance) {
    throw new Error("Missing room session instance for member");
  }
  let memberInstance = get(payload.member.id);
  if (!memberInstance) {
    memberInstance = createRoomSessionMemberObject({
      store: instance.store,
      payload
    });
  } else {
    memberInstance.setPayload(payload);
  }
  set(payload.member.id, memberInstance);
  const event = (0, import_core4.stripNamespacePrefix)(type);
  if (type.startsWith("video.member.updated.")) {
    const clientType = (0, import_core4.fromSnakeToCamelCase)(event);
    roomSessionInstance.emit(clientType, memberInstance);
  }
  switch (type) {
    case "video.member.joined":
    case "video.member.updated":
      roomSessionInstance.emit(event, memberInstance);
      break;
    case "video.member.left":
      roomSessionInstance.emit(event, memberInstance);
      remove(payload.member.id);
      break;
    case "video.member.talking":
      roomSessionInstance.emit(event, memberInstance);
      if ("talking" in payload.member) {
        const suffix = payload.member.talking ? "started" : "ended";
        roomSessionInstance.emit(`${event}.${suffix}`, memberInstance);
        const deprecatedSuffix = payload.member.talking ? "start" : "stop";
        roomSessionInstance.emit(`${event}.${deprecatedSuffix}`, memberInstance);
      }
      break;
    default:
      break;
  }
  (0, import_core4.getLogger)().trace("videoMemberWorker ended");
};

// src/video/workers/videoRoomWorker.ts
var videoRoomWorker = function* (options) {
  var _b;
  (0, import_core5.getLogger)().trace("videoRoomWorker started");
  const _a = options, { instance: client, action } = _a, memberPositionWorkerParams = __objRest(_a, ["instance", "action"]);
  const { type, payload } = action;
  const { get, set, remove } = options.instanceMap;
  let roomSessionInstance = get(payload.room_session.id);
  if (!roomSessionInstance) {
    roomSessionInstance = createRoomSessionObject({
      store: client.store,
      payload
    });
  } else {
    roomSessionInstance.setPayload(payload);
  }
  set(payload.room_session.id, roomSessionInstance);
  if ((((_b = payload.room_session.members) == null ? void 0 : _b.length) || 0) > 0) {
    ;
    (payload.room_session.members || []).forEach((member) => {
      let memberInstance = get(member.id);
      if (!memberInstance) {
        memberInstance = createRoomSessionMemberObject({
          store: client.store,
          payload: {
            room_id: payload.room_session.room_id,
            room_session_id: payload.room_session.id,
            member
          }
        });
      } else {
        memberInstance.setPayload({
          room_id: payload.room_session.room_id,
          room_session_id: payload.room_session.id,
          member
        });
      }
      set(member.id, memberInstance);
    });
  }
  const event = (0, import_core5.stripNamespacePrefix)(type);
  switch (type) {
    case "video.room.started":
    case "video.room.updated": {
      client.emit(event, roomSessionInstance);
      roomSessionInstance.emit(event, roomSessionInstance);
      break;
    }
    case "video.room.ended": {
      client.emit(event, roomSessionInstance);
      roomSessionInstance.emit(event, roomSessionInstance);
      remove(payload.room_session.id);
      break;
    }
    case "video.room.subscribed": {
      yield (0, import_effects.spawn)(import_core5.MemberPosition.memberPositionWorker, __spreadProps(__spreadValues({}, memberPositionWorkerParams), {
        instance: roomSessionInstance,
        initialState: payload,
        dispatcher: function* (subType, subPayload) {
          yield (0, import_effects.fork)(videoMemberWorker, __spreadProps(__spreadValues({}, options), {
            action: { type: subType, payload: subPayload }
          }));
        }
      }));
      roomSessionInstance.emit(event, roomSessionInstance);
      break;
    }
    default:
      break;
  }
  (0, import_core5.getLogger)().trace("videoRoomWorker ended");
};

// src/video/workers/videoPlaybackWorker.ts
var import_core6 = require("@signalwire/core");
var videoPlaybackWorker = function* (options) {
  (0, import_core6.getLogger)().trace("videoPlaybackWorker started");
  const {
    instance: client,
    action: { type, payload },
    instanceMap: { get, set, remove }
  } = options;
  const roomSessionInstance = get(payload.room_session_id);
  if (!roomSessionInstance) {
    throw new Error("Missing room session instance for playback");
  }
  let playbackInstance = get(payload.playback.id);
  if (!playbackInstance) {
    playbackInstance = import_core6.Rooms.createRoomSessionPlaybackObject({
      store: client.store,
      payload
    });
  } else {
    playbackInstance.setPayload(payload);
  }
  set(payload.playback.id, playbackInstance);
  const event = (0, import_core6.stripNamespacePrefix)(type);
  switch (type) {
    case "video.playback.started":
    case "video.playback.updated":
      roomSessionInstance.emit(event, playbackInstance);
      break;
    case "video.playback.ended":
      roomSessionInstance.emit(event, playbackInstance);
      remove(payload.playback.id);
      break;
    default:
      break;
  }
  (0, import_core6.getLogger)().trace("videoPlaybackWorker ended");
};

// src/video/workers/videoRecordingWorker.ts
var import_core7 = require("@signalwire/core");
var videoRecordingWorker = function* (options) {
  (0, import_core7.getLogger)().trace("videoRecordingWorker started");
  const {
    instance: client,
    action: { type, payload },
    instanceMap: { get, set, remove }
  } = options;
  const roomSessionInstance = get(payload.room_session_id);
  if (!roomSessionInstance) {
    throw new Error("Missing room session instance for playback");
  }
  let recordingInstance = get(payload.recording.id);
  if (!recordingInstance) {
    recordingInstance = import_core7.Rooms.createRoomSessionRecordingObject({
      store: client.store,
      payload
    });
  } else {
    recordingInstance.setPayload(payload);
  }
  set(payload.recording.id, recordingInstance);
  const event = (0, import_core7.stripNamespacePrefix)(type);
  switch (type) {
    case "video.recording.started":
    case "video.recording.updated":
      roomSessionInstance.emit(event, recordingInstance);
      break;
    case "video.recording.ended":
      roomSessionInstance.emit(event, recordingInstance);
      remove(payload.recording.id);
      break;
    default:
      break;
  }
  (0, import_core7.getLogger)().trace("videoRecordingWorker ended");
};

// src/video/workers/videoStreamWorker.ts
var import_core8 = require("@signalwire/core");
var videoStreamWorker = function* (options) {
  (0, import_core8.getLogger)().trace("videoStreamWorker started");
  const {
    instance: client,
    action: { type, payload },
    instanceMap: { get, set, remove }
  } = options;
  const roomSessionInstance = get(payload.room_session_id);
  if (!roomSessionInstance) {
    throw new Error("Missing room session instance for stream");
  }
  let streamInstance = get(payload.stream.id);
  if (!streamInstance) {
    streamInstance = import_core8.Rooms.createRoomSessionStreamObject({
      store: client.store,
      payload
    });
  } else {
    streamInstance.setPayload(payload);
  }
  set(payload.stream.id, streamInstance);
  const event = (0, import_core8.stripNamespacePrefix)(type);
  switch (type) {
    case "video.stream.started":
      roomSessionInstance.emit(event, streamInstance);
      break;
    case "video.stream.ended":
      roomSessionInstance.emit(event, streamInstance);
      remove(payload.stream.id);
      break;
    default:
      break;
  }
  (0, import_core8.getLogger)().trace("videoStreamWorker ended");
};

// src/video/workers/videoLayoutWorker.ts
var import_core9 = require("@signalwire/core");
var videoLayoutWorker = function* (options) {
  (0, import_core9.getLogger)().trace("videoLayoutWorker started");
  const {
    action: { type, payload },
    instanceMap: { get }
  } = options;
  const roomSessionInstance = get(payload.room_session_id);
  if (!roomSessionInstance) {
    throw new Error("Missing room session instance for playback");
  }
  const event = (0, import_core9.stripNamespacePrefix)(type);
  switch (type) {
    case "video.layout.changed":
      roomSessionInstance.emit(event, (0, import_core9.toExternalJSON)(payload));
      break;
    default:
      break;
  }
  (0, import_core9.getLogger)().trace("videoLayoutWorker ended");
};

// src/video/workers/videoRoomAudienceWorker.ts
var import_core10 = require("@signalwire/core");
var videoRoomAudienceWorker = function* (options) {
  (0, import_core10.getLogger)().trace("videoRoomAudienceWorker started");
  const {
    action: { type, payload },
    instanceMap: { get }
  } = options;
  const roomSessionInstance = get(payload.room_session_id);
  if (!roomSessionInstance) {
    throw new Error("Missing room session instance for playback");
  }
  switch (type) {
    case "video.room.audience_count":
      roomSessionInstance.emit("room.audienceCount", (0, import_core10.toExternalJSON)(payload));
      break;
    default:
      break;
  }
  (0, import_core10.getLogger)().trace("videoRoomAudienceWorker ended");
};

// src/video/workers/videoCallingWorker.ts
var videoCallingWorker = function* (options) {
  (0, import_core11.getLogger)().trace("videoCallingWorker started");
  const { channels } = options;
  const { swEventChannel } = channels;
  function* worker(action) {
    const { type } = action;
    switch (type) {
      case "video.room.started":
      case "video.room.updated":
      case "video.room.ended":
      case "video.room.subscribed":
        yield (0, import_effects2.fork)(videoRoomWorker, __spreadValues({
          action
        }, options));
        break;
      case "video.member.joined":
      case "video.member.left":
      case "video.member.updated":
      case "video.member.talking":
        yield (0, import_effects2.fork)(videoMemberWorker, __spreadValues({
          action
        }, options));
        break;
      case "video.playback.started":
      case "video.playback.updated":
      case "video.playback.ended":
        yield (0, import_effects2.fork)(videoPlaybackWorker, __spreadValues({
          action
        }, options));
        break;
      case "video.recording.started":
      case "video.recording.updated":
      case "video.recording.ended":
        yield (0, import_effects2.fork)(videoRecordingWorker, __spreadValues({
          action
        }, options));
        break;
      case "video.stream.started":
      case "video.stream.ended":
        yield (0, import_effects2.fork)(videoStreamWorker, __spreadValues({
          action
        }, options));
        break;
      case "video.layout.changed":
        yield (0, import_effects2.fork)(videoLayoutWorker, __spreadValues({
          action
        }, options));
        break;
      case "video.room.audience_count":
        yield (0, import_effects2.fork)(videoRoomAudienceWorker, __spreadValues({
          action
        }, options));
        break;
      default:
        (0, import_core11.getLogger)().warn(`Unknown video event: "${type}"`);
        break;
    }
  }
  const isVideoEvent = (action) => action.type.startsWith("video.");
  while (true) {
    const action = yield import_core11.sagaEffects.take(swEventChannel, isVideoEvent);
    yield (0, import_effects2.fork)(worker, action);
  }
  (0, import_core11.getLogger)().trace("videoCallingWorker ended");
};

// src/client/Client.ts
var import_core12 = require("@signalwire/core");
var Client = class extends import_core12.BaseClient {
};

// src/client/clientConnect.ts
var clientConnect = (client) => {
  return client.connect().catch(() => {
  });
};

// src/client/setupClient.ts
var import_core16 = require("@signalwire/core");

// src/utils/internals.ts
var import_core14 = require("@signalwire/core");

// src/configure/index.ts
var GLOBAL_CONFIG = {};
var getConfig = () => {
  return GLOBAL_CONFIG;
};
var config = (_a) => {
  var _b = _a, {
    cache = GLOBAL_CONFIG
  } = _b, options = __objRest(_b, [
    "cache"
  ]);
  if (cache) {
    GLOBAL_CONFIG = cache;
  }
  Object.entries(options).forEach(([key, value]) => {
    GLOBAL_CONFIG[key] = value;
  });
};

// src/Session.ts
var import_core13 = require("@signalwire/core");
var import_ws = __toESM(require("ws"));
var Session = class extends import_core13.BaseSession {
  constructor() {
    super(...arguments);
    __publicField(this, "WebSocketConstructor", import_ws.default);
    __publicField(this, "CloseEventConstructor", import_core13.SWCloseEvent);
    __publicField(this, "agent", "@signalwire/nodejs/realtime-api/3.13.0");
  }
};

// src/utils/internals.ts
var setupInternals = (userOptions) => {
  const emitter = (0, import_core14.getEventEmitter)();
  const baseOptions = __spreadProps(__spreadValues({}, userOptions), {
    emitter
  });
  const store = (0, import_core14.configureStore)({
    userOptions: baseOptions,
    SessionConstructor: Session
  });
  return { store, emitter };
};
var getToken = (userToken) => {
  const globalConfig = getConfig();
  const token = userToken || globalConfig.token || process.env.SW_TOKEN;
  if (!token) {
    throw new Error("Missing `token`");
  }
  return token;
};
var getProject = (userProject) => {
  const globalConfig = getConfig();
  const project = userProject || globalConfig.project || process.env.SW_PROJECT;
  if (!project) {
    throw new Error("Missing `project`");
  }
  return project;
};
var getCredentials = (options) => {
  const project = getProject(options == null ? void 0 : options.project);
  const token = getToken(options == null ? void 0 : options.token);
  return { project, token };
};

// src/client/clientProxyFactory.ts
var defaultInterceptors = {
  connect: clientConnect
};
var clientProxyFactory = (client, interceptors = defaultInterceptors) => {
  const clientConnect2 = interceptors.connect || clientConnect;
  const clientOn = (...args) => {
    clientConnect2(client);
    return client.on(...args);
  };
  const clientOnce = (...args) => {
    clientConnect2(client);
    return client.once(...args);
  };
  return new Proxy(client, {
    get(target, prop, receiver) {
      if (prop === "on") {
        return clientOn;
      } else if (prop === "once") {
        return clientOnce;
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/client/getClient.ts
var import_core15 = require("@signalwire/core");
var CLIENTS_MAP = /* @__PURE__ */ new Map();
var createClient = (userOptions) => {
  const client = (0, import_core15.connect)({
    store: userOptions.store,
    Component: Client
  })(userOptions);
  return client;
};
var getClient = (_a) => {
  var _b = _a, {
    cache = CLIENTS_MAP
  } = _b, userOptions = __objRest(_b, [
    "cache"
  ]);
  const { emitter, store } = setupInternals(userOptions);
  const client = createClient(__spreadProps(__spreadValues({}, userOptions), {
    store,
    emitter
  }));
  const config2 = {
    client,
    store,
    emitter
  };
  return config2;
};

// src/client/setupClient.ts
var setupClient = (userOptions) => {
  const credentials = getCredentials({
    token: userOptions == null ? void 0 : userOptions.token,
    project: userOptions == null ? void 0 : userOptions.project
  });
  const { client, store, emitter } = getClient(__spreadValues(__spreadValues({}, userOptions), credentials));
  client.session.on("session.auth_error", () => {
    (0, import_core16.getLogger)().error("Wrong credentials: couldn't connect the client.");
  });
  const proxiedClient = clientProxyFactory(client);
  return {
    client: proxiedClient,
    store,
    emitter
  };
};

// src/video/VideoClient.ts
var VideoClient = function(options) {
  const { client, store } = setupClient(options);
  const video = createVideoObject({
    store
  });
  const videoSubscribe = () => __async(this, null, function* () {
    yield clientConnect(client);
    return video.subscribe();
  });
  const interceptors = {
    subscribe: videoSubscribe,
    _session: client,
    disconnect: () => client.disconnect()
  };
  return new Proxy(video, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (typeof target[prop] === "function") {
        clientConnect(client);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/video/Video.ts
var VideoAPI = class extends AutoSubscribeConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "subscribeParams", {
      get_initial_state: true
    });
    this.runWorker("videoCallWorker", { worker: videoCallingWorker });
  }
  getRoomSessions() {
    return __async(this, null, function* () {
      return new Promise((resolve, reject) => __async(this, null, function* () {
        try {
          const { rooms = [] } = yield this.execute({
            method: "video.rooms.get",
            params: {}
          });
          const roomInstances = [];
          rooms.forEach((room) => {
            let roomInstance = this.instanceMap.get(room.id);
            if (!roomInstance) {
              roomInstance = createRoomSessionObject({
                store: this.store,
                payload: { room_session: room }
              });
            } else {
              roomInstance.setPayload({
                room_session: room
              });
            }
            roomInstances.push(roomInstance);
            this.instanceMap.set(roomInstance.id, roomInstance);
          });
          resolve({ roomSessions: roomInstances });
        } catch (error) {
          console.error("Error listing room sessions", error);
          reject(error);
        }
      }));
    });
  }
  getRoomSessionById(id) {
    return __async(this, null, function* () {
      return new Promise((resolve, reject) => __async(this, null, function* () {
        try {
          const { room } = yield this.execute({
            method: "video.room.get",
            params: {
              room_session_id: id
            }
          });
          let roomInstance = this.instanceMap.get(room.id);
          if (!roomInstance) {
            roomInstance = createRoomSessionObject({
              store: this.store,
              payload: { room_session: room }
            });
          } else {
            roomInstance.setPayload({
              room_session: room
            });
          }
          this.instanceMap.set(roomInstance.id, roomInstance);
          resolve({ roomSession: roomInstance });
        } catch (error) {
          console.error("Error retrieving the room session", error);
          reject(error);
        }
      }));
    });
  }
};
var createVideoObject = (params) => {
  const video = (0, import_core17.connect)({
    store: params.store,
    Component: VideoAPI
  })(params);
  const proxy = new Proxy(video, {
    get(target, prop, receiver) {
      if (prop === "_eventsNamespace") {
        return "";
      } else if (prop === "eventChannel") {
        return "video.rooms";
      }
      return Reflect.get(target, prop, receiver);
    }
  });
  return proxy;
};

// src/createClient.ts
var import_core19 = require("@signalwire/core");

// src/Client.ts
var import_core18 = require("@signalwire/core");
var Client2 = class extends import_core18.BaseClient {
  constructor() {
    super(...arguments);
    __publicField(this, "_consumers", /* @__PURE__ */ new Map());
  }
  onAuth(session) {
    return __async(this, null, function* () {
      try {
        if (session.authStatus === "authorized") {
          this._consumers.forEach((consumer) => {
            consumer.subscribe();
          });
        }
      } catch (error) {
        this.logger.error("Client subscription failed.");
        this.disconnect();
        throw error;
      }
    });
  }
  get video() {
    if (this._consumers.has("video")) {
      return this._consumers.get("video");
    }
    const video = createVideoObject({
      store: this.store
    });
    this._consumers.set("video", video);
    return video;
  }
};

// src/createClient.ts
var createClient2 = (userOptions) => __async(void 0, null, function* () {
  const baseUserOptions = __spreadProps(__spreadValues({}, userOptions), {
    emitter: (0, import_core19.getEventEmitter)()
  });
  const store = (0, import_core19.configureStore)({
    userOptions: baseUserOptions,
    SessionConstructor: Session
  });
  const client = (0, import_core19.connect)({
    store,
    Component: Client2,
    sessionListeners: {
      authStatus: "onAuth"
    }
  })(baseUserOptions);
  return client;
});

// src/chat/Chat.ts
var Chat_exports = {};
__export(Chat_exports, {
  ChatMember: () => import_core21.ChatMember,
  ChatMessage: () => import_core21.ChatMessage,
  Client: () => ChatClient
});
var import_core21 = require("@signalwire/core");

// src/chat/ChatClient.ts
var import_core20 = require("@signalwire/core");
var INTERCEPTED_METHODS = [
  "subscribe",
  "publish",
  "getMessages",
  "getMembers",
  "getMemberState",
  "setMemberState"
];
var UNSUPPORTED_METHODS = ["getAllowedChannels", "updateToken"];
var ChatClient = function(options) {
  const { client, store } = setupClient(options);
  const chat = import_core20.Chat.createBaseChatObject({
    store
  });
  const createInterceptor = (prop) => {
    return (...params) => __async(this, null, function* () {
      yield clientConnect(client);
      return chat[prop](...params);
    });
  };
  const interceptors = {
    _session: client,
    disconnect: () => client.disconnect()
  };
  return new Proxy(chat, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (prop !== "_session" && INTERCEPTED_METHODS.includes(prop)) {
        return createInterceptor(prop);
      } else if (UNSUPPORTED_METHODS.includes(prop)) {
        return void 0;
      }
      if (typeof target[prop] === "function") {
        clientConnect(client);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/pubSub/PubSub.ts
var PubSub_exports = {};
__export(PubSub_exports, {
  Client: () => PubSubClient,
  PubSubMessage: () => import_core23.PubSubMessage
});
var import_core23 = require("@signalwire/core");

// src/pubSub/PubSubClient.ts
var import_core22 = require("@signalwire/core");
var INTERCEPTED_METHODS2 = ["subscribe", "publish"];
var UNSUPPORTED_METHODS2 = ["getAllowedChannels", "updateToken"];
var PubSubClient = function(options) {
  const { client, store } = setupClient(options);
  const pubSub = import_core22.PubSub.createBasePubSubObject({
    store
  });
  const createInterceptor = (prop) => {
    return (...params) => __async(this, null, function* () {
      yield clientConnect(client);
      return pubSub[prop](...params);
    });
  };
  const interceptors = {
    _session: client,
    disconnect: () => client.disconnect()
  };
  return new Proxy(pubSub, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (prop !== "_session" && INTERCEPTED_METHODS2.includes(prop)) {
        return createInterceptor(prop);
      } else if (UNSUPPORTED_METHODS2.includes(prop)) {
        return void 0;
      }
      if (typeof target[prop] === "function") {
        clientConnect(client);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/task/Task.ts
var Task_exports = {};
__export(Task_exports, {
  Client: () => TaskClient,
  createTaskObject: () => createTaskObject,
  send: () => send
});
var import_core25 = require("@signalwire/core");
var import_core26 = require("@signalwire/core");

// src/task/workers.ts
var import_core24 = require("@signalwire/core");
var taskWorker = function* (options) {
  (0, import_core24.getLogger)().trace("taskWorker started");
  const { channels, instance } = options;
  const { swEventChannel } = channels;
  while (true) {
    const action = yield import_core24.sagaEffects.take(swEventChannel, (action2) => {
      return action2.type === "queuing.relay.tasks";
    });
    instance.emit("task.received", action.payload.message);
  }
  (0, import_core24.getLogger)().trace("taskWorker ended");
};

// src/common/clientContext.ts
var clientContextInterceptorsFactory = (client) => {
  return {
    addContexts(contexts) {
      return __async(this, null, function* () {
        yield clientConnect(client);
        const executeParams = {
          method: "signalwire.receive",
          params: {
            contexts
          }
        };
        return client.execute(executeParams);
      });
    },
    removeContexts(contexts) {
      return __async(this, null, function* () {
        yield clientConnect(client);
        const executeParams = {
          method: "signalwire.unreceive",
          params: {
            contexts
          }
        };
        return client.execute(executeParams);
      });
    }
  };
};

// src/task/TaskClient.ts
var TaskClient = function(options) {
  const { client, store } = setupClient(options);
  const task = createTaskObject({
    store
  });
  const disconnect = () => client.disconnect();
  const interceptors = __spreadProps(__spreadValues({}, clientContextInterceptorsFactory(client)), {
    _session: client,
    disconnect
  });
  return new Proxy(task, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (typeof target[prop] === "function") {
        clientConnect(client);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/task/send.ts
var import_node_https = require("https");
var PATH = "/api/relay/rest/tasks";
var HOST = "relay.signalwire.com";
var send = ({
  host = HOST,
  project,
  token,
  context,
  message
}) => {
  if (!project || !token) {
    throw new Error("Invalid options: project and token are required!");
  }
  return new Promise((resolve, reject) => {
    try {
      const Authorization = `Basic ${Buffer.from(`${project}:${token}`).toString("base64")}`;
      const data = JSON.stringify({ context, message });
      const options = {
        host,
        port: 443,
        method: "POST",
        path: PATH,
        headers: {
          Authorization,
          "Content-Type": "application/json",
          "Content-Length": data.length
        }
      };
      const req = (0, import_node_https.request)(options, ({ statusCode }) => {
        statusCode === 204 ? resolve() : reject();
      });
      req.on("error", reject);
      req.write(data);
      req.end();
    } catch (error) {
      reject(error);
    }
  });
};

// src/task/Task.ts
var TaskAPI = class extends import_core25.BaseComponent {
  constructor(options) {
    super(options);
    this.runWorker("taskWorker", {
      worker: taskWorker
    });
  }
};
var createTaskObject = (params) => {
  const task = (0, import_core26.connect)({
    store: params.store,
    Component: TaskAPI
  })(params);
  return task;
};

// src/messaging/Messaging.ts
var Messaging_exports = {};
__export(Messaging_exports, {
  Client: () => MessagingClient,
  Message: () => Message,
  createMessagingObject: () => createMessagingObject
});
var import_core28 = require("@signalwire/core");
var import_core29 = require("@signalwire/core");

// src/messaging/workers/messagingWorker.ts
var import_core27 = require("@signalwire/core");
var messagingWorker = function* (options) {
  (0, import_core27.getLogger)().trace("messagingWorker started");
  const {
    instance: client,
    channels: { swEventChannel }
  } = options;
  function* worker(action) {
    const { payload, type } = action;
    const message = new Message(payload);
    switch (type) {
      case "messaging.receive":
        client.emit("message.received", message);
        break;
      case "messaging.state":
        client.emit("message.updated", message);
        break;
      default:
        (0, import_core27.getLogger)().warn(`Unknown message event: "${action.type}"`);
        break;
    }
  }
  const isMessagingEvent = (action) => action.type.startsWith("messaging.");
  while (true) {
    const action = yield import_core27.sagaEffects.take(swEventChannel, isMessagingEvent);
    yield import_core27.sagaEffects.fork(worker, action);
  }
  (0, import_core27.getLogger)().trace("messagingWorker ended");
};

// src/messaging/MessagingClient.ts
var MessagingClient = function(options) {
  const { client, store } = setupClient(options);
  const messaging = createMessagingObject({
    store
  });
  const send2 = (...args) => __async(this, null, function* () {
    yield clientConnect(client);
    return messaging.send(...args);
  });
  const disconnect = () => client.disconnect();
  const interceptors = __spreadProps(__spreadValues({}, clientContextInterceptorsFactory(client)), {
    send: send2,
    _session: client,
    disconnect
  });
  return new Proxy(messaging, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (typeof target[prop] === "function") {
        clientConnect(client);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/messaging/Message.ts
var Message = class {
  constructor(options) {
    __publicField(this, "id");
    __publicField(this, "state");
    __publicField(this, "context");
    __publicField(this, "from");
    __publicField(this, "to");
    __publicField(this, "body");
    __publicField(this, "direction");
    __publicField(this, "media");
    __publicField(this, "segments");
    __publicField(this, "tags");
    __publicField(this, "reason");
    this.id = options.message_id;
    this.state = options.message_state;
    this.context = options.context;
    this.from = options.from_number;
    this.to = options.to_number;
    this.body = options.body;
    this.direction = options.direction;
    this.media = options.media || [];
    this.segments = options.segments;
    this.tags = options.tags || [];
    this.reason = options.reason;
  }
};

// src/messaging/Messaging.ts
var MessagingAPI = class extends import_core28.BaseConsumer {
  constructor(options) {
    super(options);
    this.runWorker("messagingWorker", {
      worker: messagingWorker
    });
  }
  send(params) {
    return __async(this, null, function* () {
      const _a = params, { from = "", to = "" } = _a, rest = __objRest(_a, ["from", "to"]);
      const sendParams = __spreadProps(__spreadValues({}, rest), {
        from_number: from,
        to_number: to
      });
      try {
        const response = yield this.execute({
          method: "messaging.send",
          params: sendParams
        });
        return (0, import_core28.toExternalJSON)(response);
      } catch (error) {
        this.logger.error("Error sending message", error);
        throw error;
      }
    });
  }
};
var createMessagingObject = (params) => {
  const messaging = (0, import_core29.connect)({
    store: params.store,
    Component: MessagingAPI
  })(params);
  return messaging;
};

// src/voice/Voice.ts
var Voice_exports = {};
__export(Voice_exports, {
  Client: () => VoiceClient,
  DeviceBuilder: () => DeviceBuilder,
  Playlist: () => Playlist,
  createVoiceObject: () => createVoiceObject
});
var import_core49 = require("@signalwire/core");

// src/voice/workers/voiceCallStateWorker.ts
var import_core35 = require("@signalwire/core");

// src/voice/Call.ts
var import_core34 = require("@signalwire/core");

// src/voice/utils.ts
var import_core30 = require("@signalwire/core");
var toInternalDevice = (device) => {
  switch (device.type) {
    case "sip": {
      const _a = device, { type } = _a, params = __objRest(_a, ["type"]);
      return {
        type,
        params: (0, import_core30.toSnakeCaseKeys)(params)
      };
    }
    case "phone": {
      const _b = device, { to, from, type } = _b, rest = __objRest(_b, ["to", "from", "type"]);
      return {
        type,
        params: (0, import_core30.toSnakeCaseKeys)(__spreadProps(__spreadValues({}, rest), {
          to_number: to,
          from_number: from
        }))
      };
    }
  }
  return device;
};
var toInternalDevices = (params, internalDevices = []) => {
  params.forEach((dev, index) => {
    if (Array.isArray(dev)) {
      internalDevices[index] = toInternalDevices(dev);
    } else {
      internalDevices[index] = toInternalDevice(dev);
    }
  });
  return internalDevices;
};
var toInternalPlay = (media) => {
  const _a = media, { type } = _a, params = __objRest(_a, ["type"]);
  return { type, params };
};
var toInternalPlayParams = (params, result = []) => {
  params.forEach((media, index) => {
    if (Array.isArray(media)) {
      result[index] = toInternalPlayParams(media);
    } else {
      result[index] = toInternalPlay(media);
    }
  });
  return result;
};

// src/voice/Playlist.ts
var Playlist = class {
  constructor(params = {}) {
    this.params = params;
    __publicField(this, "_media", []);
  }
  get volume() {
    var _a;
    return (_a = this.params) == null ? void 0 : _a.volume;
  }
  get media() {
    return this._media;
  }
  add(params) {
    this._media.push(params);
    return this;
  }
  static Audio(params) {
    return __spreadValues({ type: "audio" }, params);
  }
  static TTS(params) {
    return __spreadValues({ type: "tts" }, params);
  }
  static Silence(params) {
    return __spreadValues({ type: "silence" }, params);
  }
  static Ringtone(params) {
    return __spreadValues({ type: "ringtone" }, params);
  }
};

// src/voice/CallPrompt.ts
var import_core31 = require("@signalwire/core");
var ENDED_STATES = [
  "no_input",
  "error",
  "no_match",
  "digit",
  "speech"
];
var CallPromptAPI = class extends import_core31.BaseConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "_payload");
    this._payload = options.payload;
  }
  get id() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.control_id.split(".")[0];
  }
  get controlId() {
    return this._payload.control_id;
  }
  get callId() {
    return this._payload.call_id;
  }
  get nodeId() {
    return this._payload.node_id;
  }
  get result() {
    return this._payload.result;
  }
  get type() {
    var _a;
    return (_a = this.result) == null ? void 0 : _a.type;
  }
  get reason() {
    return this.type;
  }
  get digits() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "digit") {
      return this.result.params.digits;
    }
    return void 0;
  }
  get speech() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "speech") {
      return this.result.params.text;
    }
    return void 0;
  }
  get terminator() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "digit") {
      return this.result.params.terminator;
    }
    return void 0;
  }
  get text() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "speech") {
      return this.result.params.text;
    }
    return void 0;
  }
  get confidence() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "speech") {
      return this.result.params.confidence;
    }
    return void 0;
  }
  setPayload(payload) {
    this._payload = payload;
  }
  stop() {
    return __async(this, null, function* () {
      if (!this.result) {
        yield this.execute({
          method: "calling.play_and_collect.stop",
          params: {
            node_id: this.nodeId,
            call_id: this.callId,
            control_id: this.controlId
          }
        });
      }
      return this;
    });
  }
  setVolume(volume) {
    return __async(this, null, function* () {
      yield this.execute({
        method: "calling.play_and_collect.volume",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: this.controlId,
          volume
        }
      });
      return this;
    });
  }
  waitForResult() {
    return this.ended();
  }
  ended() {
    var _a;
    if (ENDED_STATES.includes((_a = this.result) == null ? void 0 : _a.type)) {
      return Promise.resolve(this);
    }
    return new Promise((resolve) => {
      const handler = (_callPrompt) => {
        this.off("prompt.ended", handler);
        this.off("prompt.failed", handler);
        resolve(this);
      };
      this.once("prompt.ended", handler);
      this.once("prompt.failed", handler);
    });
  }
};
var createCallPromptObject = (params) => {
  const record = (0, import_core31.connect)({
    store: params.store,
    Component: CallPromptAPI
  })(params);
  return record;
};

// src/voice/CallDetect.ts
var import_core32 = require("@signalwire/core");
var ENDED_STATES2 = ["finished", "error"];
var CallDetectAPI = class extends import_core32.BaseConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "_payload");
    __publicField(this, "_waitForBeep");
    __publicField(this, "_result", "UNKNOWN");
    this._payload = options.payload;
    this._waitForBeep = options.payload.waitForBeep;
  }
  get id() {
    return this._payload.control_id;
  }
  get controlId() {
    return this._payload.control_id;
  }
  get callId() {
    return this._payload.call_id;
  }
  get nodeId() {
    return this._payload.node_id;
  }
  get detect() {
    return this._payload.detect;
  }
  get type() {
    var _a;
    return (_a = this == null ? void 0 : this.detect) == null ? void 0 : _a.type;
  }
  get result() {
    return this._result;
  }
  get waitForBeep() {
    return this._waitForBeep;
  }
  get beep() {
    var _a;
    if (((_a = this.detect) == null ? void 0 : _a.params.event) === "MACHINE") {
      return Boolean(this.detect.params.beep);
    }
    return void 0;
  }
  setPayload(payload) {
    this._payload = payload;
    const lastEvent = this._lastEvent();
    if (lastEvent && lastEvent !== "finished") {
      this._result = lastEvent;
    }
  }
  stop() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "calling.detect.stop",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: this.controlId
        }
      });
      return this;
    });
  }
  waitForResult() {
    return this.ended();
  }
  ended() {
    const lastEvent = this._lastEvent();
    if (lastEvent && ENDED_STATES2.includes(lastEvent)) {
      return Promise.resolve(this);
    }
    return new Promise((resolve) => {
      const handler = () => {
        this.off("detect.ended", handler);
        resolve(this);
      };
      this.once("detect.ended", handler);
    });
  }
  _lastEvent() {
    var _a;
    return (_a = this.detect) == null ? void 0 : _a.params.event;
  }
};
var createCallDetectObject = (params) => {
  const detect = (0, import_core32.connect)({
    store: params.store,
    Component: CallDetectAPI
  })(params);
  return detect;
};

// src/voice/CallCollect.ts
var import_core33 = require("@signalwire/core");
var ENDED_STATES3 = [
  "error",
  "no_input",
  "no_match",
  "digit",
  "speech"
];
var CallCollectAPI = class extends import_core33.BaseConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "_payload");
    this._payload = options.payload;
  }
  get id() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.control_id.split(".")[0];
  }
  get controlId() {
    return this._payload.control_id;
  }
  get callId() {
    return this._payload.call_id;
  }
  get nodeId() {
    return this._payload.node_id;
  }
  get result() {
    return this._payload.result;
  }
  get type() {
    var _a;
    return (_a = this.result) == null ? void 0 : _a.type;
  }
  get reason() {
    return this.type;
  }
  get digits() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "digit") {
      return this.result.params.digits;
    }
    return void 0;
  }
  get speech() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "speech") {
      return this.result.params.text;
    }
    return void 0;
  }
  get terminator() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "digit") {
      return this.result.params.terminator;
    }
    return void 0;
  }
  get text() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "speech") {
      return this.result.params.text;
    }
    return void 0;
  }
  get confidence() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "speech") {
      return this.result.params.confidence;
    }
    return void 0;
  }
  get state() {
    return this._payload.state;
  }
  get final() {
    return this._payload.final;
  }
  setPayload(payload) {
    this._payload = payload;
  }
  stop() {
    return __async(this, null, function* () {
      if (!this.result) {
        yield this.execute({
          method: "calling.collect.stop",
          params: {
            node_id: this.nodeId,
            call_id: this.callId,
            control_id: this.controlId
          }
        });
      }
      return this;
    });
  }
  startInputTimers() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "calling.collect.start_input_timers",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: this.controlId
        }
      });
      return this;
    });
  }
  ended() {
    var _a;
    if (this.state != "collecting" && this.final !== false && ENDED_STATES3.includes((_a = this.result) == null ? void 0 : _a.type)) {
      return Promise.resolve(this);
    }
    return new Promise((resolve) => {
      const handler = (_callCollect) => {
        this.off("collect.ended", handler);
        this.off("collect.failed", handler);
        resolve(this);
      };
      this.once("collect.ended", handler);
      this.once("collect.failed", handler);
    });
  }
};
var createCallCollectObject = (params) => {
  const collect = (0, import_core33.connect)({
    store: params.store,
    Component: CallCollectAPI
  })(params);
  return collect;
};

// src/voice/DeviceBuilder.ts
var DeviceBuilder = class {
  constructor() {
    __publicField(this, "_devices", []);
  }
  get devices() {
    return this._devices;
  }
  add(params) {
    if (Array.isArray(params)) {
      this._devices.push(params);
    } else {
      this._devices.push([params]);
    }
    return this;
  }
  static Phone(params) {
    return __spreadValues({ type: "phone" }, params);
  }
  static Sip(params) {
    return __spreadValues({ type: "sip" }, params);
  }
};

// src/voice/Call.ts
var CallConsumer = class extends import_core34.BaseConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "_peer");
    __publicField(this, "_payload");
    __publicField(this, "_connectPayload");
    __publicField(this, "detectAnsweringMachine", this.amd);
    this._payload = options.payload;
    this.on("call.state", () => {
    });
  }
  get id() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.call_id;
  }
  get callId() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.call_id;
  }
  get state() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.call_state;
  }
  get callState() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.call_state;
  }
  get tag() {
    return this.__uuid;
  }
  get nodeId() {
    return this._payload.node_id;
  }
  get device() {
    return this._payload.device;
  }
  get type() {
    var _a, _b;
    return (_b = (_a = this.device) == null ? void 0 : _a.type) != null ? _b : "";
  }
  get from() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (this.type === "phone") {
      return (_e = ((_b = (_a = this.device) == null ? void 0 : _a.params) == null ? void 0 : _b.from_number) || ((_d = (_c = this.device) == null ? void 0 : _c.params) == null ? void 0 : _d.fromNumber)) != null ? _e : "";
    }
    return (_h = (_g = (_f = this.device) == null ? void 0 : _f.params) == null ? void 0 : _g.from) != null ? _h : "";
  }
  get to() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (this.type === "phone") {
      return (_e = ((_b = (_a = this.device) == null ? void 0 : _a.params) == null ? void 0 : _b.to_number) || ((_d = (_c = this.device) == null ? void 0 : _c.params) == null ? void 0 : _d.toNumber)) != null ? _e : "";
    }
    return (_h = (_g = (_f = this.device) == null ? void 0 : _f.params) == null ? void 0 : _g.to) != null ? _h : "";
  }
  get headers() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.device) == null ? void 0 : _a.params) == null ? void 0 : _b.headers) != null ? _c : [];
  }
  get active() {
    return this.state === "answered";
  }
  get connected() {
    return this.connectState === "connected";
  }
  get direction() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.direction;
  }
  get context() {
    return this._payload.context;
  }
  get connectState() {
    var _a;
    return (_a = this._connectPayload) == null ? void 0 : _a.connect_state;
  }
  get peer() {
    return this._peer;
  }
  set peer(callInstance) {
    this._peer = callInstance;
  }
  setPayload(payload) {
    this._payload = payload;
  }
  setConnectPayload(payload) {
    this._connectPayload = payload;
  }
  hangup(reason = "hangup") {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call hangup() on a call that hasn't been established.`));
      }
      this.on("call.state", (params) => {
        if (params.state === "ended") {
          resolve(new Error("Failed to hangup the call."));
        }
      });
      this.execute({
        method: "calling.end",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          reason
        }
      }).catch((e) => {
        reject(e);
      });
    });
  }
  pass() {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call pass() on a call without callId.`));
      }
      this.execute({
        method: "calling.pass",
        params: {
          node_id: this.nodeId,
          call_id: this.callId
        }
      }).then(() => {
        resolve();
      }).catch((e) => {
        reject(e);
      });
    });
  }
  answer() {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call answer() on a call without callId.`));
      }
      this.on("call.state", (params) => {
        if (params.state === "answered") {
          resolve(this);
        } else if (params.state === "ended") {
          reject(new Error("Failed to answer the call."));
        }
      });
      this.execute({
        method: "calling.answer",
        params: {
          node_id: this.nodeId,
          call_id: this.callId
        }
      }).catch((e) => {
        reject(e);
      });
    });
  }
  play(params) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call play() on a call not established yet.`));
      }
      const resolveHandler = (callPlayback) => {
        this.off("playback.failed", rejectHandler);
        resolve(callPlayback);
      };
      const rejectHandler = (callPlayback) => {
        this.off("playback.started", resolveHandler);
        reject(callPlayback);
      };
      this.once("playback.started", resolveHandler);
      this.once("playback.failed", rejectHandler);
      const controlId = (0, import_core34.uuid)();
      this.execute({
        method: "calling.play",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          volume: params.volume,
          play: toInternalPlayParams(params.media)
        }
      }).then(() => {
      }).catch((e) => {
        this.off("playback.started", resolveHandler);
        this.off("playback.failed", rejectHandler);
        reject(e);
      });
    });
  }
  playAudio(params) {
    const _a = params, { volume } = _a, rest = __objRest(_a, ["volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.Audio(rest));
    return this.play(playlist);
  }
  playSilence(params) {
    const playlist = new Playlist().add(Playlist.Silence(params));
    return this.play(playlist);
  }
  playRingtone(params) {
    const _a = params, { volume } = _a, rest = __objRest(_a, ["volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.Ringtone(rest));
    return this.play(playlist);
  }
  playTTS(params) {
    const _a = params, { volume } = _a, rest = __objRest(_a, ["volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.TTS(rest));
    return this.play(playlist);
  }
  record(params) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call record() on a call not established yet.`));
      }
      const resolveHandler = (callRecording) => {
        this.off("recording.failed", rejectHandler);
        resolve(callRecording);
      };
      const rejectHandler = (callRecording) => {
        this.off("recording.started", resolveHandler);
        reject(callRecording);
      };
      this.once("recording.started", resolveHandler);
      this.once("recording.failed", rejectHandler);
      const controlId = (0, import_core34.uuid)();
      const record = (0, import_core34.toSnakeCaseKeys)(params);
      this.execute({
        method: "calling.record",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          record
        }
      }).then(() => {
      }).catch((e) => {
        this.off("recording.started", resolveHandler);
        this.off("recording.failed", rejectHandler);
        reject(e);
      });
    });
  }
  recordAudio(params = {}) {
    return this.record({
      audio: params
    });
  }
  prompt(params) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call record() on a call not established yet.`));
      }
      if (!params.playlist) {
        reject(new Error(`Missing 'playlist' params.`));
      }
      const controlId = `${(0, import_core34.uuid)()}.prompt`;
      const { volume, media } = params.playlist;
      const { initial_timeout, digits, speech } = (0, import_core34.toSnakeCaseKeys)(params);
      const collect = {
        initial_timeout,
        digits,
        speech
      };
      this.execute({
        method: "calling.play_and_collect",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          volume,
          play: toInternalPlayParams(media),
          collect
        }
      }).then(() => {
        const promptInstance = createCallPromptObject({
          store: this.store,
          payload: {
            control_id: controlId,
            call_id: this.id,
            node_id: this.nodeId
          }
        });
        this.instanceMap.set(controlId, promptInstance);
        this.emit("prompt.started", promptInstance);
        resolve(promptInstance);
      }).catch((e) => {
        this.emit("prompt.failed", e);
        reject(e);
      });
    });
  }
  promptAudio(params) {
    const _a = params, { url, volume } = _a, rest = __objRest(_a, ["url", "volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.Audio({ url }));
    return this.prompt(__spreadValues({
      playlist
    }, rest));
  }
  promptRingtone(params) {
    const _a = params, { name, duration, volume } = _a, rest = __objRest(_a, ["name", "duration", "volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.Ringtone({ name, duration }));
    return this.prompt(__spreadValues({
      playlist
    }, rest));
  }
  promptTTS(params) {
    const _a = params, { text, language, gender, volume } = _a, rest = __objRest(_a, ["text", "language", "gender", "volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.TTS({ text, language, gender }));
    return this.prompt(__spreadValues({
      playlist
    }, rest));
  }
  sendDigits(digits) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call sendDigits() on a call not established yet.`));
      }
      const callStateHandler = (params) => {
        if (params.callState === "ended" || params.callState === "ending") {
          reject(new Error("Call is ended or about to end, couldn't send digits in time."));
        }
      };
      this.once("call.state", callStateHandler);
      const cleanup = () => {
        this.off("call.state", callStateHandler);
      };
      const resolveHandler = (call) => {
        cleanup();
        this.off("send_digits.failed", rejectHandler);
        resolve(call);
      };
      const rejectHandler = (error) => {
        cleanup();
        this.off("send_digits.finished", resolveHandler);
        reject(error);
      };
      this.once("send_digits.finished", resolveHandler);
      this.once("send_digits.failed", rejectHandler);
      const controlId = (0, import_core34.uuid)();
      this.execute({
        method: "calling.send_digits",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          digits
        }
      }).catch((e) => {
        reject(e);
      });
    });
  }
  tap(params) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call tap() on a call not established yet.`));
      }
      const resolveHandler = (callTap) => {
        this.off("tap.ended", rejectHandler);
        resolve(callTap);
      };
      const rejectHandler = (callTap) => {
        this.off("tap.started", resolveHandler);
        reject(callTap);
      };
      this.once("tap.started", resolveHandler);
      this.once("tap.ended", rejectHandler);
      const controlId = (0, import_core34.uuid)();
      const {
        audio = {},
        device: _a
      } = params, _b = _a, { type } = _b, rest = __objRest(_b, ["type"]);
      this.execute({
        method: "calling.tap",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          tap: {
            type: "audio",
            params: audio
          },
          device: {
            type,
            params: rest
          }
        }
      }).then(() => {
      }).catch((e) => {
        this.off("tap.started", resolveHandler);
        this.off("tap.ended", rejectHandler);
        reject(e);
      });
    });
  }
  tapAudio(params) {
    const { direction, device } = params;
    return this.tap({ audio: { direction }, device });
  }
  connect(params) {
    return new Promise((resolve, reject) => {
      var _b, _c;
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call connect() on a call not established yet.`));
      }
      const _a = params, { devices, ringback } = _a, rest = __objRest(_a, ["devices", "ringback"]);
      const executeParams = __spreadValues({
        tag: this.__uuid
      }, (0, import_core34.toSnakeCaseKeys)(rest));
      if ("ringback" in params) {
        executeParams.ringback = toInternalPlayParams((_c = (_b = params.ringback) == null ? void 0 : _b.media) != null ? _c : []);
      }
      if (params instanceof DeviceBuilder) {
        executeParams.devices = toInternalDevices(params.devices);
      } else if (devices instanceof DeviceBuilder) {
        executeParams.devices = toInternalDevices(devices.devices);
      } else {
        throw new Error('[connect] Invalid "devices" parameter.');
      }
      const resolveHandler = (payload) => {
        this.off("connect.failed", rejectHandler);
        resolve(payload);
      };
      const rejectHandler = (payload) => {
        this.off("connect.connected", resolveHandler);
        reject((0, import_core34.toExternalJSON)(payload));
      };
      this.once("connect.connected", resolveHandler);
      this.once("connect.failed", rejectHandler);
      this.execute({
        method: "calling.connect",
        params: __spreadValues({
          node_id: this.nodeId,
          call_id: this.callId,
          tag: this.__uuid
        }, executeParams)
      }).catch((e) => {
        this.off("connect.connected", resolveHandler);
        this.off("connect.failed", rejectHandler);
        reject(e);
      });
    });
  }
  connectPhone(_a) {
    var _b = _a, {
      ringback,
      maxPricePerMinute
    } = _b, params = __objRest(_b, [
      "ringback",
      "maxPricePerMinute"
    ]);
    const devices = new DeviceBuilder().add(DeviceBuilder.Phone(params));
    return this.connect({ devices, maxPricePerMinute, ringback });
  }
  connectSip(_c) {
    var _d = _c, {
      ringback,
      maxPricePerMinute
    } = _d, params = __objRest(_d, [
      "ringback",
      "maxPricePerMinute"
    ]);
    const devices = new DeviceBuilder().add(DeviceBuilder.Sip(params));
    return this.connect({ devices, maxPricePerMinute, ringback });
  }
  disconnect() {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId || !this.peer) {
        reject(new Error(`Can't call disconnect() on a call not connected yet.`));
      }
      const resolveHandler = () => {
        resolve();
      };
      this.once("connect.disconnected", resolveHandler);
      this.execute({
        method: "calling.disconnect",
        params: {
          node_id: this.nodeId,
          call_id: this.callId
        }
      }).catch((e) => {
        this.off("connect.disconnected", resolveHandler);
        reject(e);
      });
    });
  }
  waitForDisconnected() {
    return this.disconnect;
  }
  disconnected() {
    return new Promise((resolve) => {
      const resolveHandler = () => {
        resolve(this);
      };
      this.once("connect.disconnected", resolveHandler);
      this.once("connect.failed", resolveHandler);
      if (this.state === "ended" || this.state === "ending") {
        return resolveHandler();
      }
    });
  }
  detect(params) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call detect() on a call not established yet.`));
      }
      const controlId = (0, import_core34.uuid)();
      const _a = params, { timeout, type, waitForBeep = false } = _a, rest = __objRest(_a, ["timeout", "type", "waitForBeep"]);
      this.execute({
        method: "calling.detect",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          timeout,
          detect: {
            type,
            params: (0, import_core34.toSnakeCaseKeys)(rest)
          }
        }
      }).then(() => {
        const detectInstance = createCallDetectObject({
          store: this.store,
          payload: {
            control_id: controlId,
            call_id: this.id,
            node_id: this.nodeId,
            waitForBeep
          }
        });
        this.instanceMap.set(controlId, detectInstance);
        this.emit("detect.started", detectInstance);
        resolve(detectInstance);
      }).catch((e) => {
        this.emit("detect.ended", e);
        reject(e);
      });
    });
  }
  amd(params = {}) {
    return this.detect(__spreadProps(__spreadValues({}, params), {
      type: "machine"
    }));
  }
  detectFax(params = {}) {
    return this.detect(__spreadProps(__spreadValues({}, params), {
      type: "fax"
    }));
  }
  detectDigit(params = {}) {
    return this.detect(__spreadProps(__spreadValues({}, params), {
      type: "digit"
    }));
  }
  waitFor(params) {
    return new Promise((resolve) => {
      if (!params) {
        resolve(true);
      }
      const events = Array.isArray(params) ? params : [params];
      const emittedCallStates = /* @__PURE__ */ new Set();
      const shouldResolve = () => emittedCallStates.size === events.length;
      const shouldWaitForEnded = events.includes("ended");
      const shouldResolveUnsuccessful = (state) => {
        return !shouldWaitForEnded && state === "ended";
      };
      this.on("call.state", (params2) => {
        if (events.includes(params2.state)) {
          emittedCallStates.add(params2.state);
        } else if (shouldResolveUnsuccessful(params2.state)) {
          return resolve(false);
        }
        if (shouldResolve()) {
          resolve(true);
        }
      });
    });
  }
  collect(params) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call collect() on a call not established yet.`));
      }
      const controlId = (0, import_core34.uuid)();
      const {
        initial_timeout,
        partial_results,
        digits,
        speech,
        continuous,
        send_start_of_input,
        start_input_timers
      } = (0, import_core34.toSnakeCaseKeys)(params);
      this.execute({
        method: "calling.collect",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          initial_timeout,
          digits,
          speech,
          partial_results,
          continuous,
          send_start_of_input,
          start_input_timers
        }
      }).then(() => {
        const collectInstance = createCallCollectObject({
          store: this.store,
          payload: {
            control_id: controlId,
            call_id: this.id,
            node_id: this.nodeId
          }
        });
        this.instanceMap.set(controlId, collectInstance);
        this.emit("collect.started", collectInstance);
        resolve(collectInstance);
      }).catch((e) => {
        this.emit("collect.failed", e);
        reject(e);
      });
    });
  }
};
var CallAPI = (0, import_core34.extendComponent)(CallConsumer, {});
var createCallObject = (params) => {
  const call = (0, import_core34.connect)({
    store: params.store,
    Component: CallAPI
  })(params);
  return call;
};

// src/voice/workers/voiceCallStateWorker.ts
var voiceCallStateWorker = function* (options) {
  (0, import_core35.getLogger)().trace("voiceCallStateWorker started");
  const {
    instance: client,
    payload,
    instanceMap: { get, set, remove }
  } = options;
  let callInstance = get(payload.call_id);
  if (!callInstance) {
    callInstance = createCallObject({
      store: client.store,
      payload
    });
  } else {
    callInstance.setPayload(payload);
  }
  set(payload.call_id, callInstance);
  switch (payload.call_state) {
    case "ended": {
      callInstance.emit("call.state", callInstance);
      callInstance.emit("connect.disconnected", callInstance);
      remove(payload.call_id);
      break;
    }
    default:
      callInstance.emit("call.state", callInstance);
      break;
  }
  (0, import_core35.getLogger)().trace("voiceCallStateWorker ended");
};

// src/voice/workers/voiceCallReceiveWorker.ts
var import_core36 = require("@signalwire/core");
var voiceCallReceiveWorker = function* (options) {
  var _a;
  (0, import_core36.getLogger)().trace("voiceCallReceiveWorker started");
  const {
    instance: client,
    payload,
    instanceMap: { get, set }
  } = options;
  const { contexts = [], topics = [] } = (_a = client == null ? void 0 : client.options) != null ? _a : {};
  if (!contexts.length && !topics.length) {
    throw new Error("Invalid contexts to receive inbound calls");
  }
  let callInstance = get(payload.call_id);
  if (!callInstance) {
    callInstance = createCallObject({
      store: client.store,
      payload
    });
  } else {
    callInstance.setPayload(payload);
  }
  set(payload.call_id, callInstance);
  client.emit("call.received", callInstance);
  (0, import_core36.getLogger)().trace("voiceCallReceiveWorker ended");
};

// src/voice/workers/voiceCallPlayWorker.ts
var import_core38 = require("@signalwire/core");

// src/voice/CallPlayback.ts
var import_core37 = require("@signalwire/core");
var ENDED_STATES4 = ["finished", "error"];
var CallPlaybackAPI = class extends import_core37.BaseConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "_paused");
    __publicField(this, "_volume");
    __publicField(this, "_payload");
    this._payload = options.payload;
    this._paused = false;
  }
  get id() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.control_id.split(".")[0];
  }
  get volume() {
    return this._volume;
  }
  get callId() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.call_id;
  }
  get nodeId() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.node_id;
  }
  get controlId() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.control_id;
  }
  get state() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.state;
  }
  setPayload(payload) {
    this._payload = payload;
  }
  pause() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "calling.play.pause",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: this.controlId
        }
      });
      return this;
    });
  }
  resume() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "calling.play.resume",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: this.controlId
        }
      });
      return this;
    });
  }
  stop() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "calling.play.stop",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: this.controlId
        }
      });
      return this;
    });
  }
  setVolume(volume) {
    return __async(this, null, function* () {
      this._volume = volume;
      yield this.execute({
        method: "calling.play.volume",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: this.controlId,
          volume
        }
      });
      return this;
    });
  }
  waitForEnded() {
    return this.ended();
  }
  ended() {
    return new Promise((resolve) => {
      const handler = () => {
        this.off("playback.ended", handler);
        this.off("playback.failed", handler);
        resolve(this);
      };
      this.once("playback.ended", handler);
      this.once("playback.failed", handler);
      if (ENDED_STATES4.includes(this.state)) {
        handler();
      }
    });
  }
};
var createCallPlaybackObject = (params) => {
  const playback = (0, import_core37.connect)({
    store: params.store,
    Component: CallPlaybackAPI
  })(params);
  return playback;
};

// src/voice/workers/voiceCallPlayWorker.ts
var voiceCallPlayWorker = function* (options) {
  (0, import_core38.getLogger)().trace("voiceCallPlayWorker started");
  const {
    payload,
    instanceMap: { get, set, remove }
  } = options;
  const callInstance = get(payload.call_id);
  if (!callInstance) {
    throw new Error("Missing call instance for playback");
  }
  const [controlId] = payload.control_id.split(".");
  (0, import_core38.getLogger)().trace("voiceCallPlayWorker controlId", controlId);
  let playbackInstance = get(controlId);
  if (!playbackInstance) {
    (0, import_core38.getLogger)().trace("voiceCallPlayWorker create instance");
    playbackInstance = createCallPlaybackObject({
      store: callInstance.store,
      payload
    });
  } else {
    (0, import_core38.getLogger)().trace("voiceCallPlayWorker GOT instance");
    playbackInstance.setPayload(payload);
  }
  set(controlId, playbackInstance);
  switch (payload.state) {
    case "playing": {
      const type = playbackInstance._paused ? "playback.updated" : "playback.started";
      playbackInstance._paused = false;
      callInstance.emit(type, playbackInstance);
      break;
    }
    case "paused": {
      playbackInstance._paused = true;
      callInstance.emit("playback.updated", playbackInstance);
      break;
    }
    case "error": {
      callInstance.emit("playback.failed", playbackInstance);
      playbackInstance.emit("playback.failed", playbackInstance);
      remove(controlId);
      break;
    }
    case "finished": {
      callInstance.emit("playback.ended", playbackInstance);
      playbackInstance.emit("playback.ended", playbackInstance);
      remove(controlId);
      break;
    }
    default:
      (0, import_core38.getLogger)().warn(`Unknown playback state: "${payload.state}"`);
      break;
  }
  (0, import_core38.getLogger)().trace("voiceCallPlayWorker ended");
};

// src/voice/workers/voiceCallRecordWorker.ts
var import_core40 = require("@signalwire/core");

// src/voice/CallRecording.ts
var import_core39 = require("@signalwire/core");
var ENDED_STATES5 = ["finished", "no_input"];
var CallRecordingAPI = class extends import_core39.BaseConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "_paused");
    __publicField(this, "_payload");
    this._payload = options.payload;
    this._paused = false;
  }
  get id() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.control_id;
  }
  get callId() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.call_id;
  }
  get nodeId() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.node_id;
  }
  get controlId() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.control_id;
  }
  get state() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.state;
  }
  get url() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.url;
  }
  get size() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.size;
  }
  get duration() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.duration;
  }
  get record() {
    var _a;
    return (_a = this._payload) == null ? void 0 : _a.record;
  }
  setPayload(payload) {
    this._payload = payload;
  }
  pause(params) {
    return __async(this, null, function* () {
      const { behavior = "silence" } = params || {};
      yield this.execute({
        method: "calling.record.pause",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: this.controlId,
          behavior
        }
      });
      return this;
    });
  }
  resume() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "calling.record.resume",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: this.controlId
        }
      });
      return this;
    });
  }
  stop() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "calling.record.stop",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: this.controlId
        }
      });
      return this;
    });
  }
  ended() {
    return new Promise((resolve) => {
      const handler = () => {
        this.off("recording.ended", handler);
        this.off("recording.failed", handler);
        resolve(this);
      };
      this.once("recording.ended", handler);
      this.once("recording.failed", handler);
      if (ENDED_STATES5.includes(this.state)) {
        handler();
      }
    });
  }
};
var createCallRecordingObject = (params) => {
  const record = (0, import_core39.connect)({
    store: params.store,
    Component: CallRecordingAPI
  })(params);
  return record;
};

// src/voice/workers/voiceCallRecordWorker.ts
var voiceCallRecordWorker = function* (options) {
  (0, import_core40.getLogger)().trace("voiceCallRecordWorker started");
  const {
    payload,
    instanceMap: { get, set, remove }
  } = options;
  const callInstance = get(payload.call_id);
  if (!callInstance) {
    throw new Error("Missing call instance for recording");
  }
  let recordingInstance = get(payload.control_id);
  if (!recordingInstance) {
    recordingInstance = createCallRecordingObject({
      store: callInstance.store,
      payload
    });
  } else {
    recordingInstance.setPayload(payload);
  }
  set(payload.control_id, recordingInstance);
  switch (payload.state) {
    case "recording": {
      const type = recordingInstance._paused ? "recording.updated" : "recording.started";
      recordingInstance._paused = false;
      callInstance.emit(type, recordingInstance);
      break;
    }
    case "paused": {
      recordingInstance._paused = true;
      callInstance.emit("recording.updated", recordingInstance);
      break;
    }
    case "no_input":
    case "finished": {
      const type = payload.state === "finished" ? "recording.ended" : "recording.failed";
      callInstance.emit(type, recordingInstance);
      recordingInstance.emit(type, recordingInstance);
      remove(payload.control_id);
      break;
    }
    default:
      (0, import_core40.getLogger)().warn(`Unknown recording state: "${payload.state}"`);
      break;
  }
  (0, import_core40.getLogger)().trace("voiceCallRecordWorker ended");
};

// src/voice/workers/voiceCallCollectWorker.ts
var import_core41 = require("@signalwire/core");
var voiceCallCollectWorker = function* (options) {
  (0, import_core41.getLogger)().trace("voiceCallCollectWorker started");
  const {
    payload,
    instanceMap: { get, set, remove }
  } = options;
  const callInstance = get(payload.call_id);
  if (!callInstance) {
    throw new Error("Missing call instance for collect");
  }
  const actionInstance = get(payload.control_id);
  if (!actionInstance) {
    throw new Error("Missing the instance");
  }
  actionInstance.setPayload(payload);
  set(payload.control_id, actionInstance);
  let eventPrefix = "collect";
  if (actionInstance instanceof CallPromptAPI) {
    eventPrefix = "prompt";
  }
  if (payload.final === false) {
    callInstance.emit(`${eventPrefix}.updated`, actionInstance);
  } else {
    if (payload.result) {
      switch (payload.result.type) {
        case "start_of_input": {
          callInstance.emit(`${eventPrefix}.startOfInput`, actionInstance);
          break;
        }
        case "no_input":
        case "no_match":
        case "error": {
          if (payload.state !== "collecting") {
            callInstance.emit(`${eventPrefix}.failed`, actionInstance);
            actionInstance.emit(`${eventPrefix}.failed`, actionInstance);
            remove(payload.control_id);
          }
          break;
        }
        case "speech":
        case "digit": {
          if (payload.state !== "collecting") {
            callInstance.emit(`${eventPrefix}.ended`, actionInstance);
            actionInstance.emit(`${eventPrefix}.ended`, actionInstance);
            remove(payload.control_id);
          }
          break;
        }
        default:
          (0, import_core41.getLogger)().warn(`Unknown prompt result type: "${payload.result.type}"`);
          break;
      }
    }
  }
  (0, import_core41.getLogger)().trace("voiceCallCollectWorker ended");
};

// src/voice/workers/voiceCallTapWorker.ts
var import_core43 = require("@signalwire/core");

// src/voice/CallTap.ts
var import_core42 = require("@signalwire/core");
var ENDED_STATES6 = ["finished"];
var CallTapAPI = class extends import_core42.BaseConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "_payload");
    this._payload = options.payload;
  }
  get id() {
    return this._payload.control_id;
  }
  get controlId() {
    return this._payload.control_id;
  }
  get nodeId() {
    return this._payload.node_id;
  }
  get callId() {
    return this._payload.call_id;
  }
  get state() {
    return this._payload.state;
  }
  setPayload(payload) {
    this._payload = payload;
  }
  stop() {
    return __async(this, null, function* () {
      if (this.state !== "finished") {
        yield this.execute({
          method: "calling.tap.stop",
          params: {
            node_id: this.nodeId,
            call_id: this.callId,
            control_id: this.controlId
          }
        });
      }
      return this;
    });
  }
  ended() {
    if (ENDED_STATES6.includes(this.state)) {
      return Promise.resolve(this);
    }
    return new Promise((resolve) => {
      const handler = () => {
        this.off("tap.ended", handler);
        resolve(this);
      };
      this.once("tap.ended", handler);
    });
  }
};
var createCallTapObject = (params) => {
  const tap = (0, import_core42.connect)({
    store: params.store,
    Component: CallTapAPI
  })(params);
  return tap;
};

// src/voice/workers/voiceCallTapWorker.ts
var voiceCallTapWorker = function* (options) {
  (0, import_core43.getLogger)().trace("voiceCallTapWorker started");
  const {
    payload,
    instanceMap: { get, set, remove }
  } = options;
  const callInstance = get(payload.call_id);
  if (!callInstance) {
    throw new Error("Missing call instance for tap");
  }
  let tapInstance = get(payload.control_id);
  if (!tapInstance) {
    tapInstance = createCallTapObject({
      store: callInstance.store,
      payload
    });
  } else {
    tapInstance.setPayload(payload);
  }
  set(payload.control_id, tapInstance);
  switch (payload.state) {
    case "tapping":
      callInstance.emit("tap.started", tapInstance);
      break;
    case "finished":
      callInstance.emit("tap.ended", tapInstance);
      tapInstance.emit("tap.ended", tapInstance);
      remove(payload.control_id);
      break;
    default:
      (0, import_core43.getLogger)().warn(`Unknown tap state: "${payload.state}"`);
      break;
  }
  (0, import_core43.getLogger)().trace("voiceCallTapWorker ended");
};

// src/voice/workers/voiceCallConnectWorker.ts
var import_core44 = require("@signalwire/core");
var voiceCallConnectWorker = function* (options) {
  (0, import_core44.getLogger)().trace("voiceCallConnectWorker started");
  const {
    instance: client,
    payload,
    instanceMap: { get, set }
  } = options;
  const callInstance = get(payload.call_id);
  if (!callInstance) {
    throw new Error("Missing call instance for connect");
  }
  callInstance.setConnectPayload(payload);
  set(payload.call_id, callInstance);
  switch (payload.connect_state) {
    case "connecting": {
      callInstance.emit("connect.connecting", callInstance);
      break;
    }
    case "connected": {
      let peerCallInstance = get(payload.peer.call_id);
      if (!peerCallInstance) {
        peerCallInstance = createCallObject({
          store: client.store,
          connectPayload: payload
        });
      } else {
        peerCallInstance.setConnectPayload(payload);
      }
      set(payload.peer.call_id, peerCallInstance);
      callInstance.peer = peerCallInstance;
      peerCallInstance.peer = callInstance;
      callInstance.emit("connect.connected", peerCallInstance);
      break;
    }
    case "disconnected": {
      const peerCallInstance = get(payload.peer.call_id);
      callInstance.emit("connect.disconnected");
      callInstance.peer = void 0;
      if (peerCallInstance) {
        peerCallInstance.emit("connect.disconnected");
        peerCallInstance.peer = void 0;
      }
      break;
    }
    case "failed": {
      callInstance.peer = void 0;
      callInstance.emit("connect.failed");
      break;
    }
    default:
      (0, import_core44.getLogger)().warn(`Unknown connect state: "${payload.connect_state}"`);
      break;
  }
  callInstance.emit("call.state", callInstance);
  (0, import_core44.getLogger)().trace("voiceCallConnectWorker ended");
};

// src/voice/workers/voiceCallDialWorker.ts
var import_core45 = require("@signalwire/core");
var voiceCallDialWorker = function* (options) {
  (0, import_core45.getLogger)().trace("voiceCallDialWorker started");
  const {
    instance: client,
    payload,
    instanceMap: { get },
    initialState
  } = options;
  if (payload.tag && payload.tag !== initialState.tag)
    return;
  switch (payload.dial_state) {
    case "failed": {
      client.emit("dial.failed", payload);
      break;
    }
    case "answered": {
      const callInstance = get(payload.call.call_id);
      callInstance.setPayload(payload.call);
      client.emit("dial.answered", callInstance);
      break;
    }
    default:
      break;
  }
  (0, import_core45.getLogger)().trace("voiceCallDialWorker ended");
};

// src/voice/workers/VoiceCallSendDigitWorker.ts
var import_core46 = require("@signalwire/core");
var voiceCallSendDigitsWorker = function* (options) {
  (0, import_core46.getLogger)().trace("voiceCallSendDigitsWorker started");
  const {
    payload,
    instanceMap: { get }
  } = options;
  const callInstance = get(payload.call_id);
  if (!callInstance) {
    throw new Error("Missing call instance for send digits");
  }
  switch (payload.state) {
    case "finished":
      callInstance.emit("send_digits.finished", callInstance);
      break;
    default: {
      const error = new Error(`[voiceCallSendDigitsWorker] unhandled state: '${payload.state}'`);
      callInstance.emit("send_digits.failed", error);
      break;
    }
  }
  (0, import_core46.getLogger)().trace("voiceCallSendDigitsWorker ended");
};

// src/voice/workers/voiceCallDetectWorker.ts
var import_core47 = require("@signalwire/core");
var voiceCallDetectWorker = function* (options) {
  (0, import_core47.getLogger)().trace("voiceCallDetectWorker started");
  const {
    payload,
    instanceMap: { get, set, remove }
  } = options;
  const callInstance = get(payload.call_id);
  if (!callInstance) {
    throw new Error("Missing call instance for collect");
  }
  let detectInstance = get(payload.control_id);
  if (!detectInstance) {
    detectInstance = createCallDetectObject({
      store: callInstance.store,
      payload
    });
  } else {
    detectInstance.setPayload(payload);
  }
  set(payload.control_id, detectInstance);
  const { detect } = payload;
  if (!detect)
    return;
  const { type, params } = detect;
  const { event } = params;
  switch (event) {
    case "finished":
    case "error": {
      callInstance.emit("detect.ended", detectInstance);
      detectInstance.emit("detect.ended", detectInstance);
      remove(payload.control_id);
      return;
    }
    default:
      callInstance.emit("detect.updated", detectInstance);
      break;
  }
  switch (type) {
    case "machine":
      if (params.beep && detectInstance.waitForBeep) {
        callInstance.emit("detect.ended", detectInstance);
        detectInstance.emit("detect.ended", detectInstance);
      }
      break;
    case "digit":
    case "fax":
      break;
    default:
      (0, import_core47.getLogger)().warn(`Unknown detect type: "${type}"`);
      break;
  }
  (0, import_core47.getLogger)().trace("voiceCallDetectWorker ended");
};

// src/voice/workers/voiceCallingWorker.ts
var import_core48 = require("@signalwire/core");
var import_effects3 = __toESM(require_redux_saga_effects_cjs());
var voiceCallingWroker = function* (options) {
  (0, import_core48.getLogger)().trace("voiceCallingWroker started");
  const {
    channels: { swEventChannel }
  } = options;
  function* worker(action) {
    const { type, payload } = action;
    switch (type) {
      case "calling.call.state":
        yield (0, import_effects3.fork)(voiceCallStateWorker, __spreadProps(__spreadValues({}, options), {
          payload
        }));
        break;
      case "calling.call.dial":
        yield (0, import_effects3.fork)(voiceCallDialWorker, __spreadProps(__spreadValues({}, options), {
          payload
        }));
        break;
      case "calling.call.receive":
        yield (0, import_effects3.fork)(voiceCallReceiveWorker, __spreadProps(__spreadValues({}, options), {
          payload
        }));
        break;
      case "calling.call.play":
        yield (0, import_effects3.fork)(voiceCallPlayWorker, __spreadProps(__spreadValues({}, options), {
          payload
        }));
        break;
      case "calling.call.record":
        yield (0, import_effects3.fork)(voiceCallRecordWorker, __spreadProps(__spreadValues({}, options), {
          payload
        }));
        break;
      case "calling.call.collect":
        yield (0, import_effects3.fork)(voiceCallCollectWorker, __spreadProps(__spreadValues({}, options), {
          payload
        }));
        break;
      case "calling.call.send_digits":
        yield (0, import_effects3.fork)(voiceCallSendDigitsWorker, __spreadProps(__spreadValues({}, options), {
          payload
        }));
        break;
      case "calling.call.detect":
        yield (0, import_effects3.fork)(voiceCallDetectWorker, __spreadProps(__spreadValues({}, options), {
          payload
        }));
        break;
      case "calling.call.tap":
        yield (0, import_effects3.fork)(voiceCallTapWorker, __spreadProps(__spreadValues({}, options), {
          payload
        }));
        break;
      case "calling.call.connect":
        yield (0, import_effects3.fork)(voiceCallConnectWorker, __spreadProps(__spreadValues({}, options), {
          payload
        }));
        break;
      default:
        (0, import_core48.getLogger)().warn(`Unknown call event: "${type}"`);
        break;
    }
  }
  const workerCatchable = import_core48.sagaHelpers.createCatchableSaga(worker, (error) => {
    (0, import_core48.getLogger)().error("Voice calling event error", error);
  });
  const isCallingEvent = (action) => action.type.startsWith("calling.");
  while (true) {
    const action = yield import_core48.sagaEffects.take(swEventChannel, isCallingEvent);
    yield import_core48.sagaEffects.fork(workerCatchable, action);
  }
  (0, import_core48.getLogger)().trace("voiceCallingWroker ended");
};

// src/voice/VoiceClient.ts
var VoiceClient = function(options) {
  const { client, store } = setupClient(options);
  const voice = createVoiceObject(__spreadValues({
    store
  }, options));
  const dial = (dialer) => __async(this, null, function* () {
    yield clientConnect(client);
    return voice.dial(dialer);
  });
  const disconnect = () => client.disconnect();
  const interceptors = __spreadProps(__spreadValues({}, clientContextInterceptorsFactory(client)), {
    dial,
    _session: client,
    disconnect
  });
  return new Proxy(voice, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (typeof target[prop] === "function") {
        clientConnect(client);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/voice/Voice.ts
var VoiceAPI = class extends import_core49.BaseConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "_tag");
    this._tag = (0, import_core49.uuid)();
    this.runWorker("voiceCallingWorker", {
      worker: voiceCallingWroker,
      initialState: {
        tag: this._tag
      }
    });
  }
  dial(params) {
    return new Promise((resolve, reject) => {
      const resolveHandler = (call) => {
        this.off("dial.failed", rejectHandler);
        resolve(call);
      };
      const rejectHandler = (error) => {
        this.off("dial.answered", resolveHandler);
        reject((0, import_core49.toExternalJSON)(error));
      };
      this.once("dial.answered", resolveHandler);
      this.once("dial.failed", rejectHandler);
      let executeParams;
      if (params instanceof DeviceBuilder) {
        const { devices } = params;
        executeParams = {
          tag: this._tag,
          devices: toInternalDevices(devices)
        };
      } else if ("region" in params) {
        const { region, nodeId, devices: deviceBuilder } = params;
        executeParams = {
          tag: this._tag,
          region,
          node_id: nodeId,
          devices: toInternalDevices(deviceBuilder.devices)
        };
      } else {
        throw new Error("[dial] Invalid input");
      }
      this.execute({
        method: "calling.dial",
        params: executeParams
      }).catch((e) => {
        reject(e);
      });
    });
  }
  dialPhone(_a) {
    var _b = _a, {
      region,
      maxPricePerMinute,
      nodeId
    } = _b, params = __objRest(_b, [
      "region",
      "maxPricePerMinute",
      "nodeId"
    ]);
    const devices = new DeviceBuilder().add(DeviceBuilder.Phone(params));
    return this.dial({
      maxPricePerMinute,
      region,
      nodeId,
      devices
    });
  }
  dialSip(_c) {
    var _d = _c, {
      region,
      maxPricePerMinute,
      nodeId
    } = _d, params = __objRest(_d, [
      "region",
      "maxPricePerMinute",
      "nodeId"
    ]);
    const devices = new DeviceBuilder().add(DeviceBuilder.Sip(params));
    return this.dial({
      maxPricePerMinute,
      region,
      nodeId,
      devices
    });
  }
};
var createVoiceObject = (params) => {
  const voice = (0, import_core49.connect)({
    store: params.store,
    Component: VoiceAPI
  })(params);
  return voice;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Chat,
  Messaging,
  PubSub,
  Task,
  Video,
  Voice,
  config,
  createClient,
  getConfig
});
//# sourceMappingURL=index.node.js.map
